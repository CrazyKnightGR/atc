// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_world_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_world_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_world_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_world_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_world_2eproto;
namespace world_proto {
class Aircraft;
class AircraftDefaultTypeInternal;
extern AircraftDefaultTypeInternal _Aircraft_default_instance_;
class Aircraft_Situation;
class Aircraft_SituationDefaultTypeInternal;
extern Aircraft_SituationDefaultTypeInternal _Aircraft_Situation_default_instance_;
class Airport;
class AirportDefaultTypeInternal;
extern AirportDefaultTypeInternal _Airport_default_instance_;
class AirspaceGeometry;
class AirspaceGeometryDefaultTypeInternal;
extern AirspaceGeometryDefaultTypeInternal _AirspaceGeometry_default_instance_;
class Attitude;
class AttitudeDefaultTypeInternal;
extern AttitudeDefaultTypeInternal _Attitude_default_instance_;
class ClientToServer;
class ClientToServerDefaultTypeInternal;
extern ClientToServerDefaultTypeInternal _ClientToServer_default_instance_;
class ClientToServer_Connect;
class ClientToServer_ConnectDefaultTypeInternal;
extern ClientToServer_ConnectDefaultTypeInternal _ClientToServer_Connect_default_instance_;
class ClientToServer_CreateAircraft;
class ClientToServer_CreateAircraftDefaultTypeInternal;
extern ClientToServer_CreateAircraftDefaultTypeInternal _ClientToServer_CreateAircraft_default_instance_;
class ClientToServer_QueryAirport;
class ClientToServer_QueryAirportDefaultTypeInternal;
extern ClientToServer_QueryAirportDefaultTypeInternal _ClientToServer_QueryAirport_default_instance_;
class ClientToServer_QueryTaxiPath;
class ClientToServer_QueryTaxiPathDefaultTypeInternal;
extern ClientToServer_QueryTaxiPathDefaultTypeInternal _ClientToServer_QueryTaxiPath_default_instance_;
class ClientToServer_RemoveAircraft;
class ClientToServer_RemoveAircraftDefaultTypeInternal;
extern ClientToServer_RemoveAircraftDefaultTypeInternal _ClientToServer_RemoveAircraft_default_instance_;
class ClientToServer_UpdateAircraftSituation;
class ClientToServer_UpdateAircraftSituationDefaultTypeInternal;
extern ClientToServer_UpdateAircraftSituationDefaultTypeInternal _ClientToServer_UpdateAircraftSituation_default_instance_;
class ControlFacility;
class ControlFacilityDefaultTypeInternal;
extern ControlFacilityDefaultTypeInternal _ControlFacility_default_instance_;
class ControlledAirspace;
class ControlledAirspaceDefaultTypeInternal;
extern ControlledAirspaceDefaultTypeInternal _ControlledAirspace_default_instance_;
class GeoBox;
class GeoBoxDefaultTypeInternal;
extern GeoBoxDefaultTypeInternal _GeoBox_default_instance_;
class GeoPoint;
class GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class GeoPolygon;
class GeoPolygonDefaultTypeInternal;
extern GeoPolygonDefaultTypeInternal _GeoPolygon_default_instance_;
class GeoPolygon_GeoEdge;
class GeoPolygon_GeoEdgeDefaultTypeInternal;
extern GeoPolygon_GeoEdgeDefaultTypeInternal _GeoPolygon_GeoEdge_default_instance_;
class ParkingStand;
class ParkingStandDefaultTypeInternal;
extern ParkingStandDefaultTypeInternal _ParkingStand_default_instance_;
class Runway;
class RunwayDefaultTypeInternal;
extern RunwayDefaultTypeInternal _Runway_default_instance_;
class Runway_End;
class Runway_EndDefaultTypeInternal;
extern Runway_EndDefaultTypeInternal _Runway_End_default_instance_;
class ServerToClient;
class ServerToClientDefaultTypeInternal;
extern ServerToClientDefaultTypeInternal _ServerToClient_default_instance_;
class ServerToClient_FaultDeclined;
class ServerToClient_FaultDeclinedDefaultTypeInternal;
extern ServerToClient_FaultDeclinedDefaultTypeInternal _ServerToClient_FaultDeclined_default_instance_;
class ServerToClient_FaultNotFound;
class ServerToClient_FaultNotFoundDefaultTypeInternal;
extern ServerToClient_FaultNotFoundDefaultTypeInternal _ServerToClient_FaultNotFound_default_instance_;
class ServerToClient_NotifyAircraftCreated;
class ServerToClient_NotifyAircraftCreatedDefaultTypeInternal;
extern ServerToClient_NotifyAircraftCreatedDefaultTypeInternal _ServerToClient_NotifyAircraftCreated_default_instance_;
class ServerToClient_NotifyAircraftRemoved;
class ServerToClient_NotifyAircraftRemovedDefaultTypeInternal;
extern ServerToClient_NotifyAircraftRemovedDefaultTypeInternal _ServerToClient_NotifyAircraftRemoved_default_instance_;
class ServerToClient_NotifyAircraftSituationUpdated;
class ServerToClient_NotifyAircraftSituationUpdatedDefaultTypeInternal;
extern ServerToClient_NotifyAircraftSituationUpdatedDefaultTypeInternal _ServerToClient_NotifyAircraftSituationUpdated_default_instance_;
class ServerToClient_ReplyConnect;
class ServerToClient_ReplyConnectDefaultTypeInternal;
extern ServerToClient_ReplyConnectDefaultTypeInternal _ServerToClient_ReplyConnect_default_instance_;
class ServerToClient_ReplyCreateAircraft;
class ServerToClient_ReplyCreateAircraftDefaultTypeInternal;
extern ServerToClient_ReplyCreateAircraftDefaultTypeInternal _ServerToClient_ReplyCreateAircraft_default_instance_;
class ServerToClient_ReplyQueryAirport;
class ServerToClient_ReplyQueryAirportDefaultTypeInternal;
extern ServerToClient_ReplyQueryAirportDefaultTypeInternal _ServerToClient_ReplyQueryAirport_default_instance_;
class ServerToClient_ReplyQueryTaxiPath;
class ServerToClient_ReplyQueryTaxiPathDefaultTypeInternal;
extern ServerToClient_ReplyQueryTaxiPathDefaultTypeInternal _ServerToClient_ReplyQueryTaxiPath_default_instance_;
class TaxiEdge;
class TaxiEdgeDefaultTypeInternal;
extern TaxiEdgeDefaultTypeInternal _TaxiEdge_default_instance_;
class TaxiEdge_ActiveZoneMatrix;
class TaxiEdge_ActiveZoneMatrixDefaultTypeInternal;
extern TaxiEdge_ActiveZoneMatrixDefaultTypeInternal _TaxiEdge_ActiveZoneMatrix_default_instance_;
class TaxiNode;
class TaxiNodeDefaultTypeInternal;
extern TaxiNodeDefaultTypeInternal _TaxiNode_default_instance_;
class TaxiPath;
class TaxiPathDefaultTypeInternal;
extern TaxiPathDefaultTypeInternal _TaxiPath_default_instance_;
class Vector3d;
class Vector3dDefaultTypeInternal;
extern Vector3dDefaultTypeInternal _Vector3d_default_instance_;
}  // namespace world_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::world_proto::Aircraft* Arena::CreateMaybeMessage<::world_proto::Aircraft>(Arena*);
template<> ::world_proto::Aircraft_Situation* Arena::CreateMaybeMessage<::world_proto::Aircraft_Situation>(Arena*);
template<> ::world_proto::Airport* Arena::CreateMaybeMessage<::world_proto::Airport>(Arena*);
template<> ::world_proto::AirspaceGeometry* Arena::CreateMaybeMessage<::world_proto::AirspaceGeometry>(Arena*);
template<> ::world_proto::Attitude* Arena::CreateMaybeMessage<::world_proto::Attitude>(Arena*);
template<> ::world_proto::ClientToServer* Arena::CreateMaybeMessage<::world_proto::ClientToServer>(Arena*);
template<> ::world_proto::ClientToServer_Connect* Arena::CreateMaybeMessage<::world_proto::ClientToServer_Connect>(Arena*);
template<> ::world_proto::ClientToServer_CreateAircraft* Arena::CreateMaybeMessage<::world_proto::ClientToServer_CreateAircraft>(Arena*);
template<> ::world_proto::ClientToServer_QueryAirport* Arena::CreateMaybeMessage<::world_proto::ClientToServer_QueryAirport>(Arena*);
template<> ::world_proto::ClientToServer_QueryTaxiPath* Arena::CreateMaybeMessage<::world_proto::ClientToServer_QueryTaxiPath>(Arena*);
template<> ::world_proto::ClientToServer_RemoveAircraft* Arena::CreateMaybeMessage<::world_proto::ClientToServer_RemoveAircraft>(Arena*);
template<> ::world_proto::ClientToServer_UpdateAircraftSituation* Arena::CreateMaybeMessage<::world_proto::ClientToServer_UpdateAircraftSituation>(Arena*);
template<> ::world_proto::ControlFacility* Arena::CreateMaybeMessage<::world_proto::ControlFacility>(Arena*);
template<> ::world_proto::ControlledAirspace* Arena::CreateMaybeMessage<::world_proto::ControlledAirspace>(Arena*);
template<> ::world_proto::GeoBox* Arena::CreateMaybeMessage<::world_proto::GeoBox>(Arena*);
template<> ::world_proto::GeoPoint* Arena::CreateMaybeMessage<::world_proto::GeoPoint>(Arena*);
template<> ::world_proto::GeoPolygon* Arena::CreateMaybeMessage<::world_proto::GeoPolygon>(Arena*);
template<> ::world_proto::GeoPolygon_GeoEdge* Arena::CreateMaybeMessage<::world_proto::GeoPolygon_GeoEdge>(Arena*);
template<> ::world_proto::ParkingStand* Arena::CreateMaybeMessage<::world_proto::ParkingStand>(Arena*);
template<> ::world_proto::Runway* Arena::CreateMaybeMessage<::world_proto::Runway>(Arena*);
template<> ::world_proto::Runway_End* Arena::CreateMaybeMessage<::world_proto::Runway_End>(Arena*);
template<> ::world_proto::ServerToClient* Arena::CreateMaybeMessage<::world_proto::ServerToClient>(Arena*);
template<> ::world_proto::ServerToClient_FaultDeclined* Arena::CreateMaybeMessage<::world_proto::ServerToClient_FaultDeclined>(Arena*);
template<> ::world_proto::ServerToClient_FaultNotFound* Arena::CreateMaybeMessage<::world_proto::ServerToClient_FaultNotFound>(Arena*);
template<> ::world_proto::ServerToClient_NotifyAircraftCreated* Arena::CreateMaybeMessage<::world_proto::ServerToClient_NotifyAircraftCreated>(Arena*);
template<> ::world_proto::ServerToClient_NotifyAircraftRemoved* Arena::CreateMaybeMessage<::world_proto::ServerToClient_NotifyAircraftRemoved>(Arena*);
template<> ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* Arena::CreateMaybeMessage<::world_proto::ServerToClient_NotifyAircraftSituationUpdated>(Arena*);
template<> ::world_proto::ServerToClient_ReplyConnect* Arena::CreateMaybeMessage<::world_proto::ServerToClient_ReplyConnect>(Arena*);
template<> ::world_proto::ServerToClient_ReplyCreateAircraft* Arena::CreateMaybeMessage<::world_proto::ServerToClient_ReplyCreateAircraft>(Arena*);
template<> ::world_proto::ServerToClient_ReplyQueryAirport* Arena::CreateMaybeMessage<::world_proto::ServerToClient_ReplyQueryAirport>(Arena*);
template<> ::world_proto::ServerToClient_ReplyQueryTaxiPath* Arena::CreateMaybeMessage<::world_proto::ServerToClient_ReplyQueryTaxiPath>(Arena*);
template<> ::world_proto::TaxiEdge* Arena::CreateMaybeMessage<::world_proto::TaxiEdge>(Arena*);
template<> ::world_proto::TaxiEdge_ActiveZoneMatrix* Arena::CreateMaybeMessage<::world_proto::TaxiEdge_ActiveZoneMatrix>(Arena*);
template<> ::world_proto::TaxiNode* Arena::CreateMaybeMessage<::world_proto::TaxiNode>(Arena*);
template<> ::world_proto::TaxiPath* Arena::CreateMaybeMessage<::world_proto::TaxiPath>(Arena*);
template<> ::world_proto::Vector3d* Arena::CreateMaybeMessage<::world_proto::Vector3d>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace world_proto {

enum Aircraft_Category : int {
  Aircraft_Category_AIRCRAFT_CATEGORY_NONE = 0,
  Aircraft_Category_AIRCRAFT_CATEGORY_HEAVY = 1,
  Aircraft_Category_AIRCRAFT_CATEGORY_JET = 2,
  Aircraft_Category_AIRCRAFT_CATEGORY_TURBOPROP = 4,
  Aircraft_Category_AIRCRAFT_CATEGORY_PROP = 8,
  Aircraft_Category_AIRCRAFT_CATEGORY_LIGHT_PROP = 16,
  Aircraft_Category_AIRCRAFT_CATEGORY_HELICPOTER = 32,
  Aircraft_Category_Aircraft_Category_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Aircraft_Category_Aircraft_Category_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Aircraft_Category_IsValid(int value);
constexpr Aircraft_Category Aircraft_Category_Category_MIN = Aircraft_Category_AIRCRAFT_CATEGORY_NONE;
constexpr Aircraft_Category Aircraft_Category_Category_MAX = Aircraft_Category_AIRCRAFT_CATEGORY_HELICPOTER;
constexpr int Aircraft_Category_Category_ARRAYSIZE = Aircraft_Category_Category_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Aircraft_Category_descriptor();
template<typename T>
inline const std::string& Aircraft_Category_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Aircraft_Category>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Aircraft_Category_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Aircraft_Category_descriptor(), enum_t_value);
}
inline bool Aircraft_Category_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Aircraft_Category* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Aircraft_Category>(
    Aircraft_Category_descriptor(), name, value);
}
enum Aircraft_OperationType : int {
  Aircraft_OperationType_AIRCRAFT_OPERATION_NONE = 0,
  Aircraft_OperationType_AIRCRAFT_OPERATION_GA = 1,
  Aircraft_OperationType_AIRCRAFT_OPERATION_AIRLINE = 2,
  Aircraft_OperationType_AIRCRAFT_OPERATION_CARGO = 3,
  Aircraft_OperationType_AIRCRAFT_OPERATION_MILITARY = 8,
  Aircraft_OperationType_Aircraft_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Aircraft_OperationType_Aircraft_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Aircraft_OperationType_IsValid(int value);
constexpr Aircraft_OperationType Aircraft_OperationType_OperationType_MIN = Aircraft_OperationType_AIRCRAFT_OPERATION_NONE;
constexpr Aircraft_OperationType Aircraft_OperationType_OperationType_MAX = Aircraft_OperationType_AIRCRAFT_OPERATION_MILITARY;
constexpr int Aircraft_OperationType_OperationType_ARRAYSIZE = Aircraft_OperationType_OperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Aircraft_OperationType_descriptor();
template<typename T>
inline const std::string& Aircraft_OperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Aircraft_OperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Aircraft_OperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Aircraft_OperationType_descriptor(), enum_t_value);
}
inline bool Aircraft_OperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Aircraft_OperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Aircraft_OperationType>(
    Aircraft_OperationType_descriptor(), name, value);
}
enum TaxiEdge_Type : int {
  TaxiEdge_Type_TAXI_EDGE_GROUNDWAY = 0,
  TaxiEdge_Type_TAXI_EDGE_TAXIWAY = 1,
  TaxiEdge_Type_TAXI_EDGE_RUNWAY = 2,
  TaxiEdge_Type_TaxiEdge_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaxiEdge_Type_TaxiEdge_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaxiEdge_Type_IsValid(int value);
constexpr TaxiEdge_Type TaxiEdge_Type_Type_MIN = TaxiEdge_Type_TAXI_EDGE_GROUNDWAY;
constexpr TaxiEdge_Type TaxiEdge_Type_Type_MAX = TaxiEdge_Type_TAXI_EDGE_RUNWAY;
constexpr int TaxiEdge_Type_Type_ARRAYSIZE = TaxiEdge_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaxiEdge_Type_descriptor();
template<typename T>
inline const std::string& TaxiEdge_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaxiEdge_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaxiEdge_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaxiEdge_Type_descriptor(), enum_t_value);
}
inline bool TaxiEdge_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaxiEdge_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaxiEdge_Type>(
    TaxiEdge_Type_descriptor(), name, value);
}
enum ParkingStand_Type : int {
  ParkingStand_Type_PARKING_UNKNOWN = 0,
  ParkingStand_Type_PARKING_GATE = 1,
  ParkingStand_Type_PARKING_REMOTE = 2,
  ParkingStand_Type_PARKING_HANGAR = 3,
  ParkingStand_Type_ParkingStand_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ParkingStand_Type_ParkingStand_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ParkingStand_Type_IsValid(int value);
constexpr ParkingStand_Type ParkingStand_Type_Type_MIN = ParkingStand_Type_PARKING_UNKNOWN;
constexpr ParkingStand_Type ParkingStand_Type_Type_MAX = ParkingStand_Type_PARKING_HANGAR;
constexpr int ParkingStand_Type_Type_ARRAYSIZE = ParkingStand_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParkingStand_Type_descriptor();
template<typename T>
inline const std::string& ParkingStand_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParkingStand_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParkingStand_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParkingStand_Type_descriptor(), enum_t_value);
}
inline bool ParkingStand_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParkingStand_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParkingStand_Type>(
    ParkingStand_Type_descriptor(), name, value);
}
enum GeoPolygon_GeoEdgeType : int {
  GeoPolygon_GeoEdgeType_GEO_EDGE_UNKNOWN = 0,
  GeoPolygon_GeoEdgeType_GEO_EDGE_ARC_BY_EDGE = 1,
  GeoPolygon_GeoEdgeType_GEO_EDGE_CIRCLE = 2,
  GeoPolygon_GeoEdgeType_GEO_EDGE_GREAT_CIRCLE = 3,
  GeoPolygon_GeoEdgeType_GEO_EDGE_RHUMB_LINE = 4,
  GeoPolygon_GeoEdgeType_GEO_EDGE_CLOCKWISE_ARC = 5,
  GeoPolygon_GeoEdgeType_GEO_EDGE_COUNTER_CLOCKWISE_ARC = 6,
  GeoPolygon_GeoEdgeType_GeoPolygon_GeoEdgeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoPolygon_GeoEdgeType_GeoPolygon_GeoEdgeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoPolygon_GeoEdgeType_IsValid(int value);
constexpr GeoPolygon_GeoEdgeType GeoPolygon_GeoEdgeType_GeoEdgeType_MIN = GeoPolygon_GeoEdgeType_GEO_EDGE_UNKNOWN;
constexpr GeoPolygon_GeoEdgeType GeoPolygon_GeoEdgeType_GeoEdgeType_MAX = GeoPolygon_GeoEdgeType_GEO_EDGE_COUNTER_CLOCKWISE_ARC;
constexpr int GeoPolygon_GeoEdgeType_GeoEdgeType_ARRAYSIZE = GeoPolygon_GeoEdgeType_GeoEdgeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoPolygon_GeoEdgeType_descriptor();
template<typename T>
inline const std::string& GeoPolygon_GeoEdgeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoPolygon_GeoEdgeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoPolygon_GeoEdgeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoPolygon_GeoEdgeType_descriptor(), enum_t_value);
}
inline bool GeoPolygon_GeoEdgeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoPolygon_GeoEdgeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoPolygon_GeoEdgeType>(
    GeoPolygon_GeoEdgeType_descriptor(), name, value);
}
enum ControlledAirspace_Type : int {
  ControlledAirspace_Type_AIRSPACE_UNKNOWN = 0,
  ControlledAirspace_Type_AIRSPACE_CONTROL_ZONE = 1,
  ControlledAirspace_Type_AIRSPACE_CONTROL_AREA = 2,
  ControlledAirspace_Type_AIRSPACE_TERMINAL_CONTROL_AREA = 3,
  ControlledAirspace_Type_AIRSPACE_FIR_AREA = 4,
  ControlledAirspace_Type_AIRSPACE_FIR_OCEANIC = 5,
  ControlledAirspace_Type_AIRSPACE_UIR_AREA = 6,
  ControlledAirspace_Type_AIRSPACE_UIR_OCEANIC = 7,
  ControlledAirspace_Type_ControlledAirspace_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlledAirspace_Type_ControlledAirspace_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlledAirspace_Type_IsValid(int value);
constexpr ControlledAirspace_Type ControlledAirspace_Type_Type_MIN = ControlledAirspace_Type_AIRSPACE_UNKNOWN;
constexpr ControlledAirspace_Type ControlledAirspace_Type_Type_MAX = ControlledAirspace_Type_AIRSPACE_UIR_OCEANIC;
constexpr int ControlledAirspace_Type_Type_ARRAYSIZE = ControlledAirspace_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlledAirspace_Type_descriptor();
template<typename T>
inline const std::string& ControlledAirspace_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlledAirspace_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlledAirspace_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlledAirspace_Type_descriptor(), enum_t_value);
}
inline bool ControlledAirspace_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlledAirspace_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlledAirspace_Type>(
    ControlledAirspace_Type_descriptor(), name, value);
}
enum ControlledAirspace_Classification : int {
  ControlledAirspace_Classification_AIRSPACE_CLASS_UNKNOWN = 0,
  ControlledAirspace_Classification_AIRSPACE_CLASS_A = 1,
  ControlledAirspace_Classification_AIRSPACE_CLASS_B = 2,
  ControlledAirspace_Classification_AIRSPACE_CLASS_C = 3,
  ControlledAirspace_Classification_AIRSPACE_CLASS_D = 4,
  ControlledAirspace_Classification_AIRSPACE_CLASS_E = 5,
  ControlledAirspace_Classification_AIRSPACE_CLASS_G = 6,
  ControlledAirspace_Classification_ControlledAirspace_Classification_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlledAirspace_Classification_ControlledAirspace_Classification_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlledAirspace_Classification_IsValid(int value);
constexpr ControlledAirspace_Classification ControlledAirspace_Classification_Classification_MIN = ControlledAirspace_Classification_AIRSPACE_CLASS_UNKNOWN;
constexpr ControlledAirspace_Classification ControlledAirspace_Classification_Classification_MAX = ControlledAirspace_Classification_AIRSPACE_CLASS_G;
constexpr int ControlledAirspace_Classification_Classification_ARRAYSIZE = ControlledAirspace_Classification_Classification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlledAirspace_Classification_descriptor();
template<typename T>
inline const std::string& ControlledAirspace_Classification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlledAirspace_Classification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlledAirspace_Classification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlledAirspace_Classification_descriptor(), enum_t_value);
}
inline bool ControlledAirspace_Classification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlledAirspace_Classification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlledAirspace_Classification>(
    ControlledAirspace_Classification_descriptor(), name, value);
}
enum ControlFacility_Type : int {
  ControlFacility_Type_FACILITY_UNKNOWN = 0,
  ControlFacility_Type_FACILITY_TOWER = 1,
  ControlFacility_Type_FACILITY_TERMINAL = 2,
  ControlFacility_Type_FACILITY_CENTER = 3,
  ControlFacility_Type_FACILITY_OCEANIC = 4,
  ControlFacility_Type_ControlFacility_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlFacility_Type_ControlFacility_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlFacility_Type_IsValid(int value);
constexpr ControlFacility_Type ControlFacility_Type_Type_MIN = ControlFacility_Type_FACILITY_UNKNOWN;
constexpr ControlFacility_Type ControlFacility_Type_Type_MAX = ControlFacility_Type_FACILITY_OCEANIC;
constexpr int ControlFacility_Type_Type_ARRAYSIZE = ControlFacility_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlFacility_Type_descriptor();
template<typename T>
inline const std::string& ControlFacility_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlFacility_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlFacility_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlFacility_Type_descriptor(), enum_t_value);
}
inline bool ControlFacility_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlFacility_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlFacility_Type>(
    ControlFacility_Type_descriptor(), name, value);
}
// ===================================================================

class GeoPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {}
  virtual ~GeoPoint();

  GeoPoint(const GeoPoint& from);
  GeoPoint(GeoPoint&& from) noexcept
    : GeoPoint() {
    *this = ::std::move(from);
  }

  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
               &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GeoPoint& a, GeoPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPoint* New() const final {
    return CreateMaybeMessage<GeoPoint>(nullptr);
  }

  GeoPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPoint& from);
  void MergeFrom(const GeoPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.GeoPoint";
  }
  protected:
  explicit GeoPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
  };
  // double lat = 1;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double lon = 2;
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.GeoPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double lat_;
  double lon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class GeoBox PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.GeoBox) */ {
 public:
  inline GeoBox() : GeoBox(nullptr) {}
  virtual ~GeoBox();

  GeoBox(const GeoBox& from);
  GeoBox(GeoBox&& from) noexcept
    : GeoBox() {
    *this = ::std::move(from);
  }

  inline GeoBox& operator=(const GeoBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoBox& operator=(GeoBox&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoBox* internal_default_instance() {
    return reinterpret_cast<const GeoBox*>(
               &_GeoBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GeoBox& a, GeoBox& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoBox* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoBox* New() const final {
    return CreateMaybeMessage<GeoBox>(nullptr);
  }

  GeoBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoBox& from);
  void MergeFrom(const GeoBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.GeoBox";
  }
  protected:
  explicit GeoBox(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNorthWestFieldNumber = 1,
    kNorthEastFieldNumber = 2,
    kSouthWestFieldNumber = 3,
    kSouthEastFieldNumber = 4,
  };
  // .world_proto.GeoPoint north_west = 1;
  bool has_north_west() const;
  private:
  bool _internal_has_north_west() const;
  public:
  void clear_north_west();
  const ::world_proto::GeoPoint& north_west() const;
  ::world_proto::GeoPoint* release_north_west();
  ::world_proto::GeoPoint* mutable_north_west();
  void set_allocated_north_west(::world_proto::GeoPoint* north_west);
  private:
  const ::world_proto::GeoPoint& _internal_north_west() const;
  ::world_proto::GeoPoint* _internal_mutable_north_west();
  public:
  void unsafe_arena_set_allocated_north_west(
      ::world_proto::GeoPoint* north_west);
  ::world_proto::GeoPoint* unsafe_arena_release_north_west();

  // .world_proto.GeoPoint north_east = 2;
  bool has_north_east() const;
  private:
  bool _internal_has_north_east() const;
  public:
  void clear_north_east();
  const ::world_proto::GeoPoint& north_east() const;
  ::world_proto::GeoPoint* release_north_east();
  ::world_proto::GeoPoint* mutable_north_east();
  void set_allocated_north_east(::world_proto::GeoPoint* north_east);
  private:
  const ::world_proto::GeoPoint& _internal_north_east() const;
  ::world_proto::GeoPoint* _internal_mutable_north_east();
  public:
  void unsafe_arena_set_allocated_north_east(
      ::world_proto::GeoPoint* north_east);
  ::world_proto::GeoPoint* unsafe_arena_release_north_east();

  // .world_proto.GeoPoint south_west = 3;
  bool has_south_west() const;
  private:
  bool _internal_has_south_west() const;
  public:
  void clear_south_west();
  const ::world_proto::GeoPoint& south_west() const;
  ::world_proto::GeoPoint* release_south_west();
  ::world_proto::GeoPoint* mutable_south_west();
  void set_allocated_south_west(::world_proto::GeoPoint* south_west);
  private:
  const ::world_proto::GeoPoint& _internal_south_west() const;
  ::world_proto::GeoPoint* _internal_mutable_south_west();
  public:
  void unsafe_arena_set_allocated_south_west(
      ::world_proto::GeoPoint* south_west);
  ::world_proto::GeoPoint* unsafe_arena_release_south_west();

  // .world_proto.GeoPoint south_east = 4;
  bool has_south_east() const;
  private:
  bool _internal_has_south_east() const;
  public:
  void clear_south_east();
  const ::world_proto::GeoPoint& south_east() const;
  ::world_proto::GeoPoint* release_south_east();
  ::world_proto::GeoPoint* mutable_south_east();
  void set_allocated_south_east(::world_proto::GeoPoint* south_east);
  private:
  const ::world_proto::GeoPoint& _internal_south_east() const;
  ::world_proto::GeoPoint* _internal_mutable_south_east();
  public:
  void unsafe_arena_set_allocated_south_east(
      ::world_proto::GeoPoint* south_east);
  ::world_proto::GeoPoint* unsafe_arena_release_south_east();

  // @@protoc_insertion_point(class_scope:world_proto.GeoBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::GeoPoint* north_west_;
  ::world_proto::GeoPoint* north_east_;
  ::world_proto::GeoPoint* south_west_;
  ::world_proto::GeoPoint* south_east_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Vector3d PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Vector3d) */ {
 public:
  inline Vector3d() : Vector3d(nullptr) {}
  virtual ~Vector3d();

  Vector3d(const Vector3d& from);
  Vector3d(Vector3d&& from) noexcept
    : Vector3d() {
    *this = ::std::move(from);
  }

  inline Vector3d& operator=(const Vector3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3d& operator=(Vector3d&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3d* internal_default_instance() {
    return reinterpret_cast<const Vector3d*>(
               &_Vector3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vector3d& a, Vector3d& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3d* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3d* New() const final {
    return CreateMaybeMessage<Vector3d>(nullptr);
  }

  Vector3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3d>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3d& from);
  void MergeFrom(const Vector3d& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3d* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Vector3d";
  }
  protected:
  explicit Vector3d(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kAltFieldNumber = 3,
  };
  // double lat = 1;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double lon = 2;
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // double alt = 3;
  void clear_alt();
  double alt() const;
  void set_alt(double value);
  private:
  double _internal_alt() const;
  void _internal_set_alt(double value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.Vector3d)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double lat_;
  double lon_;
  double alt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Attitude PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Attitude) */ {
 public:
  inline Attitude() : Attitude(nullptr) {}
  virtual ~Attitude();

  Attitude(const Attitude& from);
  Attitude(Attitude&& from) noexcept
    : Attitude() {
    *this = ::std::move(from);
  }

  inline Attitude& operator=(const Attitude& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attitude& operator=(Attitude&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Attitude& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Attitude* internal_default_instance() {
    return reinterpret_cast<const Attitude*>(
               &_Attitude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Attitude& a, Attitude& b) {
    a.Swap(&b);
  }
  inline void Swap(Attitude* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attitude* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attitude* New() const final {
    return CreateMaybeMessage<Attitude>(nullptr);
  }

  Attitude* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attitude>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Attitude& from);
  void MergeFrom(const Attitude& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attitude* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Attitude";
  }
  protected:
  explicit Attitude(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadingFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float heading = 1;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // float pitch = 2;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 3;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.Attitude)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float heading_;
  float pitch_;
  float roll_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Aircraft_Situation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Aircraft.Situation) */ {
 public:
  inline Aircraft_Situation() : Aircraft_Situation(nullptr) {}
  virtual ~Aircraft_Situation();

  Aircraft_Situation(const Aircraft_Situation& from);
  Aircraft_Situation(Aircraft_Situation&& from) noexcept
    : Aircraft_Situation() {
    *this = ::std::move(from);
  }

  inline Aircraft_Situation& operator=(const Aircraft_Situation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aircraft_Situation& operator=(Aircraft_Situation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Aircraft_Situation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Aircraft_Situation* internal_default_instance() {
    return reinterpret_cast<const Aircraft_Situation*>(
               &_Aircraft_Situation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Aircraft_Situation& a, Aircraft_Situation& b) {
    a.Swap(&b);
  }
  inline void Swap(Aircraft_Situation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aircraft_Situation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Aircraft_Situation* New() const final {
    return CreateMaybeMessage<Aircraft_Situation>(nullptr);
  }

  Aircraft_Situation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Aircraft_Situation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Aircraft_Situation& from);
  void MergeFrom(const Aircraft_Situation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aircraft_Situation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Aircraft.Situation";
  }
  protected:
  explicit Aircraft_Situation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSquawkFieldNumber = 14,
    kLocationFieldNumber = 1,
    kAttitudeFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kFlapRatioFieldNumber = 6,
    kSpoilerRatioFieldNumber = 7,
    kGearRatioFieldNumber = 8,
    kNoseWheelAngleFieldNumber = 9,
    kIsOnGroundFieldNumber = 5,
    kLandingLightsFieldNumber = 10,
    kTaxiLightsFieldNumber = 11,
    kStrobeLightsFieldNumber = 12,
    kFrequencyKhzFieldNumber = 13,
    kModeCFieldNumber = 15,
    kModeSFieldNumber = 16,
  };
  // string squawk = 14;
  void clear_squawk();
  const std::string& squawk() const;
  void set_squawk(const std::string& value);
  void set_squawk(std::string&& value);
  void set_squawk(const char* value);
  void set_squawk(const char* value, size_t size);
  std::string* mutable_squawk();
  std::string* release_squawk();
  void set_allocated_squawk(std::string* squawk);
  private:
  const std::string& _internal_squawk() const;
  void _internal_set_squawk(const std::string& value);
  std::string* _internal_mutable_squawk();
  public:

  // .world_proto.Vector3d location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::world_proto::Vector3d& location() const;
  ::world_proto::Vector3d* release_location();
  ::world_proto::Vector3d* mutable_location();
  void set_allocated_location(::world_proto::Vector3d* location);
  private:
  const ::world_proto::Vector3d& _internal_location() const;
  ::world_proto::Vector3d* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::world_proto::Vector3d* location);
  ::world_proto::Vector3d* unsafe_arena_release_location();

  // .world_proto.Attitude attitude = 2;
  bool has_attitude() const;
  private:
  bool _internal_has_attitude() const;
  public:
  void clear_attitude();
  const ::world_proto::Attitude& attitude() const;
  ::world_proto::Attitude* release_attitude();
  ::world_proto::Attitude* mutable_attitude();
  void set_allocated_attitude(::world_proto::Attitude* attitude);
  private:
  const ::world_proto::Attitude& _internal_attitude() const;
  ::world_proto::Attitude* _internal_mutable_attitude();
  public:
  void unsafe_arena_set_allocated_attitude(
      ::world_proto::Attitude* attitude);
  ::world_proto::Attitude* unsafe_arena_release_attitude();

  // .world_proto.Vector3d velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::world_proto::Vector3d& velocity() const;
  ::world_proto::Vector3d* release_velocity();
  ::world_proto::Vector3d* mutable_velocity();
  void set_allocated_velocity(::world_proto::Vector3d* velocity);
  private:
  const ::world_proto::Vector3d& _internal_velocity() const;
  ::world_proto::Vector3d* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::world_proto::Vector3d* velocity);
  ::world_proto::Vector3d* unsafe_arena_release_velocity();

  // .world_proto.Vector3d acceleration = 4;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::world_proto::Vector3d& acceleration() const;
  ::world_proto::Vector3d* release_acceleration();
  ::world_proto::Vector3d* mutable_acceleration();
  void set_allocated_acceleration(::world_proto::Vector3d* acceleration);
  private:
  const ::world_proto::Vector3d& _internal_acceleration() const;
  ::world_proto::Vector3d* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::world_proto::Vector3d* acceleration);
  ::world_proto::Vector3d* unsafe_arena_release_acceleration();

  // float flap_ratio = 6;
  void clear_flap_ratio();
  float flap_ratio() const;
  void set_flap_ratio(float value);
  private:
  float _internal_flap_ratio() const;
  void _internal_set_flap_ratio(float value);
  public:

  // float spoiler_ratio = 7;
  void clear_spoiler_ratio();
  float spoiler_ratio() const;
  void set_spoiler_ratio(float value);
  private:
  float _internal_spoiler_ratio() const;
  void _internal_set_spoiler_ratio(float value);
  public:

  // float gear_ratio = 8;
  void clear_gear_ratio();
  float gear_ratio() const;
  void set_gear_ratio(float value);
  private:
  float _internal_gear_ratio() const;
  void _internal_set_gear_ratio(float value);
  public:

  // float nose_wheel_angle = 9;
  void clear_nose_wheel_angle();
  float nose_wheel_angle() const;
  void set_nose_wheel_angle(float value);
  private:
  float _internal_nose_wheel_angle() const;
  void _internal_set_nose_wheel_angle(float value);
  public:

  // bool is_on_ground = 5;
  void clear_is_on_ground();
  bool is_on_ground() const;
  void set_is_on_ground(bool value);
  private:
  bool _internal_is_on_ground() const;
  void _internal_set_is_on_ground(bool value);
  public:

  // bool landing_lights = 10;
  void clear_landing_lights();
  bool landing_lights() const;
  void set_landing_lights(bool value);
  private:
  bool _internal_landing_lights() const;
  void _internal_set_landing_lights(bool value);
  public:

  // bool taxi_lights = 11;
  void clear_taxi_lights();
  bool taxi_lights() const;
  void set_taxi_lights(bool value);
  private:
  bool _internal_taxi_lights() const;
  void _internal_set_taxi_lights(bool value);
  public:

  // bool strobe_lights = 12;
  void clear_strobe_lights();
  bool strobe_lights() const;
  void set_strobe_lights(bool value);
  private:
  bool _internal_strobe_lights() const;
  void _internal_set_strobe_lights(bool value);
  public:

  // int32 frequency_khz = 13;
  void clear_frequency_khz();
  ::PROTOBUF_NAMESPACE_ID::int32 frequency_khz() const;
  void set_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_frequency_khz() const;
  void _internal_set_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool mode_c = 15;
  void clear_mode_c();
  bool mode_c() const;
  void set_mode_c(bool value);
  private:
  bool _internal_mode_c() const;
  void _internal_set_mode_c(bool value);
  public:

  // bool mode_s = 16;
  void clear_mode_s();
  bool mode_s() const;
  void set_mode_s(bool value);
  private:
  bool _internal_mode_s() const;
  void _internal_set_mode_s(bool value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.Aircraft.Situation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr squawk_;
  ::world_proto::Vector3d* location_;
  ::world_proto::Attitude* attitude_;
  ::world_proto::Vector3d* velocity_;
  ::world_proto::Vector3d* acceleration_;
  float flap_ratio_;
  float spoiler_ratio_;
  float gear_ratio_;
  float nose_wheel_angle_;
  bool is_on_ground_;
  bool landing_lights_;
  bool taxi_lights_;
  bool strobe_lights_;
  ::PROTOBUF_NAMESPACE_ID::int32 frequency_khz_;
  bool mode_c_;
  bool mode_s_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Aircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Aircraft) */ {
 public:
  inline Aircraft() : Aircraft(nullptr) {}
  virtual ~Aircraft();

  Aircraft(const Aircraft& from);
  Aircraft(Aircraft&& from) noexcept
    : Aircraft() {
    *this = ::std::move(from);
  }

  inline Aircraft& operator=(const Aircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aircraft& operator=(Aircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Aircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Aircraft* internal_default_instance() {
    return reinterpret_cast<const Aircraft*>(
               &_Aircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Aircraft& a, Aircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(Aircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Aircraft* New() const final {
    return CreateMaybeMessage<Aircraft>(nullptr);
  }

  Aircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Aircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Aircraft& from);
  void MergeFrom(const Aircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Aircraft";
  }
  protected:
  explicit Aircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Aircraft_Situation Situation;

  typedef Aircraft_Category Category;
  static constexpr Category AIRCRAFT_CATEGORY_NONE =
    Aircraft_Category_AIRCRAFT_CATEGORY_NONE;
  static constexpr Category AIRCRAFT_CATEGORY_HEAVY =
    Aircraft_Category_AIRCRAFT_CATEGORY_HEAVY;
  static constexpr Category AIRCRAFT_CATEGORY_JET =
    Aircraft_Category_AIRCRAFT_CATEGORY_JET;
  static constexpr Category AIRCRAFT_CATEGORY_TURBOPROP =
    Aircraft_Category_AIRCRAFT_CATEGORY_TURBOPROP;
  static constexpr Category AIRCRAFT_CATEGORY_PROP =
    Aircraft_Category_AIRCRAFT_CATEGORY_PROP;
  static constexpr Category AIRCRAFT_CATEGORY_LIGHT_PROP =
    Aircraft_Category_AIRCRAFT_CATEGORY_LIGHT_PROP;
  static constexpr Category AIRCRAFT_CATEGORY_HELICPOTER =
    Aircraft_Category_AIRCRAFT_CATEGORY_HELICPOTER;
  static inline bool Category_IsValid(int value) {
    return Aircraft_Category_IsValid(value);
  }
  static constexpr Category Category_MIN =
    Aircraft_Category_Category_MIN;
  static constexpr Category Category_MAX =
    Aircraft_Category_Category_MAX;
  static constexpr int Category_ARRAYSIZE =
    Aircraft_Category_Category_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Category_descriptor() {
    return Aircraft_Category_descriptor();
  }
  template<typename T>
  static inline const std::string& Category_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Category>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Category_Name.");
    return Aircraft_Category_Name(enum_t_value);
  }
  static inline bool Category_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Category* value) {
    return Aircraft_Category_Parse(name, value);
  }

  typedef Aircraft_OperationType OperationType;
  static constexpr OperationType AIRCRAFT_OPERATION_NONE =
    Aircraft_OperationType_AIRCRAFT_OPERATION_NONE;
  static constexpr OperationType AIRCRAFT_OPERATION_GA =
    Aircraft_OperationType_AIRCRAFT_OPERATION_GA;
  static constexpr OperationType AIRCRAFT_OPERATION_AIRLINE =
    Aircraft_OperationType_AIRCRAFT_OPERATION_AIRLINE;
  static constexpr OperationType AIRCRAFT_OPERATION_CARGO =
    Aircraft_OperationType_AIRCRAFT_OPERATION_CARGO;
  static constexpr OperationType AIRCRAFT_OPERATION_MILITARY =
    Aircraft_OperationType_AIRCRAFT_OPERATION_MILITARY;
  static inline bool OperationType_IsValid(int value) {
    return Aircraft_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN =
    Aircraft_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX =
    Aircraft_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE =
    Aircraft_OperationType_OperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperationType_descriptor() {
    return Aircraft_OperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& OperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperationType_Name.");
    return Aircraft_OperationType_Name(enum_t_value);
  }
  static inline bool OperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OperationType* value) {
    return Aircraft_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModelIcaoFieldNumber = 2,
    kAirlineIcaoFieldNumber = 3,
    kTailNoFieldNumber = 4,
    kCallSignFieldNumber = 5,
    kSituationFieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // string model_icao = 2;
  void clear_model_icao();
  const std::string& model_icao() const;
  void set_model_icao(const std::string& value);
  void set_model_icao(std::string&& value);
  void set_model_icao(const char* value);
  void set_model_icao(const char* value, size_t size);
  std::string* mutable_model_icao();
  std::string* release_model_icao();
  void set_allocated_model_icao(std::string* model_icao);
  private:
  const std::string& _internal_model_icao() const;
  void _internal_set_model_icao(const std::string& value);
  std::string* _internal_mutable_model_icao();
  public:

  // string airline_icao = 3;
  void clear_airline_icao();
  const std::string& airline_icao() const;
  void set_airline_icao(const std::string& value);
  void set_airline_icao(std::string&& value);
  void set_airline_icao(const char* value);
  void set_airline_icao(const char* value, size_t size);
  std::string* mutable_airline_icao();
  std::string* release_airline_icao();
  void set_allocated_airline_icao(std::string* airline_icao);
  private:
  const std::string& _internal_airline_icao() const;
  void _internal_set_airline_icao(const std::string& value);
  std::string* _internal_mutable_airline_icao();
  public:

  // string tail_no = 4;
  void clear_tail_no();
  const std::string& tail_no() const;
  void set_tail_no(const std::string& value);
  void set_tail_no(std::string&& value);
  void set_tail_no(const char* value);
  void set_tail_no(const char* value, size_t size);
  std::string* mutable_tail_no();
  std::string* release_tail_no();
  void set_allocated_tail_no(std::string* tail_no);
  private:
  const std::string& _internal_tail_no() const;
  void _internal_set_tail_no(const std::string& value);
  std::string* _internal_mutable_tail_no();
  public:

  // string call_sign = 5;
  void clear_call_sign();
  const std::string& call_sign() const;
  void set_call_sign(const std::string& value);
  void set_call_sign(std::string&& value);
  void set_call_sign(const char* value);
  void set_call_sign(const char* value, size_t size);
  std::string* mutable_call_sign();
  std::string* release_call_sign();
  void set_allocated_call_sign(std::string* call_sign);
  private:
  const std::string& _internal_call_sign() const;
  void _internal_set_call_sign(const std::string& value);
  std::string* _internal_mutable_call_sign();
  public:

  // .world_proto.Aircraft.Situation situation = 6;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::world_proto::Aircraft_Situation& situation() const;
  ::world_proto::Aircraft_Situation* release_situation();
  ::world_proto::Aircraft_Situation* mutable_situation();
  void set_allocated_situation(::world_proto::Aircraft_Situation* situation);
  private:
  const ::world_proto::Aircraft_Situation& _internal_situation() const;
  ::world_proto::Aircraft_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::world_proto::Aircraft_Situation* situation);
  ::world_proto::Aircraft_Situation* unsafe_arena_release_situation();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.Aircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_icao_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr airline_icao_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tail_no_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_sign_;
  ::world_proto::Aircraft_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Runway_End PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Runway.End) */ {
 public:
  inline Runway_End() : Runway_End(nullptr) {}
  virtual ~Runway_End();

  Runway_End(const Runway_End& from);
  Runway_End(Runway_End&& from) noexcept
    : Runway_End() {
    *this = ::std::move(from);
  }

  inline Runway_End& operator=(const Runway_End& from) {
    CopyFrom(from);
    return *this;
  }
  inline Runway_End& operator=(Runway_End&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Runway_End& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Runway_End* internal_default_instance() {
    return reinterpret_cast<const Runway_End*>(
               &_Runway_End_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Runway_End& a, Runway_End& b) {
    a.Swap(&b);
  }
  inline void Swap(Runway_End* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Runway_End* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Runway_End* New() const final {
    return CreateMaybeMessage<Runway_End>(nullptr);
  }

  Runway_End* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Runway_End>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Runway_End& from);
  void MergeFrom(const Runway_End& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Runway_End* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Runway.End";
  }
  protected:
  explicit Runway_End(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCenterlinePointFieldNumber = 3,
    kHeadingFieldNumber = 2,
    kDisplacedThresholdMetersFieldNumber = 4,
    kOverrunAreaMetersFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .world_proto.GeoPoint centerline_point = 3;
  bool has_centerline_point() const;
  private:
  bool _internal_has_centerline_point() const;
  public:
  void clear_centerline_point();
  const ::world_proto::GeoPoint& centerline_point() const;
  ::world_proto::GeoPoint* release_centerline_point();
  ::world_proto::GeoPoint* mutable_centerline_point();
  void set_allocated_centerline_point(::world_proto::GeoPoint* centerline_point);
  private:
  const ::world_proto::GeoPoint& _internal_centerline_point() const;
  ::world_proto::GeoPoint* _internal_mutable_centerline_point();
  public:
  void unsafe_arena_set_allocated_centerline_point(
      ::world_proto::GeoPoint* centerline_point);
  ::world_proto::GeoPoint* unsafe_arena_release_centerline_point();

  // float heading = 2;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // float displaced_threshold_meters = 4;
  void clear_displaced_threshold_meters();
  float displaced_threshold_meters() const;
  void set_displaced_threshold_meters(float value);
  private:
  float _internal_displaced_threshold_meters() const;
  void _internal_set_displaced_threshold_meters(float value);
  public:

  // float overrun_area_meters = 5;
  void clear_overrun_area_meters();
  float overrun_area_meters() const;
  void set_overrun_area_meters(float value);
  private:
  float _internal_overrun_area_meters() const;
  void _internal_set_overrun_area_meters(float value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.Runway.End)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::world_proto::GeoPoint* centerline_point_;
  float heading_;
  float displaced_threshold_meters_;
  float overrun_area_meters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Runway PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Runway) */ {
 public:
  inline Runway() : Runway(nullptr) {}
  virtual ~Runway();

  Runway(const Runway& from);
  Runway(Runway&& from) noexcept
    : Runway() {
    *this = ::std::move(from);
  }

  inline Runway& operator=(const Runway& from) {
    CopyFrom(from);
    return *this;
  }
  inline Runway& operator=(Runway&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Runway& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Runway* internal_default_instance() {
    return reinterpret_cast<const Runway*>(
               &_Runway_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Runway& a, Runway& b) {
    a.Swap(&b);
  }
  inline void Swap(Runway* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Runway* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Runway* New() const final {
    return CreateMaybeMessage<Runway>(nullptr);
  }

  Runway* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Runway>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Runway& from);
  void MergeFrom(const Runway& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Runway* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Runway";
  }
  protected:
  explicit Runway(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Runway_End End;

  // accessors -------------------------------------------------------

  enum : int {
    kEnd1FieldNumber = 4,
    kEnd2FieldNumber = 5,
    kWidthMetersFieldNumber = 1,
    kLengthMetersFieldNumber = 2,
    kMaskBitFieldNumber = 3,
  };
  // .world_proto.Runway.End end_1 = 4;
  bool has_end_1() const;
  private:
  bool _internal_has_end_1() const;
  public:
  void clear_end_1();
  const ::world_proto::Runway_End& end_1() const;
  ::world_proto::Runway_End* release_end_1();
  ::world_proto::Runway_End* mutable_end_1();
  void set_allocated_end_1(::world_proto::Runway_End* end_1);
  private:
  const ::world_proto::Runway_End& _internal_end_1() const;
  ::world_proto::Runway_End* _internal_mutable_end_1();
  public:
  void unsafe_arena_set_allocated_end_1(
      ::world_proto::Runway_End* end_1);
  ::world_proto::Runway_End* unsafe_arena_release_end_1();

  // .world_proto.Runway.End end_2 = 5;
  bool has_end_2() const;
  private:
  bool _internal_has_end_2() const;
  public:
  void clear_end_2();
  const ::world_proto::Runway_End& end_2() const;
  ::world_proto::Runway_End* release_end_2();
  ::world_proto::Runway_End* mutable_end_2();
  void set_allocated_end_2(::world_proto::Runway_End* end_2);
  private:
  const ::world_proto::Runway_End& _internal_end_2() const;
  ::world_proto::Runway_End* _internal_mutable_end_2();
  public:
  void unsafe_arena_set_allocated_end_2(
      ::world_proto::Runway_End* end_2);
  ::world_proto::Runway_End* unsafe_arena_release_end_2();

  // float width_meters = 1;
  void clear_width_meters();
  float width_meters() const;
  void set_width_meters(float value);
  private:
  float _internal_width_meters() const;
  void _internal_set_width_meters(float value);
  public:

  // float length_meters = 2;
  void clear_length_meters();
  float length_meters() const;
  void set_length_meters(float value);
  private:
  float _internal_length_meters() const;
  void _internal_set_length_meters(float value);
  public:

  // uint32 mask_bit = 3;
  void clear_mask_bit();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_bit() const;
  void set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mask_bit() const;
  void _internal_set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.Runway)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::Runway_End* end_1_;
  ::world_proto::Runway_End* end_2_;
  float width_meters_;
  float length_meters_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_bit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class TaxiNode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.TaxiNode) */ {
 public:
  inline TaxiNode() : TaxiNode(nullptr) {}
  virtual ~TaxiNode();

  TaxiNode(const TaxiNode& from);
  TaxiNode(TaxiNode&& from) noexcept
    : TaxiNode() {
    *this = ::std::move(from);
  }

  inline TaxiNode& operator=(const TaxiNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiNode& operator=(TaxiNode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiNode* internal_default_instance() {
    return reinterpret_cast<const TaxiNode*>(
               &_TaxiNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaxiNode& a, TaxiNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiNode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiNode* New() const final {
    return CreateMaybeMessage<TaxiNode>(nullptr);
  }

  TaxiNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiNode& from);
  void MergeFrom(const TaxiNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.TaxiNode";
  }
  protected:
  explicit TaxiNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kIdFieldNumber = 1,
    kIsJunctionFieldNumber = 3,
  };
  // .world_proto.GeoPoint location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::world_proto::GeoPoint& location() const;
  ::world_proto::GeoPoint* release_location();
  ::world_proto::GeoPoint* mutable_location();
  void set_allocated_location(::world_proto::GeoPoint* location);
  private:
  const ::world_proto::GeoPoint& _internal_location() const;
  ::world_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::world_proto::GeoPoint* location);
  ::world_proto::GeoPoint* unsafe_arena_release_location();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_junction = 3;
  void clear_is_junction();
  bool is_junction() const;
  void set_is_junction(bool value);
  private:
  bool _internal_is_junction() const;
  void _internal_set_is_junction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.TaxiNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::GeoPoint* location_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool is_junction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class TaxiEdge_ActiveZoneMatrix PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.TaxiEdge.ActiveZoneMatrix) */ {
 public:
  inline TaxiEdge_ActiveZoneMatrix() : TaxiEdge_ActiveZoneMatrix(nullptr) {}
  virtual ~TaxiEdge_ActiveZoneMatrix();

  TaxiEdge_ActiveZoneMatrix(const TaxiEdge_ActiveZoneMatrix& from);
  TaxiEdge_ActiveZoneMatrix(TaxiEdge_ActiveZoneMatrix&& from) noexcept
    : TaxiEdge_ActiveZoneMatrix() {
    *this = ::std::move(from);
  }

  inline TaxiEdge_ActiveZoneMatrix& operator=(const TaxiEdge_ActiveZoneMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiEdge_ActiveZoneMatrix& operator=(TaxiEdge_ActiveZoneMatrix&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiEdge_ActiveZoneMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiEdge_ActiveZoneMatrix* internal_default_instance() {
    return reinterpret_cast<const TaxiEdge_ActiveZoneMatrix*>(
               &_TaxiEdge_ActiveZoneMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TaxiEdge_ActiveZoneMatrix& a, TaxiEdge_ActiveZoneMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiEdge_ActiveZoneMatrix* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiEdge_ActiveZoneMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiEdge_ActiveZoneMatrix* New() const final {
    return CreateMaybeMessage<TaxiEdge_ActiveZoneMatrix>(nullptr);
  }

  TaxiEdge_ActiveZoneMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiEdge_ActiveZoneMatrix>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiEdge_ActiveZoneMatrix& from);
  void MergeFrom(const TaxiEdge_ActiveZoneMatrix& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiEdge_ActiveZoneMatrix* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.TaxiEdge.ActiveZoneMatrix";
  }
  protected:
  explicit TaxiEdge_ActiveZoneMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepartureFieldNumber = 1,
    kArrivalFieldNumber = 2,
    kIlsFieldNumber = 3,
  };
  // uint32 departure = 1;
  void clear_departure();
  ::PROTOBUF_NAMESPACE_ID::uint32 departure() const;
  void set_departure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_departure() const;
  void _internal_set_departure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 arrival = 2;
  void clear_arrival();
  ::PROTOBUF_NAMESPACE_ID::uint32 arrival() const;
  void set_arrival(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_arrival() const;
  void _internal_set_arrival(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 ils = 3;
  void clear_ils();
  ::PROTOBUF_NAMESPACE_ID::uint32 ils() const;
  void set_ils(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ils() const;
  void _internal_set_ils(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.TaxiEdge.ActiveZoneMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 departure_;
  ::PROTOBUF_NAMESPACE_ID::uint32 arrival_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ils_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class TaxiEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.TaxiEdge) */ {
 public:
  inline TaxiEdge() : TaxiEdge(nullptr) {}
  virtual ~TaxiEdge();

  TaxiEdge(const TaxiEdge& from);
  TaxiEdge(TaxiEdge&& from) noexcept
    : TaxiEdge() {
    *this = ::std::move(from);
  }

  inline TaxiEdge& operator=(const TaxiEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiEdge& operator=(TaxiEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiEdge* internal_default_instance() {
    return reinterpret_cast<const TaxiEdge*>(
               &_TaxiEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TaxiEdge& a, TaxiEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiEdge* New() const final {
    return CreateMaybeMessage<TaxiEdge>(nullptr);
  }

  TaxiEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiEdge& from);
  void MergeFrom(const TaxiEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.TaxiEdge";
  }
  protected:
  explicit TaxiEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TaxiEdge_ActiveZoneMatrix ActiveZoneMatrix;

  typedef TaxiEdge_Type Type;
  static constexpr Type TAXI_EDGE_GROUNDWAY =
    TaxiEdge_Type_TAXI_EDGE_GROUNDWAY;
  static constexpr Type TAXI_EDGE_TAXIWAY =
    TaxiEdge_Type_TAXI_EDGE_TAXIWAY;
  static constexpr Type TAXI_EDGE_RUNWAY =
    TaxiEdge_Type_TAXI_EDGE_RUNWAY;
  static inline bool Type_IsValid(int value) {
    return TaxiEdge_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TaxiEdge_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TaxiEdge_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TaxiEdge_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TaxiEdge_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TaxiEdge_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TaxiEdge_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kActiveZonesFieldNumber = 10,
    kIdFieldNumber = 1,
    kNodeId1FieldNumber = 3,
    kNodeId2FieldNumber = 4,
    kTypeFieldNumber = 5,
    kIsOneWayFieldNumber = 6,
    kIsHighSpeedExitFieldNumber = 7,
    kLengthMetersFieldNumber = 8,
    kHeadingFieldNumber = 9,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .world_proto.TaxiEdge.ActiveZoneMatrix active_zones = 10;
  bool has_active_zones() const;
  private:
  bool _internal_has_active_zones() const;
  public:
  void clear_active_zones();
  const ::world_proto::TaxiEdge_ActiveZoneMatrix& active_zones() const;
  ::world_proto::TaxiEdge_ActiveZoneMatrix* release_active_zones();
  ::world_proto::TaxiEdge_ActiveZoneMatrix* mutable_active_zones();
  void set_allocated_active_zones(::world_proto::TaxiEdge_ActiveZoneMatrix* active_zones);
  private:
  const ::world_proto::TaxiEdge_ActiveZoneMatrix& _internal_active_zones() const;
  ::world_proto::TaxiEdge_ActiveZoneMatrix* _internal_mutable_active_zones();
  public:
  void unsafe_arena_set_allocated_active_zones(
      ::world_proto::TaxiEdge_ActiveZoneMatrix* active_zones);
  ::world_proto::TaxiEdge_ActiveZoneMatrix* unsafe_arena_release_active_zones();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 node_id_1 = 3;
  void clear_node_id_1();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_1() const;
  void set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id_1() const;
  void _internal_set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 node_id_2 = 4;
  void clear_node_id_2();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_2() const;
  void set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id_2() const;
  void _internal_set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .world_proto.TaxiEdge.Type type = 5;
  void clear_type();
  ::world_proto::TaxiEdge_Type type() const;
  void set_type(::world_proto::TaxiEdge_Type value);
  private:
  ::world_proto::TaxiEdge_Type _internal_type() const;
  void _internal_set_type(::world_proto::TaxiEdge_Type value);
  public:

  // bool is_one_way = 6;
  void clear_is_one_way();
  bool is_one_way() const;
  void set_is_one_way(bool value);
  private:
  bool _internal_is_one_way() const;
  void _internal_set_is_one_way(bool value);
  public:

  // bool is_high_speed_exit = 7;
  void clear_is_high_speed_exit();
  bool is_high_speed_exit() const;
  void set_is_high_speed_exit(bool value);
  private:
  bool _internal_is_high_speed_exit() const;
  void _internal_set_is_high_speed_exit(bool value);
  public:

  // float length_meters = 8;
  void clear_length_meters();
  float length_meters() const;
  void set_length_meters(float value);
  private:
  float _internal_length_meters() const;
  void _internal_set_length_meters(float value);
  public:

  // float heading = 9;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.TaxiEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::world_proto::TaxiEdge_ActiveZoneMatrix* active_zones_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_1_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_2_;
  int type_;
  bool is_one_way_;
  bool is_high_speed_exit_;
  float length_meters_;
  float heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ParkingStand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ParkingStand) */ {
 public:
  inline ParkingStand() : ParkingStand(nullptr) {}
  virtual ~ParkingStand();

  ParkingStand(const ParkingStand& from);
  ParkingStand(ParkingStand&& from) noexcept
    : ParkingStand() {
    *this = ::std::move(from);
  }

  inline ParkingStand& operator=(const ParkingStand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingStand& operator=(ParkingStand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParkingStand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingStand* internal_default_instance() {
    return reinterpret_cast<const ParkingStand*>(
               &_ParkingStand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ParkingStand& a, ParkingStand& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingStand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingStand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParkingStand* New() const final {
    return CreateMaybeMessage<ParkingStand>(nullptr);
  }

  ParkingStand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParkingStand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParkingStand& from);
  void MergeFrom(const ParkingStand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingStand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ParkingStand";
  }
  protected:
  explicit ParkingStand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ParkingStand_Type Type;
  static constexpr Type PARKING_UNKNOWN =
    ParkingStand_Type_PARKING_UNKNOWN;
  static constexpr Type PARKING_GATE =
    ParkingStand_Type_PARKING_GATE;
  static constexpr Type PARKING_REMOTE =
    ParkingStand_Type_PARKING_REMOTE;
  static constexpr Type PARKING_HANGAR =
    ParkingStand_Type_PARKING_HANGAR;
  static inline bool Type_IsValid(int value) {
    return ParkingStand_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ParkingStand_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ParkingStand_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ParkingStand_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ParkingStand_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ParkingStand_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ParkingStand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 7,
    kOperationTypesFieldNumber = 8,
    kAirlineIcaosFieldNumber = 9,
    kNameFieldNumber = 2,
    kWidthCodeFieldNumber = 6,
    kLocationFieldNumber = 4,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 3,
    kHeadingFieldNumber = 5,
  };
  // repeated .world_proto.Aircraft.Category categories = 7;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  private:
  ::world_proto::Aircraft_Category _internal_categories(int index) const;
  void _internal_add_categories(::world_proto::Aircraft_Category value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_categories();
  public:
  ::world_proto::Aircraft_Category categories(int index) const;
  void set_categories(int index, ::world_proto::Aircraft_Category value);
  void add_categories(::world_proto::Aircraft_Category value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_categories();

  // repeated .world_proto.Aircraft.OperationType operation_types = 8;
  int operation_types_size() const;
  private:
  int _internal_operation_types_size() const;
  public:
  void clear_operation_types();
  private:
  ::world_proto::Aircraft_OperationType _internal_operation_types(int index) const;
  void _internal_add_operation_types(::world_proto::Aircraft_OperationType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_operation_types();
  public:
  ::world_proto::Aircraft_OperationType operation_types(int index) const;
  void set_operation_types(int index, ::world_proto::Aircraft_OperationType value);
  void add_operation_types(::world_proto::Aircraft_OperationType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& operation_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_operation_types();

  // repeated string airline_icaos = 9;
  int airline_icaos_size() const;
  private:
  int _internal_airline_icaos_size() const;
  public:
  void clear_airline_icaos();
  const std::string& airline_icaos(int index) const;
  std::string* mutable_airline_icaos(int index);
  void set_airline_icaos(int index, const std::string& value);
  void set_airline_icaos(int index, std::string&& value);
  void set_airline_icaos(int index, const char* value);
  void set_airline_icaos(int index, const char* value, size_t size);
  std::string* add_airline_icaos();
  void add_airline_icaos(const std::string& value);
  void add_airline_icaos(std::string&& value);
  void add_airline_icaos(const char* value);
  void add_airline_icaos(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& airline_icaos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_airline_icaos();
  private:
  const std::string& _internal_airline_icaos(int index) const;
  std::string* _internal_add_airline_icaos();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string width_code = 6;
  void clear_width_code();
  const std::string& width_code() const;
  void set_width_code(const std::string& value);
  void set_width_code(std::string&& value);
  void set_width_code(const char* value);
  void set_width_code(const char* value, size_t size);
  std::string* mutable_width_code();
  std::string* release_width_code();
  void set_allocated_width_code(std::string* width_code);
  private:
  const std::string& _internal_width_code() const;
  void _internal_set_width_code(const std::string& value);
  std::string* _internal_mutable_width_code();
  public:

  // .world_proto.GeoPoint location = 4;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::world_proto::GeoPoint& location() const;
  ::world_proto::GeoPoint* release_location();
  ::world_proto::GeoPoint* mutable_location();
  void set_allocated_location(::world_proto::GeoPoint* location);
  private:
  const ::world_proto::GeoPoint& _internal_location() const;
  ::world_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::world_proto::GeoPoint* location);
  ::world_proto::GeoPoint* unsafe_arena_release_location();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .world_proto.ParkingStand.Type type = 3;
  void clear_type();
  ::world_proto::ParkingStand_Type type() const;
  void set_type(::world_proto::ParkingStand_Type value);
  private:
  ::world_proto::ParkingStand_Type _internal_type() const;
  void _internal_set_type(::world_proto::ParkingStand_Type value);
  public:

  // float heading = 5;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ParkingStand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> categories_;
  mutable std::atomic<int> _categories_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> operation_types_;
  mutable std::atomic<int> _operation_types_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> airline_icaos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr width_code_;
  ::world_proto::GeoPoint* location_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int type_;
  float heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Airport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.Airport) */ {
 public:
  inline Airport() : Airport(nullptr) {}
  virtual ~Airport();

  Airport(const Airport& from);
  Airport(Airport&& from) noexcept
    : Airport() {
    *this = ::std::move(from);
  }

  inline Airport& operator=(const Airport& from) {
    CopyFrom(from);
    return *this;
  }
  inline Airport& operator=(Airport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Airport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Airport* internal_default_instance() {
    return reinterpret_cast<const Airport*>(
               &_Airport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Airport& a, Airport& b) {
    a.Swap(&b);
  }
  inline void Swap(Airport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Airport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Airport* New() const final {
    return CreateMaybeMessage<Airport>(nullptr);
  }

  Airport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Airport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Airport& from);
  void MergeFrom(const Airport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Airport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.Airport";
  }
  protected:
  explicit Airport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunwaysFieldNumber = 3,
    kParkingStandsFieldNumber = 4,
    kTaxiNodesFieldNumber = 5,
    kTaxiEdgesFieldNumber = 6,
    kIcaoFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // repeated .world_proto.Runway runways = 3;
  int runways_size() const;
  private:
  int _internal_runways_size() const;
  public:
  void clear_runways();
  ::world_proto::Runway* mutable_runways(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::Runway >*
      mutable_runways();
  private:
  const ::world_proto::Runway& _internal_runways(int index) const;
  ::world_proto::Runway* _internal_add_runways();
  public:
  const ::world_proto::Runway& runways(int index) const;
  ::world_proto::Runway* add_runways();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::Runway >&
      runways() const;

  // repeated .world_proto.ParkingStand parking_stands = 4;
  int parking_stands_size() const;
  private:
  int _internal_parking_stands_size() const;
  public:
  void clear_parking_stands();
  ::world_proto::ParkingStand* mutable_parking_stands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::ParkingStand >*
      mutable_parking_stands();
  private:
  const ::world_proto::ParkingStand& _internal_parking_stands(int index) const;
  ::world_proto::ParkingStand* _internal_add_parking_stands();
  public:
  const ::world_proto::ParkingStand& parking_stands(int index) const;
  ::world_proto::ParkingStand* add_parking_stands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::ParkingStand >&
      parking_stands() const;

  // repeated .world_proto.TaxiNode taxi_nodes = 5;
  int taxi_nodes_size() const;
  private:
  int _internal_taxi_nodes_size() const;
  public:
  void clear_taxi_nodes();
  ::world_proto::TaxiNode* mutable_taxi_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiNode >*
      mutable_taxi_nodes();
  private:
  const ::world_proto::TaxiNode& _internal_taxi_nodes(int index) const;
  ::world_proto::TaxiNode* _internal_add_taxi_nodes();
  public:
  const ::world_proto::TaxiNode& taxi_nodes(int index) const;
  ::world_proto::TaxiNode* add_taxi_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiNode >&
      taxi_nodes() const;

  // repeated .world_proto.TaxiEdge taxi_edges = 6;
  int taxi_edges_size() const;
  private:
  int _internal_taxi_edges_size() const;
  public:
  void clear_taxi_edges();
  ::world_proto::TaxiEdge* mutable_taxi_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiEdge >*
      mutable_taxi_edges();
  private:
  const ::world_proto::TaxiEdge& _internal_taxi_edges(int index) const;
  ::world_proto::TaxiEdge* _internal_add_taxi_edges();
  public:
  const ::world_proto::TaxiEdge& taxi_edges(int index) const;
  ::world_proto::TaxiEdge* add_taxi_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiEdge >&
      taxi_edges() const;

  // string icao = 1;
  void clear_icao();
  const std::string& icao() const;
  void set_icao(const std::string& value);
  void set_icao(std::string&& value);
  void set_icao(const char* value);
  void set_icao(const char* value, size_t size);
  std::string* mutable_icao();
  std::string* release_icao();
  void set_allocated_icao(std::string* icao);
  private:
  const std::string& _internal_icao() const;
  void _internal_set_icao(const std::string& value);
  std::string* _internal_mutable_icao();
  public:

  // .world_proto.GeoPoint location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::world_proto::GeoPoint& location() const;
  ::world_proto::GeoPoint* release_location();
  ::world_proto::GeoPoint* mutable_location();
  void set_allocated_location(::world_proto::GeoPoint* location);
  private:
  const ::world_proto::GeoPoint& _internal_location() const;
  ::world_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::world_proto::GeoPoint* location);
  ::world_proto::GeoPoint* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:world_proto.Airport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::Runway > runways_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::ParkingStand > parking_stands_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiNode > taxi_nodes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiEdge > taxi_edges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icao_;
  ::world_proto::GeoPoint* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class TaxiPath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.TaxiPath) */ {
 public:
  inline TaxiPath() : TaxiPath(nullptr) {}
  virtual ~TaxiPath();

  TaxiPath(const TaxiPath& from);
  TaxiPath(TaxiPath&& from) noexcept
    : TaxiPath() {
    *this = ::std::move(from);
  }

  inline TaxiPath& operator=(const TaxiPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiPath& operator=(TaxiPath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiPath* internal_default_instance() {
    return reinterpret_cast<const TaxiPath*>(
               &_TaxiPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TaxiPath& a, TaxiPath& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiPath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiPath* New() const final {
    return CreateMaybeMessage<TaxiPath>(nullptr);
  }

  TaxiPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiPath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiPath& from);
  void MergeFrom(const TaxiPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.TaxiPath";
  }
  protected:
  explicit TaxiPath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgeIdsFieldNumber = 3,
    kFromNodeIdFieldNumber = 1,
    kToNodeIdFieldNumber = 2,
  };
  // repeated int32 edge_ids = 3;
  int edge_ids_size() const;
  private:
  int _internal_edge_ids_size() const;
  public:
  void clear_edge_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_edge_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_edge_ids() const;
  void _internal_add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_edge_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 edge_ids(int index) const;
  void set_edge_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      edge_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_edge_ids();

  // int32 from_node_id = 1;
  void clear_from_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 from_node_id() const;
  void set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_from_node_id() const;
  void _internal_set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 to_node_id = 2;
  void clear_to_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 to_node_id() const;
  void set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_to_node_id() const;
  void _internal_set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.TaxiPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > edge_ids_;
  mutable std::atomic<int> _edge_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 from_node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 to_node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon_GeoEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.GeoPolygon.GeoEdge) */ {
 public:
  inline GeoPolygon_GeoEdge() : GeoPolygon_GeoEdge(nullptr) {}
  virtual ~GeoPolygon_GeoEdge();

  GeoPolygon_GeoEdge(const GeoPolygon_GeoEdge& from);
  GeoPolygon_GeoEdge(GeoPolygon_GeoEdge&& from) noexcept
    : GeoPolygon_GeoEdge() {
    *this = ::std::move(from);
  }

  inline GeoPolygon_GeoEdge& operator=(const GeoPolygon_GeoEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon_GeoEdge& operator=(GeoPolygon_GeoEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPolygon_GeoEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPolygon_GeoEdge* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon_GeoEdge*>(
               &_GeoPolygon_GeoEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GeoPolygon_GeoEdge& a, GeoPolygon_GeoEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPolygon_GeoEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon_GeoEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPolygon_GeoEdge* New() const final {
    return CreateMaybeMessage<GeoPolygon_GeoEdge>(nullptr);
  }

  GeoPolygon_GeoEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPolygon_GeoEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPolygon_GeoEdge& from);
  void MergeFrom(const GeoPolygon_GeoEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPolygon_GeoEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.GeoPolygon.GeoEdge";
  }
  protected:
  explicit GeoPolygon_GeoEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromPointFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .world_proto.GeoPoint from_point = 2;
  bool has_from_point() const;
  private:
  bool _internal_has_from_point() const;
  public:
  void clear_from_point();
  const ::world_proto::GeoPoint& from_point() const;
  ::world_proto::GeoPoint* release_from_point();
  ::world_proto::GeoPoint* mutable_from_point();
  void set_allocated_from_point(::world_proto::GeoPoint* from_point);
  private:
  const ::world_proto::GeoPoint& _internal_from_point() const;
  ::world_proto::GeoPoint* _internal_mutable_from_point();
  public:
  void unsafe_arena_set_allocated_from_point(
      ::world_proto::GeoPoint* from_point);
  ::world_proto::GeoPoint* unsafe_arena_release_from_point();

  // .world_proto.GeoPolygon.GeoEdgeType type = 1;
  void clear_type();
  ::world_proto::GeoPolygon_GeoEdgeType type() const;
  void set_type(::world_proto::GeoPolygon_GeoEdgeType value);
  private:
  ::world_proto::GeoPolygon_GeoEdgeType _internal_type() const;
  void _internal_set_type(::world_proto::GeoPolygon_GeoEdgeType value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.GeoPolygon.GeoEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::GeoPoint* from_point_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.GeoPolygon) */ {
 public:
  inline GeoPolygon() : GeoPolygon(nullptr) {}
  virtual ~GeoPolygon();

  GeoPolygon(const GeoPolygon& from);
  GeoPolygon(GeoPolygon&& from) noexcept
    : GeoPolygon() {
    *this = ::std::move(from);
  }

  inline GeoPolygon& operator=(const GeoPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon& operator=(GeoPolygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPolygon* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon*>(
               &_GeoPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GeoPolygon& a, GeoPolygon& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPolygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPolygon* New() const final {
    return CreateMaybeMessage<GeoPolygon>(nullptr);
  }

  GeoPolygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPolygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPolygon& from);
  void MergeFrom(const GeoPolygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPolygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.GeoPolygon";
  }
  protected:
  explicit GeoPolygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GeoPolygon_GeoEdge GeoEdge;

  typedef GeoPolygon_GeoEdgeType GeoEdgeType;
  static constexpr GeoEdgeType GEO_EDGE_UNKNOWN =
    GeoPolygon_GeoEdgeType_GEO_EDGE_UNKNOWN;
  static constexpr GeoEdgeType GEO_EDGE_ARC_BY_EDGE =
    GeoPolygon_GeoEdgeType_GEO_EDGE_ARC_BY_EDGE;
  static constexpr GeoEdgeType GEO_EDGE_CIRCLE =
    GeoPolygon_GeoEdgeType_GEO_EDGE_CIRCLE;
  static constexpr GeoEdgeType GEO_EDGE_GREAT_CIRCLE =
    GeoPolygon_GeoEdgeType_GEO_EDGE_GREAT_CIRCLE;
  static constexpr GeoEdgeType GEO_EDGE_RHUMB_LINE =
    GeoPolygon_GeoEdgeType_GEO_EDGE_RHUMB_LINE;
  static constexpr GeoEdgeType GEO_EDGE_CLOCKWISE_ARC =
    GeoPolygon_GeoEdgeType_GEO_EDGE_CLOCKWISE_ARC;
  static constexpr GeoEdgeType GEO_EDGE_COUNTER_CLOCKWISE_ARC =
    GeoPolygon_GeoEdgeType_GEO_EDGE_COUNTER_CLOCKWISE_ARC;
  static inline bool GeoEdgeType_IsValid(int value) {
    return GeoPolygon_GeoEdgeType_IsValid(value);
  }
  static constexpr GeoEdgeType GeoEdgeType_MIN =
    GeoPolygon_GeoEdgeType_GeoEdgeType_MIN;
  static constexpr GeoEdgeType GeoEdgeType_MAX =
    GeoPolygon_GeoEdgeType_GeoEdgeType_MAX;
  static constexpr int GeoEdgeType_ARRAYSIZE =
    GeoPolygon_GeoEdgeType_GeoEdgeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GeoEdgeType_descriptor() {
    return GeoPolygon_GeoEdgeType_descriptor();
  }
  template<typename T>
  static inline const std::string& GeoEdgeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GeoEdgeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GeoEdgeType_Name.");
    return GeoPolygon_GeoEdgeType_Name(enum_t_value);
  }
  static inline bool GeoEdgeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GeoEdgeType* value) {
    return GeoPolygon_GeoEdgeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEdgesFieldNumber = 1,
  };
  // repeated .world_proto.GeoPolygon.GeoEdge edges = 1;
  int edges_size() const;
  private:
  int _internal_edges_size() const;
  public:
  void clear_edges();
  ::world_proto::GeoPolygon_GeoEdge* mutable_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::GeoPolygon_GeoEdge >*
      mutable_edges();
  private:
  const ::world_proto::GeoPolygon_GeoEdge& _internal_edges(int index) const;
  ::world_proto::GeoPolygon_GeoEdge* _internal_add_edges();
  public:
  const ::world_proto::GeoPolygon_GeoEdge& edges(int index) const;
  ::world_proto::GeoPolygon_GeoEdge* add_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::GeoPolygon_GeoEdge >&
      edges() const;

  // @@protoc_insertion_point(class_scope:world_proto.GeoPolygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::GeoPolygon_GeoEdge > edges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class AirspaceGeometry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.AirspaceGeometry) */ {
 public:
  inline AirspaceGeometry() : AirspaceGeometry(nullptr) {}
  virtual ~AirspaceGeometry();

  AirspaceGeometry(const AirspaceGeometry& from);
  AirspaceGeometry(AirspaceGeometry&& from) noexcept
    : AirspaceGeometry() {
    *this = ::std::move(from);
  }

  inline AirspaceGeometry& operator=(const AirspaceGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline AirspaceGeometry& operator=(AirspaceGeometry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AirspaceGeometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AirspaceGeometry* internal_default_instance() {
    return reinterpret_cast<const AirspaceGeometry*>(
               &_AirspaceGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AirspaceGeometry& a, AirspaceGeometry& b) {
    a.Swap(&b);
  }
  inline void Swap(AirspaceGeometry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AirspaceGeometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AirspaceGeometry* New() const final {
    return CreateMaybeMessage<AirspaceGeometry>(nullptr);
  }

  AirspaceGeometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AirspaceGeometry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AirspaceGeometry& from);
  void MergeFrom(const AirspaceGeometry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AirspaceGeometry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.AirspaceGeometry";
  }
  protected:
  explicit AirspaceGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLateralBoundsFieldNumber = 1,
    kLowerBoundFeetFieldNumber = 2,
    kUpperBoundFeetFieldNumber = 3,
  };
  // .world_proto.GeoPolygon lateral_bounds = 1;
  bool has_lateral_bounds() const;
  private:
  bool _internal_has_lateral_bounds() const;
  public:
  void clear_lateral_bounds();
  const ::world_proto::GeoPolygon& lateral_bounds() const;
  ::world_proto::GeoPolygon* release_lateral_bounds();
  ::world_proto::GeoPolygon* mutable_lateral_bounds();
  void set_allocated_lateral_bounds(::world_proto::GeoPolygon* lateral_bounds);
  private:
  const ::world_proto::GeoPolygon& _internal_lateral_bounds() const;
  ::world_proto::GeoPolygon* _internal_mutable_lateral_bounds();
  public:
  void unsafe_arena_set_allocated_lateral_bounds(
      ::world_proto::GeoPolygon* lateral_bounds);
  ::world_proto::GeoPolygon* unsafe_arena_release_lateral_bounds();

  // float lower_bound_feet = 2;
  void clear_lower_bound_feet();
  float lower_bound_feet() const;
  void set_lower_bound_feet(float value);
  private:
  float _internal_lower_bound_feet() const;
  void _internal_set_lower_bound_feet(float value);
  public:

  // float upper_bound_feet = 3;
  void clear_upper_bound_feet();
  float upper_bound_feet() const;
  void set_upper_bound_feet(float value);
  private:
  float _internal_upper_bound_feet() const;
  void _internal_set_upper_bound_feet(float value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.AirspaceGeometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::GeoPolygon* lateral_bounds_;
  float lower_bound_feet_;
  float upper_bound_feet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ControlledAirspace PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ControlledAirspace) */ {
 public:
  inline ControlledAirspace() : ControlledAirspace(nullptr) {}
  virtual ~ControlledAirspace();

  ControlledAirspace(const ControlledAirspace& from);
  ControlledAirspace(ControlledAirspace&& from) noexcept
    : ControlledAirspace() {
    *this = ::std::move(from);
  }

  inline ControlledAirspace& operator=(const ControlledAirspace& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlledAirspace& operator=(ControlledAirspace&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlledAirspace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlledAirspace* internal_default_instance() {
    return reinterpret_cast<const ControlledAirspace*>(
               &_ControlledAirspace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ControlledAirspace& a, ControlledAirspace& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlledAirspace* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlledAirspace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlledAirspace* New() const final {
    return CreateMaybeMessage<ControlledAirspace>(nullptr);
  }

  ControlledAirspace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlledAirspace>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlledAirspace& from);
  void MergeFrom(const ControlledAirspace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlledAirspace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ControlledAirspace";
  }
  protected:
  explicit ControlledAirspace(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControlledAirspace_Type Type;
  static constexpr Type AIRSPACE_UNKNOWN =
    ControlledAirspace_Type_AIRSPACE_UNKNOWN;
  static constexpr Type AIRSPACE_CONTROL_ZONE =
    ControlledAirspace_Type_AIRSPACE_CONTROL_ZONE;
  static constexpr Type AIRSPACE_CONTROL_AREA =
    ControlledAirspace_Type_AIRSPACE_CONTROL_AREA;
  static constexpr Type AIRSPACE_TERMINAL_CONTROL_AREA =
    ControlledAirspace_Type_AIRSPACE_TERMINAL_CONTROL_AREA;
  static constexpr Type AIRSPACE_FIR_AREA =
    ControlledAirspace_Type_AIRSPACE_FIR_AREA;
  static constexpr Type AIRSPACE_FIR_OCEANIC =
    ControlledAirspace_Type_AIRSPACE_FIR_OCEANIC;
  static constexpr Type AIRSPACE_UIR_AREA =
    ControlledAirspace_Type_AIRSPACE_UIR_AREA;
  static constexpr Type AIRSPACE_UIR_OCEANIC =
    ControlledAirspace_Type_AIRSPACE_UIR_OCEANIC;
  static inline bool Type_IsValid(int value) {
    return ControlledAirspace_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ControlledAirspace_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ControlledAirspace_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ControlledAirspace_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ControlledAirspace_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ControlledAirspace_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ControlledAirspace_Type_Parse(name, value);
  }

  typedef ControlledAirspace_Classification Classification;
  static constexpr Classification AIRSPACE_CLASS_UNKNOWN =
    ControlledAirspace_Classification_AIRSPACE_CLASS_UNKNOWN;
  static constexpr Classification AIRSPACE_CLASS_A =
    ControlledAirspace_Classification_AIRSPACE_CLASS_A;
  static constexpr Classification AIRSPACE_CLASS_B =
    ControlledAirspace_Classification_AIRSPACE_CLASS_B;
  static constexpr Classification AIRSPACE_CLASS_C =
    ControlledAirspace_Classification_AIRSPACE_CLASS_C;
  static constexpr Classification AIRSPACE_CLASS_D =
    ControlledAirspace_Classification_AIRSPACE_CLASS_D;
  static constexpr Classification AIRSPACE_CLASS_E =
    ControlledAirspace_Classification_AIRSPACE_CLASS_E;
  static constexpr Classification AIRSPACE_CLASS_G =
    ControlledAirspace_Classification_AIRSPACE_CLASS_G;
  static inline bool Classification_IsValid(int value) {
    return ControlledAirspace_Classification_IsValid(value);
  }
  static constexpr Classification Classification_MIN =
    ControlledAirspace_Classification_Classification_MIN;
  static constexpr Classification Classification_MAX =
    ControlledAirspace_Classification_Classification_MAX;
  static constexpr int Classification_ARRAYSIZE =
    ControlledAirspace_Classification_Classification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Classification_descriptor() {
    return ControlledAirspace_Classification_descriptor();
  }
  template<typename T>
  static inline const std::string& Classification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Classification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Classification_Name.");
    return ControlledAirspace_Classification_Name(enum_t_value);
  }
  static inline bool Classification_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Classification* value) {
    return ControlledAirspace_Classification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAreaCodeFieldNumber = 1,
    kIcaoCodeFieldNumber = 2,
    kAirspaceCenterFieldNumber = 3,
    kControlledAirspaceNameFieldNumber = 4,
    kTowerAirportIcaoFieldNumber = 8,
    kGeometryFieldNumber = 7,
    kTypeFieldNumber = 5,
    kClassificationFieldNumber = 6,
  };
  // string area_code = 1;
  void clear_area_code();
  const std::string& area_code() const;
  void set_area_code(const std::string& value);
  void set_area_code(std::string&& value);
  void set_area_code(const char* value);
  void set_area_code(const char* value, size_t size);
  std::string* mutable_area_code();
  std::string* release_area_code();
  void set_allocated_area_code(std::string* area_code);
  private:
  const std::string& _internal_area_code() const;
  void _internal_set_area_code(const std::string& value);
  std::string* _internal_mutable_area_code();
  public:

  // string icao_code = 2;
  void clear_icao_code();
  const std::string& icao_code() const;
  void set_icao_code(const std::string& value);
  void set_icao_code(std::string&& value);
  void set_icao_code(const char* value);
  void set_icao_code(const char* value, size_t size);
  std::string* mutable_icao_code();
  std::string* release_icao_code();
  void set_allocated_icao_code(std::string* icao_code);
  private:
  const std::string& _internal_icao_code() const;
  void _internal_set_icao_code(const std::string& value);
  std::string* _internal_mutable_icao_code();
  public:

  // string airspace_center = 3;
  void clear_airspace_center();
  const std::string& airspace_center() const;
  void set_airspace_center(const std::string& value);
  void set_airspace_center(std::string&& value);
  void set_airspace_center(const char* value);
  void set_airspace_center(const char* value, size_t size);
  std::string* mutable_airspace_center();
  std::string* release_airspace_center();
  void set_allocated_airspace_center(std::string* airspace_center);
  private:
  const std::string& _internal_airspace_center() const;
  void _internal_set_airspace_center(const std::string& value);
  std::string* _internal_mutable_airspace_center();
  public:

  // string controlled_airspace_name = 4;
  void clear_controlled_airspace_name();
  const std::string& controlled_airspace_name() const;
  void set_controlled_airspace_name(const std::string& value);
  void set_controlled_airspace_name(std::string&& value);
  void set_controlled_airspace_name(const char* value);
  void set_controlled_airspace_name(const char* value, size_t size);
  std::string* mutable_controlled_airspace_name();
  std::string* release_controlled_airspace_name();
  void set_allocated_controlled_airspace_name(std::string* controlled_airspace_name);
  private:
  const std::string& _internal_controlled_airspace_name() const;
  void _internal_set_controlled_airspace_name(const std::string& value);
  std::string* _internal_mutable_controlled_airspace_name();
  public:

  // string tower_airport_icao = 8;
  void clear_tower_airport_icao();
  const std::string& tower_airport_icao() const;
  void set_tower_airport_icao(const std::string& value);
  void set_tower_airport_icao(std::string&& value);
  void set_tower_airport_icao(const char* value);
  void set_tower_airport_icao(const char* value, size_t size);
  std::string* mutable_tower_airport_icao();
  std::string* release_tower_airport_icao();
  void set_allocated_tower_airport_icao(std::string* tower_airport_icao);
  private:
  const std::string& _internal_tower_airport_icao() const;
  void _internal_set_tower_airport_icao(const std::string& value);
  std::string* _internal_mutable_tower_airport_icao();
  public:

  // .world_proto.AirspaceGeometry geometry = 7;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::world_proto::AirspaceGeometry& geometry() const;
  ::world_proto::AirspaceGeometry* release_geometry();
  ::world_proto::AirspaceGeometry* mutable_geometry();
  void set_allocated_geometry(::world_proto::AirspaceGeometry* geometry);
  private:
  const ::world_proto::AirspaceGeometry& _internal_geometry() const;
  ::world_proto::AirspaceGeometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::world_proto::AirspaceGeometry* geometry);
  ::world_proto::AirspaceGeometry* unsafe_arena_release_geometry();

  // .world_proto.ControlledAirspace.Type type = 5;
  void clear_type();
  ::world_proto::ControlledAirspace_Type type() const;
  void set_type(::world_proto::ControlledAirspace_Type value);
  private:
  ::world_proto::ControlledAirspace_Type _internal_type() const;
  void _internal_set_type(::world_proto::ControlledAirspace_Type value);
  public:

  // .world_proto.ControlledAirspace.Classification classification = 6;
  void clear_classification();
  ::world_proto::ControlledAirspace_Classification classification() const;
  void set_classification(::world_proto::ControlledAirspace_Classification value);
  private:
  ::world_proto::ControlledAirspace_Classification _internal_classification() const;
  void _internal_set_classification(::world_proto::ControlledAirspace_Classification value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ControlledAirspace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr area_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icao_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr airspace_center_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controlled_airspace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tower_airport_icao_;
  ::world_proto::AirspaceGeometry* geometry_;
  int type_;
  int classification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ControlFacility PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ControlFacility) */ {
 public:
  inline ControlFacility() : ControlFacility(nullptr) {}
  virtual ~ControlFacility();

  ControlFacility(const ControlFacility& from);
  ControlFacility(ControlFacility&& from) noexcept
    : ControlFacility() {
    *this = ::std::move(from);
  }

  inline ControlFacility& operator=(const ControlFacility& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlFacility& operator=(ControlFacility&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlFacility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlFacility* internal_default_instance() {
    return reinterpret_cast<const ControlFacility*>(
               &_ControlFacility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ControlFacility& a, ControlFacility& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlFacility* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlFacility* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlFacility* New() const final {
    return CreateMaybeMessage<ControlFacility>(nullptr);
  }

  ControlFacility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlFacility>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlFacility& from);
  void MergeFrom(const ControlFacility& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlFacility* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ControlFacility";
  }
  protected:
  explicit ControlFacility(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControlFacility_Type Type;
  static constexpr Type FACILITY_UNKNOWN =
    ControlFacility_Type_FACILITY_UNKNOWN;
  static constexpr Type FACILITY_TOWER =
    ControlFacility_Type_FACILITY_TOWER;
  static constexpr Type FACILITY_TERMINAL =
    ControlFacility_Type_FACILITY_TERMINAL;
  static constexpr Type FACILITY_CENTER =
    ControlFacility_Type_FACILITY_CENTER;
  static constexpr Type FACILITY_OCEANIC =
    ControlFacility_Type_FACILITY_OCEANIC;
  static inline bool Type_IsValid(int value) {
    return ControlFacility_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ControlFacility_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ControlFacility_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ControlFacility_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ControlFacility_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ControlFacility_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ControlFacility_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCallSignFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string call_sign = 1;
  void clear_call_sign();
  const std::string& call_sign() const;
  void set_call_sign(const std::string& value);
  void set_call_sign(std::string&& value);
  void set_call_sign(const char* value);
  void set_call_sign(const char* value, size_t size);
  std::string* mutable_call_sign();
  std::string* release_call_sign();
  void set_allocated_call_sign(std::string* call_sign);
  private:
  const std::string& _internal_call_sign() const;
  void _internal_set_call_sign(const std::string& value);
  std::string* _internal_mutable_call_sign();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .world_proto.ControlFacility.Type type = 3;
  void clear_type();
  ::world_proto::ControlFacility_Type type() const;
  void set_type(::world_proto::ControlFacility_Type value);
  private:
  ::world_proto::ControlFacility_Type _internal_type() const;
  void _internal_set_type(::world_proto::ControlFacility_Type value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ControlFacility)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Connect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer.Connect) */ {
 public:
  inline ClientToServer_Connect() : ClientToServer_Connect(nullptr) {}
  virtual ~ClientToServer_Connect();

  ClientToServer_Connect(const ClientToServer_Connect& from);
  ClientToServer_Connect(ClientToServer_Connect&& from) noexcept
    : ClientToServer_Connect() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Connect& operator=(const ClientToServer_Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Connect& operator=(ClientToServer_Connect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Connect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Connect* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Connect*>(
               &_ClientToServer_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ClientToServer_Connect& a, ClientToServer_Connect& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_Connect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_Connect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Connect* New() const final {
    return CreateMaybeMessage<ClientToServer_Connect>(nullptr);
  }

  ClientToServer_Connect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Connect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Connect& from);
  void MergeFrom(const ClientToServer_Connect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Connect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer.Connect";
  }
  protected:
  explicit ClientToServer_Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer.Connect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_QueryAirport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer.QueryAirport) */ {
 public:
  inline ClientToServer_QueryAirport() : ClientToServer_QueryAirport(nullptr) {}
  virtual ~ClientToServer_QueryAirport();

  ClientToServer_QueryAirport(const ClientToServer_QueryAirport& from);
  ClientToServer_QueryAirport(ClientToServer_QueryAirport&& from) noexcept
    : ClientToServer_QueryAirport() {
    *this = ::std::move(from);
  }

  inline ClientToServer_QueryAirport& operator=(const ClientToServer_QueryAirport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_QueryAirport& operator=(ClientToServer_QueryAirport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_QueryAirport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_QueryAirport* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_QueryAirport*>(
               &_ClientToServer_QueryAirport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ClientToServer_QueryAirport& a, ClientToServer_QueryAirport& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_QueryAirport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_QueryAirport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_QueryAirport* New() const final {
    return CreateMaybeMessage<ClientToServer_QueryAirport>(nullptr);
  }

  ClientToServer_QueryAirport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_QueryAirport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_QueryAirport& from);
  void MergeFrom(const ClientToServer_QueryAirport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_QueryAirport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer.QueryAirport";
  }
  protected:
  explicit ClientToServer_QueryAirport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIcaoCodeFieldNumber = 1,
  };
  // string icao_code = 1;
  void clear_icao_code();
  const std::string& icao_code() const;
  void set_icao_code(const std::string& value);
  void set_icao_code(std::string&& value);
  void set_icao_code(const char* value);
  void set_icao_code(const char* value, size_t size);
  std::string* mutable_icao_code();
  std::string* release_icao_code();
  void set_allocated_icao_code(std::string* icao_code);
  private:
  const std::string& _internal_icao_code() const;
  void _internal_set_icao_code(const std::string& value);
  std::string* _internal_mutable_icao_code();
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer.QueryAirport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icao_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_QueryTaxiPath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer.QueryTaxiPath) */ {
 public:
  inline ClientToServer_QueryTaxiPath() : ClientToServer_QueryTaxiPath(nullptr) {}
  virtual ~ClientToServer_QueryTaxiPath();

  ClientToServer_QueryTaxiPath(const ClientToServer_QueryTaxiPath& from);
  ClientToServer_QueryTaxiPath(ClientToServer_QueryTaxiPath&& from) noexcept
    : ClientToServer_QueryTaxiPath() {
    *this = ::std::move(from);
  }

  inline ClientToServer_QueryTaxiPath& operator=(const ClientToServer_QueryTaxiPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_QueryTaxiPath& operator=(ClientToServer_QueryTaxiPath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_QueryTaxiPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_QueryTaxiPath* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_QueryTaxiPath*>(
               &_ClientToServer_QueryTaxiPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ClientToServer_QueryTaxiPath& a, ClientToServer_QueryTaxiPath& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_QueryTaxiPath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_QueryTaxiPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_QueryTaxiPath* New() const final {
    return CreateMaybeMessage<ClientToServer_QueryTaxiPath>(nullptr);
  }

  ClientToServer_QueryTaxiPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_QueryTaxiPath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_QueryTaxiPath& from);
  void MergeFrom(const ClientToServer_QueryTaxiPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_QueryTaxiPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer.QueryTaxiPath";
  }
  protected:
  explicit ClientToServer_QueryTaxiPath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAirportIcaoFieldNumber = 1,
    kAircraftModelIcaoFieldNumber = 2,
    kFromPointFieldNumber = 3,
    kToPointFieldNumber = 4,
  };
  // string airport_icao = 1;
  void clear_airport_icao();
  const std::string& airport_icao() const;
  void set_airport_icao(const std::string& value);
  void set_airport_icao(std::string&& value);
  void set_airport_icao(const char* value);
  void set_airport_icao(const char* value, size_t size);
  std::string* mutable_airport_icao();
  std::string* release_airport_icao();
  void set_allocated_airport_icao(std::string* airport_icao);
  private:
  const std::string& _internal_airport_icao() const;
  void _internal_set_airport_icao(const std::string& value);
  std::string* _internal_mutable_airport_icao();
  public:

  // string aircraft_model_icao = 2;
  void clear_aircraft_model_icao();
  const std::string& aircraft_model_icao() const;
  void set_aircraft_model_icao(const std::string& value);
  void set_aircraft_model_icao(std::string&& value);
  void set_aircraft_model_icao(const char* value);
  void set_aircraft_model_icao(const char* value, size_t size);
  std::string* mutable_aircraft_model_icao();
  std::string* release_aircraft_model_icao();
  void set_allocated_aircraft_model_icao(std::string* aircraft_model_icao);
  private:
  const std::string& _internal_aircraft_model_icao() const;
  void _internal_set_aircraft_model_icao(const std::string& value);
  std::string* _internal_mutable_aircraft_model_icao();
  public:

  // .world_proto.GeoPoint from_point = 3;
  bool has_from_point() const;
  private:
  bool _internal_has_from_point() const;
  public:
  void clear_from_point();
  const ::world_proto::GeoPoint& from_point() const;
  ::world_proto::GeoPoint* release_from_point();
  ::world_proto::GeoPoint* mutable_from_point();
  void set_allocated_from_point(::world_proto::GeoPoint* from_point);
  private:
  const ::world_proto::GeoPoint& _internal_from_point() const;
  ::world_proto::GeoPoint* _internal_mutable_from_point();
  public:
  void unsafe_arena_set_allocated_from_point(
      ::world_proto::GeoPoint* from_point);
  ::world_proto::GeoPoint* unsafe_arena_release_from_point();

  // .world_proto.GeoPoint to_point = 4;
  bool has_to_point() const;
  private:
  bool _internal_has_to_point() const;
  public:
  void clear_to_point();
  const ::world_proto::GeoPoint& to_point() const;
  ::world_proto::GeoPoint* release_to_point();
  ::world_proto::GeoPoint* mutable_to_point();
  void set_allocated_to_point(::world_proto::GeoPoint* to_point);
  private:
  const ::world_proto::GeoPoint& _internal_to_point() const;
  ::world_proto::GeoPoint* _internal_mutable_to_point();
  public:
  void unsafe_arena_set_allocated_to_point(
      ::world_proto::GeoPoint* to_point);
  ::world_proto::GeoPoint* unsafe_arena_release_to_point();

  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer.QueryTaxiPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr airport_icao_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aircraft_model_icao_;
  ::world_proto::GeoPoint* from_point_;
  ::world_proto::GeoPoint* to_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_CreateAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer.CreateAircraft) */ {
 public:
  inline ClientToServer_CreateAircraft() : ClientToServer_CreateAircraft(nullptr) {}
  virtual ~ClientToServer_CreateAircraft();

  ClientToServer_CreateAircraft(const ClientToServer_CreateAircraft& from);
  ClientToServer_CreateAircraft(ClientToServer_CreateAircraft&& from) noexcept
    : ClientToServer_CreateAircraft() {
    *this = ::std::move(from);
  }

  inline ClientToServer_CreateAircraft& operator=(const ClientToServer_CreateAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_CreateAircraft& operator=(ClientToServer_CreateAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_CreateAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_CreateAircraft* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_CreateAircraft*>(
               &_ClientToServer_CreateAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ClientToServer_CreateAircraft& a, ClientToServer_CreateAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_CreateAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_CreateAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_CreateAircraft* New() const final {
    return CreateMaybeMessage<ClientToServer_CreateAircraft>(nullptr);
  }

  ClientToServer_CreateAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_CreateAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_CreateAircraft& from);
  void MergeFrom(const ClientToServer_CreateAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_CreateAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer.CreateAircraft";
  }
  protected:
  explicit ClientToServer_CreateAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftFieldNumber = 1,
  };
  // .world_proto.Aircraft aircraft = 1;
  bool has_aircraft() const;
  private:
  bool _internal_has_aircraft() const;
  public:
  void clear_aircraft();
  const ::world_proto::Aircraft& aircraft() const;
  ::world_proto::Aircraft* release_aircraft();
  ::world_proto::Aircraft* mutable_aircraft();
  void set_allocated_aircraft(::world_proto::Aircraft* aircraft);
  private:
  const ::world_proto::Aircraft& _internal_aircraft() const;
  ::world_proto::Aircraft* _internal_mutable_aircraft();
  public:
  void unsafe_arena_set_allocated_aircraft(
      ::world_proto::Aircraft* aircraft);
  ::world_proto::Aircraft* unsafe_arena_release_aircraft();

  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer.CreateAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::Aircraft* aircraft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UpdateAircraftSituation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer.UpdateAircraftSituation) */ {
 public:
  inline ClientToServer_UpdateAircraftSituation() : ClientToServer_UpdateAircraftSituation(nullptr) {}
  virtual ~ClientToServer_UpdateAircraftSituation();

  ClientToServer_UpdateAircraftSituation(const ClientToServer_UpdateAircraftSituation& from);
  ClientToServer_UpdateAircraftSituation(ClientToServer_UpdateAircraftSituation&& from) noexcept
    : ClientToServer_UpdateAircraftSituation() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UpdateAircraftSituation& operator=(const ClientToServer_UpdateAircraftSituation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UpdateAircraftSituation& operator=(ClientToServer_UpdateAircraftSituation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UpdateAircraftSituation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UpdateAircraftSituation* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UpdateAircraftSituation*>(
               &_ClientToServer_UpdateAircraftSituation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ClientToServer_UpdateAircraftSituation& a, ClientToServer_UpdateAircraftSituation& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UpdateAircraftSituation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UpdateAircraftSituation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UpdateAircraftSituation* New() const final {
    return CreateMaybeMessage<ClientToServer_UpdateAircraftSituation>(nullptr);
  }

  ClientToServer_UpdateAircraftSituation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UpdateAircraftSituation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UpdateAircraftSituation& from);
  void MergeFrom(const ClientToServer_UpdateAircraftSituation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UpdateAircraftSituation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer.UpdateAircraftSituation";
  }
  protected:
  explicit ClientToServer_UpdateAircraftSituation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSituationFieldNumber = 2,
    kAircraftIdFieldNumber = 1,
  };
  // .world_proto.Aircraft.Situation situation = 2;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::world_proto::Aircraft_Situation& situation() const;
  ::world_proto::Aircraft_Situation* release_situation();
  ::world_proto::Aircraft_Situation* mutable_situation();
  void set_allocated_situation(::world_proto::Aircraft_Situation* situation);
  private:
  const ::world_proto::Aircraft_Situation& _internal_situation() const;
  ::world_proto::Aircraft_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::world_proto::Aircraft_Situation* situation);
  ::world_proto::Aircraft_Situation* unsafe_arena_release_situation();

  // int32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::int32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer.UpdateAircraftSituation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::Aircraft_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::int32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_RemoveAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer.RemoveAircraft) */ {
 public:
  inline ClientToServer_RemoveAircraft() : ClientToServer_RemoveAircraft(nullptr) {}
  virtual ~ClientToServer_RemoveAircraft();

  ClientToServer_RemoveAircraft(const ClientToServer_RemoveAircraft& from);
  ClientToServer_RemoveAircraft(ClientToServer_RemoveAircraft&& from) noexcept
    : ClientToServer_RemoveAircraft() {
    *this = ::std::move(from);
  }

  inline ClientToServer_RemoveAircraft& operator=(const ClientToServer_RemoveAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_RemoveAircraft& operator=(ClientToServer_RemoveAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_RemoveAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_RemoveAircraft* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_RemoveAircraft*>(
               &_ClientToServer_RemoveAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ClientToServer_RemoveAircraft& a, ClientToServer_RemoveAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_RemoveAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_RemoveAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_RemoveAircraft* New() const final {
    return CreateMaybeMessage<ClientToServer_RemoveAircraft>(nullptr);
  }

  ClientToServer_RemoveAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_RemoveAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_RemoveAircraft& from);
  void MergeFrom(const ClientToServer_RemoveAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_RemoveAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer.RemoveAircraft";
  }
  protected:
  explicit ClientToServer_RemoveAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftIdFieldNumber = 1,
  };
  // int32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::int32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer.RemoveAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ClientToServer) */ {
 public:
  inline ClientToServer() : ClientToServer(nullptr) {}
  virtual ~ClientToServer();

  ClientToServer(const ClientToServer& from);
  ClientToServer(ClientToServer&& from) noexcept
    : ClientToServer() {
    *this = ::std::move(from);
  }

  inline ClientToServer& operator=(const ClientToServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer& operator=(ClientToServer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer& default_instance();

  enum PayloadCase {
    kConnect = 101,
    kQueryAirport = 102,
    kCreateAircraft = 103,
    kUpdateAircraftSituation = 104,
    kRemoveAircraft = 105,
    kQueryTaxiPath = 106,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer* internal_default_instance() {
    return reinterpret_cast<const ClientToServer*>(
               &_ClientToServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ClientToServer& a, ClientToServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer* New() const final {
    return CreateMaybeMessage<ClientToServer>(nullptr);
  }

  ClientToServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer& from);
  void MergeFrom(const ClientToServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ClientToServer";
  }
  protected:
  explicit ClientToServer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClientToServer_Connect Connect;
  typedef ClientToServer_QueryAirport QueryAirport;
  typedef ClientToServer_QueryTaxiPath QueryTaxiPath;
  typedef ClientToServer_CreateAircraft CreateAircraft;
  typedef ClientToServer_UpdateAircraftSituation UpdateAircraftSituation;
  typedef ClientToServer_RemoveAircraft RemoveAircraft;

  // accessors -------------------------------------------------------

  enum : int {
    kSentAtFieldNumber = 2,
    kIdFieldNumber = 1,
    kConnectFieldNumber = 101,
    kQueryAirportFieldNumber = 102,
    kCreateAircraftFieldNumber = 103,
    kUpdateAircraftSituationFieldNumber = 104,
    kRemoveAircraftFieldNumber = 105,
    kQueryTaxiPathFieldNumber = 106,
  };
  // .google.protobuf.Timestamp sent_at = 2;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_sent_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_sent_at();
  void set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_sent_at();
  public:
  void unsafe_arena_set_allocated_sent_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_sent_at();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .world_proto.ClientToServer.Connect connect = 101;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  const ::world_proto::ClientToServer_Connect& connect() const;
  ::world_proto::ClientToServer_Connect* release_connect();
  ::world_proto::ClientToServer_Connect* mutable_connect();
  void set_allocated_connect(::world_proto::ClientToServer_Connect* connect);
  private:
  const ::world_proto::ClientToServer_Connect& _internal_connect() const;
  ::world_proto::ClientToServer_Connect* _internal_mutable_connect();
  public:
  void unsafe_arena_set_allocated_connect(
      ::world_proto::ClientToServer_Connect* connect);
  ::world_proto::ClientToServer_Connect* unsafe_arena_release_connect();

  // .world_proto.ClientToServer.QueryAirport query_airport = 102;
  bool has_query_airport() const;
  private:
  bool _internal_has_query_airport() const;
  public:
  void clear_query_airport();
  const ::world_proto::ClientToServer_QueryAirport& query_airport() const;
  ::world_proto::ClientToServer_QueryAirport* release_query_airport();
  ::world_proto::ClientToServer_QueryAirport* mutable_query_airport();
  void set_allocated_query_airport(::world_proto::ClientToServer_QueryAirport* query_airport);
  private:
  const ::world_proto::ClientToServer_QueryAirport& _internal_query_airport() const;
  ::world_proto::ClientToServer_QueryAirport* _internal_mutable_query_airport();
  public:
  void unsafe_arena_set_allocated_query_airport(
      ::world_proto::ClientToServer_QueryAirport* query_airport);
  ::world_proto::ClientToServer_QueryAirport* unsafe_arena_release_query_airport();

  // .world_proto.ClientToServer.CreateAircraft create_aircraft = 103;
  bool has_create_aircraft() const;
  private:
  bool _internal_has_create_aircraft() const;
  public:
  void clear_create_aircraft();
  const ::world_proto::ClientToServer_CreateAircraft& create_aircraft() const;
  ::world_proto::ClientToServer_CreateAircraft* release_create_aircraft();
  ::world_proto::ClientToServer_CreateAircraft* mutable_create_aircraft();
  void set_allocated_create_aircraft(::world_proto::ClientToServer_CreateAircraft* create_aircraft);
  private:
  const ::world_proto::ClientToServer_CreateAircraft& _internal_create_aircraft() const;
  ::world_proto::ClientToServer_CreateAircraft* _internal_mutable_create_aircraft();
  public:
  void unsafe_arena_set_allocated_create_aircraft(
      ::world_proto::ClientToServer_CreateAircraft* create_aircraft);
  ::world_proto::ClientToServer_CreateAircraft* unsafe_arena_release_create_aircraft();

  // .world_proto.ClientToServer.UpdateAircraftSituation update_aircraft_situation = 104;
  bool has_update_aircraft_situation() const;
  private:
  bool _internal_has_update_aircraft_situation() const;
  public:
  void clear_update_aircraft_situation();
  const ::world_proto::ClientToServer_UpdateAircraftSituation& update_aircraft_situation() const;
  ::world_proto::ClientToServer_UpdateAircraftSituation* release_update_aircraft_situation();
  ::world_proto::ClientToServer_UpdateAircraftSituation* mutable_update_aircraft_situation();
  void set_allocated_update_aircraft_situation(::world_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation);
  private:
  const ::world_proto::ClientToServer_UpdateAircraftSituation& _internal_update_aircraft_situation() const;
  ::world_proto::ClientToServer_UpdateAircraftSituation* _internal_mutable_update_aircraft_situation();
  public:
  void unsafe_arena_set_allocated_update_aircraft_situation(
      ::world_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation);
  ::world_proto::ClientToServer_UpdateAircraftSituation* unsafe_arena_release_update_aircraft_situation();

  // .world_proto.ClientToServer.RemoveAircraft remove_aircraft = 105;
  bool has_remove_aircraft() const;
  private:
  bool _internal_has_remove_aircraft() const;
  public:
  void clear_remove_aircraft();
  const ::world_proto::ClientToServer_RemoveAircraft& remove_aircraft() const;
  ::world_proto::ClientToServer_RemoveAircraft* release_remove_aircraft();
  ::world_proto::ClientToServer_RemoveAircraft* mutable_remove_aircraft();
  void set_allocated_remove_aircraft(::world_proto::ClientToServer_RemoveAircraft* remove_aircraft);
  private:
  const ::world_proto::ClientToServer_RemoveAircraft& _internal_remove_aircraft() const;
  ::world_proto::ClientToServer_RemoveAircraft* _internal_mutable_remove_aircraft();
  public:
  void unsafe_arena_set_allocated_remove_aircraft(
      ::world_proto::ClientToServer_RemoveAircraft* remove_aircraft);
  ::world_proto::ClientToServer_RemoveAircraft* unsafe_arena_release_remove_aircraft();

  // .world_proto.ClientToServer.QueryTaxiPath query_taxi_path = 106;
  bool has_query_taxi_path() const;
  private:
  bool _internal_has_query_taxi_path() const;
  public:
  void clear_query_taxi_path();
  const ::world_proto::ClientToServer_QueryTaxiPath& query_taxi_path() const;
  ::world_proto::ClientToServer_QueryTaxiPath* release_query_taxi_path();
  ::world_proto::ClientToServer_QueryTaxiPath* mutable_query_taxi_path();
  void set_allocated_query_taxi_path(::world_proto::ClientToServer_QueryTaxiPath* query_taxi_path);
  private:
  const ::world_proto::ClientToServer_QueryTaxiPath& _internal_query_taxi_path() const;
  ::world_proto::ClientToServer_QueryTaxiPath* _internal_mutable_query_taxi_path();
  public:
  void unsafe_arena_set_allocated_query_taxi_path(
      ::world_proto::ClientToServer_QueryTaxiPath* query_taxi_path);
  ::world_proto::ClientToServer_QueryTaxiPath* unsafe_arena_release_query_taxi_path();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:world_proto.ClientToServer)
 private:
  class _Internal;
  void set_has_connect();
  void set_has_query_airport();
  void set_has_create_aircraft();
  void set_has_update_aircraft_situation();
  void set_has_remove_aircraft();
  void set_has_query_taxi_path();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* sent_at_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::world_proto::ClientToServer_Connect* connect_;
    ::world_proto::ClientToServer_QueryAirport* query_airport_;
    ::world_proto::ClientToServer_CreateAircraft* create_aircraft_;
    ::world_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation_;
    ::world_proto::ClientToServer_RemoveAircraft* remove_aircraft_;
    ::world_proto::ClientToServer_QueryTaxiPath* query_taxi_path_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_FaultDeclined PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.FaultDeclined) */ {
 public:
  inline ServerToClient_FaultDeclined() : ServerToClient_FaultDeclined(nullptr) {}
  virtual ~ServerToClient_FaultDeclined();

  ServerToClient_FaultDeclined(const ServerToClient_FaultDeclined& from);
  ServerToClient_FaultDeclined(ServerToClient_FaultDeclined&& from) noexcept
    : ServerToClient_FaultDeclined() {
    *this = ::std::move(from);
  }

  inline ServerToClient_FaultDeclined& operator=(const ServerToClient_FaultDeclined& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_FaultDeclined& operator=(ServerToClient_FaultDeclined&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_FaultDeclined& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_FaultDeclined* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_FaultDeclined*>(
               &_ServerToClient_FaultDeclined_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ServerToClient_FaultDeclined& a, ServerToClient_FaultDeclined& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_FaultDeclined* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_FaultDeclined* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_FaultDeclined* New() const final {
    return CreateMaybeMessage<ServerToClient_FaultDeclined>(nullptr);
  }

  ServerToClient_FaultDeclined* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_FaultDeclined>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_FaultDeclined& from);
  void MergeFrom(const ServerToClient_FaultDeclined& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_FaultDeclined* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.FaultDeclined";
  }
  protected:
  explicit ServerToClient_FaultDeclined(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.FaultDeclined)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_FaultNotFound PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.FaultNotFound) */ {
 public:
  inline ServerToClient_FaultNotFound() : ServerToClient_FaultNotFound(nullptr) {}
  virtual ~ServerToClient_FaultNotFound();

  ServerToClient_FaultNotFound(const ServerToClient_FaultNotFound& from);
  ServerToClient_FaultNotFound(ServerToClient_FaultNotFound&& from) noexcept
    : ServerToClient_FaultNotFound() {
    *this = ::std::move(from);
  }

  inline ServerToClient_FaultNotFound& operator=(const ServerToClient_FaultNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_FaultNotFound& operator=(ServerToClient_FaultNotFound&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_FaultNotFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_FaultNotFound* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_FaultNotFound*>(
               &_ServerToClient_FaultNotFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ServerToClient_FaultNotFound& a, ServerToClient_FaultNotFound& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_FaultNotFound* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_FaultNotFound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_FaultNotFound* New() const final {
    return CreateMaybeMessage<ServerToClient_FaultNotFound>(nullptr);
  }

  ServerToClient_FaultNotFound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_FaultNotFound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_FaultNotFound& from);
  void MergeFrom(const ServerToClient_FaultNotFound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_FaultNotFound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.FaultNotFound";
  }
  protected:
  explicit ServerToClient_FaultNotFound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.FaultNotFound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyConnect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.ReplyConnect) */ {
 public:
  inline ServerToClient_ReplyConnect() : ServerToClient_ReplyConnect(nullptr) {}
  virtual ~ServerToClient_ReplyConnect();

  ServerToClient_ReplyConnect(const ServerToClient_ReplyConnect& from);
  ServerToClient_ReplyConnect(ServerToClient_ReplyConnect&& from) noexcept
    : ServerToClient_ReplyConnect() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyConnect& operator=(const ServerToClient_ReplyConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyConnect& operator=(ServerToClient_ReplyConnect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyConnect* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyConnect*>(
               &_ServerToClient_ReplyConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ServerToClient_ReplyConnect& a, ServerToClient_ReplyConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyConnect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyConnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyConnect* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyConnect>(nullptr);
  }

  ServerToClient_ReplyConnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyConnect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyConnect& from);
  void MergeFrom(const ServerToClient_ReplyConnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyConnect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.ReplyConnect";
  }
  protected:
  explicit ServerToClient_ReplyConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerBannerFieldNumber = 2,
  };
  // string server_banner = 2;
  void clear_server_banner();
  const std::string& server_banner() const;
  void set_server_banner(const std::string& value);
  void set_server_banner(std::string&& value);
  void set_server_banner(const char* value);
  void set_server_banner(const char* value, size_t size);
  std::string* mutable_server_banner();
  std::string* release_server_banner();
  void set_allocated_server_banner(std::string* server_banner);
  private:
  const std::string& _internal_server_banner() const;
  void _internal_set_server_banner(const std::string& value);
  std::string* _internal_mutable_server_banner();
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.ReplyConnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_banner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyCreateAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.ReplyCreateAircraft) */ {
 public:
  inline ServerToClient_ReplyCreateAircraft() : ServerToClient_ReplyCreateAircraft(nullptr) {}
  virtual ~ServerToClient_ReplyCreateAircraft();

  ServerToClient_ReplyCreateAircraft(const ServerToClient_ReplyCreateAircraft& from);
  ServerToClient_ReplyCreateAircraft(ServerToClient_ReplyCreateAircraft&& from) noexcept
    : ServerToClient_ReplyCreateAircraft() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyCreateAircraft& operator=(const ServerToClient_ReplyCreateAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyCreateAircraft& operator=(ServerToClient_ReplyCreateAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyCreateAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyCreateAircraft* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyCreateAircraft*>(
               &_ServerToClient_ReplyCreateAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ServerToClient_ReplyCreateAircraft& a, ServerToClient_ReplyCreateAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyCreateAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyCreateAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyCreateAircraft* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyCreateAircraft>(nullptr);
  }

  ServerToClient_ReplyCreateAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyCreateAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyCreateAircraft& from);
  void MergeFrom(const ServerToClient_ReplyCreateAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyCreateAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.ReplyCreateAircraft";
  }
  protected:
  explicit ServerToClient_ReplyCreateAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatedAircraftIdFieldNumber = 1,
  };
  // int32 created_aircraft_id = 1;
  void clear_created_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::int32 created_aircraft_id() const;
  void set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_created_aircraft_id() const;
  void _internal_set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.ReplyCreateAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 created_aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyQueryAirport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.ReplyQueryAirport) */ {
 public:
  inline ServerToClient_ReplyQueryAirport() : ServerToClient_ReplyQueryAirport(nullptr) {}
  virtual ~ServerToClient_ReplyQueryAirport();

  ServerToClient_ReplyQueryAirport(const ServerToClient_ReplyQueryAirport& from);
  ServerToClient_ReplyQueryAirport(ServerToClient_ReplyQueryAirport&& from) noexcept
    : ServerToClient_ReplyQueryAirport() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyQueryAirport& operator=(const ServerToClient_ReplyQueryAirport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyQueryAirport& operator=(ServerToClient_ReplyQueryAirport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyQueryAirport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyQueryAirport* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyQueryAirport*>(
               &_ServerToClient_ReplyQueryAirport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ServerToClient_ReplyQueryAirport& a, ServerToClient_ReplyQueryAirport& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyQueryAirport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyQueryAirport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyQueryAirport* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryAirport>(nullptr);
  }

  ServerToClient_ReplyQueryAirport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryAirport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyQueryAirport& from);
  void MergeFrom(const ServerToClient_ReplyQueryAirport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyQueryAirport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.ReplyQueryAirport";
  }
  protected:
  explicit ServerToClient_ReplyQueryAirport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAirportFieldNumber = 1,
  };
  // .world_proto.Airport airport = 1;
  bool has_airport() const;
  private:
  bool _internal_has_airport() const;
  public:
  void clear_airport();
  const ::world_proto::Airport& airport() const;
  ::world_proto::Airport* release_airport();
  ::world_proto::Airport* mutable_airport();
  void set_allocated_airport(::world_proto::Airport* airport);
  private:
  const ::world_proto::Airport& _internal_airport() const;
  ::world_proto::Airport* _internal_mutable_airport();
  public:
  void unsafe_arena_set_allocated_airport(
      ::world_proto::Airport* airport);
  ::world_proto::Airport* unsafe_arena_release_airport();

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.ReplyQueryAirport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::Airport* airport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyQueryTaxiPath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.ReplyQueryTaxiPath) */ {
 public:
  inline ServerToClient_ReplyQueryTaxiPath() : ServerToClient_ReplyQueryTaxiPath(nullptr) {}
  virtual ~ServerToClient_ReplyQueryTaxiPath();

  ServerToClient_ReplyQueryTaxiPath(const ServerToClient_ReplyQueryTaxiPath& from);
  ServerToClient_ReplyQueryTaxiPath(ServerToClient_ReplyQueryTaxiPath&& from) noexcept
    : ServerToClient_ReplyQueryTaxiPath() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyQueryTaxiPath& operator=(const ServerToClient_ReplyQueryTaxiPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyQueryTaxiPath& operator=(ServerToClient_ReplyQueryTaxiPath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyQueryTaxiPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyQueryTaxiPath* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyQueryTaxiPath*>(
               &_ServerToClient_ReplyQueryTaxiPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ServerToClient_ReplyQueryTaxiPath& a, ServerToClient_ReplyQueryTaxiPath& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyQueryTaxiPath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyQueryTaxiPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyQueryTaxiPath* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryTaxiPath>(nullptr);
  }

  ServerToClient_ReplyQueryTaxiPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryTaxiPath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyQueryTaxiPath& from);
  void MergeFrom(const ServerToClient_ReplyQueryTaxiPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyQueryTaxiPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.ReplyQueryTaxiPath";
  }
  protected:
  explicit ServerToClient_ReplyQueryTaxiPath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaxiPathFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .world_proto.TaxiPath taxi_path = 2;
  bool has_taxi_path() const;
  private:
  bool _internal_has_taxi_path() const;
  public:
  void clear_taxi_path();
  const ::world_proto::TaxiPath& taxi_path() const;
  ::world_proto::TaxiPath* release_taxi_path();
  ::world_proto::TaxiPath* mutable_taxi_path();
  void set_allocated_taxi_path(::world_proto::TaxiPath* taxi_path);
  private:
  const ::world_proto::TaxiPath& _internal_taxi_path() const;
  ::world_proto::TaxiPath* _internal_mutable_taxi_path();
  public:
  void unsafe_arena_set_allocated_taxi_path(
      ::world_proto::TaxiPath* taxi_path);
  ::world_proto::TaxiPath* unsafe_arena_release_taxi_path();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.ReplyQueryTaxiPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::TaxiPath* taxi_path_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_NotifyAircraftCreated PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.NotifyAircraftCreated) */ {
 public:
  inline ServerToClient_NotifyAircraftCreated() : ServerToClient_NotifyAircraftCreated(nullptr) {}
  virtual ~ServerToClient_NotifyAircraftCreated();

  ServerToClient_NotifyAircraftCreated(const ServerToClient_NotifyAircraftCreated& from);
  ServerToClient_NotifyAircraftCreated(ServerToClient_NotifyAircraftCreated&& from) noexcept
    : ServerToClient_NotifyAircraftCreated() {
    *this = ::std::move(from);
  }

  inline ServerToClient_NotifyAircraftCreated& operator=(const ServerToClient_NotifyAircraftCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_NotifyAircraftCreated& operator=(ServerToClient_NotifyAircraftCreated&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_NotifyAircraftCreated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_NotifyAircraftCreated* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_NotifyAircraftCreated*>(
               &_ServerToClient_NotifyAircraftCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ServerToClient_NotifyAircraftCreated& a, ServerToClient_NotifyAircraftCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_NotifyAircraftCreated* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_NotifyAircraftCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_NotifyAircraftCreated* New() const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftCreated>(nullptr);
  }

  ServerToClient_NotifyAircraftCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftCreated>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_NotifyAircraftCreated& from);
  void MergeFrom(const ServerToClient_NotifyAircraftCreated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_NotifyAircraftCreated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.NotifyAircraftCreated";
  }
  protected:
  explicit ServerToClient_NotifyAircraftCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftFieldNumber = 1,
  };
  // .world_proto.Aircraft aircraft = 1;
  bool has_aircraft() const;
  private:
  bool _internal_has_aircraft() const;
  public:
  void clear_aircraft();
  const ::world_proto::Aircraft& aircraft() const;
  ::world_proto::Aircraft* release_aircraft();
  ::world_proto::Aircraft* mutable_aircraft();
  void set_allocated_aircraft(::world_proto::Aircraft* aircraft);
  private:
  const ::world_proto::Aircraft& _internal_aircraft() const;
  ::world_proto::Aircraft* _internal_mutable_aircraft();
  public:
  void unsafe_arena_set_allocated_aircraft(
      ::world_proto::Aircraft* aircraft);
  ::world_proto::Aircraft* unsafe_arena_release_aircraft();

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.NotifyAircraftCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::Aircraft* aircraft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_NotifyAircraftSituationUpdated PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.NotifyAircraftSituationUpdated) */ {
 public:
  inline ServerToClient_NotifyAircraftSituationUpdated() : ServerToClient_NotifyAircraftSituationUpdated(nullptr) {}
  virtual ~ServerToClient_NotifyAircraftSituationUpdated();

  ServerToClient_NotifyAircraftSituationUpdated(const ServerToClient_NotifyAircraftSituationUpdated& from);
  ServerToClient_NotifyAircraftSituationUpdated(ServerToClient_NotifyAircraftSituationUpdated&& from) noexcept
    : ServerToClient_NotifyAircraftSituationUpdated() {
    *this = ::std::move(from);
  }

  inline ServerToClient_NotifyAircraftSituationUpdated& operator=(const ServerToClient_NotifyAircraftSituationUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_NotifyAircraftSituationUpdated& operator=(ServerToClient_NotifyAircraftSituationUpdated&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_NotifyAircraftSituationUpdated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_NotifyAircraftSituationUpdated* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_NotifyAircraftSituationUpdated*>(
               &_ServerToClient_NotifyAircraftSituationUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ServerToClient_NotifyAircraftSituationUpdated& a, ServerToClient_NotifyAircraftSituationUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_NotifyAircraftSituationUpdated* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_NotifyAircraftSituationUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_NotifyAircraftSituationUpdated* New() const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftSituationUpdated>(nullptr);
  }

  ServerToClient_NotifyAircraftSituationUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftSituationUpdated>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_NotifyAircraftSituationUpdated& from);
  void MergeFrom(const ServerToClient_NotifyAircraftSituationUpdated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_NotifyAircraftSituationUpdated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.NotifyAircraftSituationUpdated";
  }
  protected:
  explicit ServerToClient_NotifyAircraftSituationUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSituationFieldNumber = 2,
    kAirctaftIdFieldNumber = 1,
  };
  // .world_proto.Aircraft.Situation situation = 2;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::world_proto::Aircraft_Situation& situation() const;
  ::world_proto::Aircraft_Situation* release_situation();
  ::world_proto::Aircraft_Situation* mutable_situation();
  void set_allocated_situation(::world_proto::Aircraft_Situation* situation);
  private:
  const ::world_proto::Aircraft_Situation& _internal_situation() const;
  ::world_proto::Aircraft_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::world_proto::Aircraft_Situation* situation);
  ::world_proto::Aircraft_Situation* unsafe_arena_release_situation();

  // int32 airctaft_id = 1;
  void clear_airctaft_id();
  ::PROTOBUF_NAMESPACE_ID::int32 airctaft_id() const;
  void set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_airctaft_id() const;
  void _internal_set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.NotifyAircraftSituationUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::world_proto::Aircraft_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::int32 airctaft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_NotifyAircraftRemoved PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient.NotifyAircraftRemoved) */ {
 public:
  inline ServerToClient_NotifyAircraftRemoved() : ServerToClient_NotifyAircraftRemoved(nullptr) {}
  virtual ~ServerToClient_NotifyAircraftRemoved();

  ServerToClient_NotifyAircraftRemoved(const ServerToClient_NotifyAircraftRemoved& from);
  ServerToClient_NotifyAircraftRemoved(ServerToClient_NotifyAircraftRemoved&& from) noexcept
    : ServerToClient_NotifyAircraftRemoved() {
    *this = ::std::move(from);
  }

  inline ServerToClient_NotifyAircraftRemoved& operator=(const ServerToClient_NotifyAircraftRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_NotifyAircraftRemoved& operator=(ServerToClient_NotifyAircraftRemoved&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_NotifyAircraftRemoved& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_NotifyAircraftRemoved* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_NotifyAircraftRemoved*>(
               &_ServerToClient_NotifyAircraftRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ServerToClient_NotifyAircraftRemoved& a, ServerToClient_NotifyAircraftRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_NotifyAircraftRemoved* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_NotifyAircraftRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_NotifyAircraftRemoved* New() const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftRemoved>(nullptr);
  }

  ServerToClient_NotifyAircraftRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftRemoved>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_NotifyAircraftRemoved& from);
  void MergeFrom(const ServerToClient_NotifyAircraftRemoved& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_NotifyAircraftRemoved* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient.NotifyAircraftRemoved";
  }
  protected:
  explicit ServerToClient_NotifyAircraftRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAirctaftIdFieldNumber = 1,
  };
  // int32 airctaft_id = 1;
  void clear_airctaft_id();
  ::PROTOBUF_NAMESPACE_ID::int32 airctaft_id() const;
  void set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_airctaft_id() const;
  void _internal_set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient.NotifyAircraftRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 airctaft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world_proto.ServerToClient) */ {
 public:
  inline ServerToClient() : ServerToClient(nullptr) {}
  virtual ~ServerToClient();

  ServerToClient(const ServerToClient& from);
  ServerToClient(ServerToClient&& from) noexcept
    : ServerToClient() {
    *this = ::std::move(from);
  }

  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient& operator=(ServerToClient&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient& default_instance();

  enum PayloadCase {
    kReplyConnect = 1101,
    kReplyQueryAirport = 1102,
    kReplyCreateAircraft = 1103,
    kReplyQueryTaxiPath = 1106,
    kNotifyAircraftCreated = 201,
    kNotifyAircraftSituationUpdated = 202,
    kNotifyAircraftRemoved = 203,
    kFaultDeclined = 3001,
    kFaultNotFound = 3002,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient* internal_default_instance() {
    return reinterpret_cast<const ServerToClient*>(
               &_ServerToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ServerToClient& a, ServerToClient& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient* New() const final {
    return CreateMaybeMessage<ServerToClient>(nullptr);
  }

  ServerToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world_proto.ServerToClient";
  }
  protected:
  explicit ServerToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ServerToClient_FaultDeclined FaultDeclined;
  typedef ServerToClient_FaultNotFound FaultNotFound;
  typedef ServerToClient_ReplyConnect ReplyConnect;
  typedef ServerToClient_ReplyCreateAircraft ReplyCreateAircraft;
  typedef ServerToClient_ReplyQueryAirport ReplyQueryAirport;
  typedef ServerToClient_ReplyQueryTaxiPath ReplyQueryTaxiPath;
  typedef ServerToClient_NotifyAircraftCreated NotifyAircraftCreated;
  typedef ServerToClient_NotifyAircraftSituationUpdated NotifyAircraftSituationUpdated;
  typedef ServerToClient_NotifyAircraftRemoved NotifyAircraftRemoved;

  // accessors -------------------------------------------------------

  enum : int {
    kSentAtFieldNumber = 4,
    kRequestSentAtFieldNumber = 5,
    kRequestReceivedAtFieldNumber = 6,
    kIdFieldNumber = 2,
    kReplyToRequestIdFieldNumber = 3,
    kReplyConnectFieldNumber = 1101,
    kReplyQueryAirportFieldNumber = 1102,
    kReplyCreateAircraftFieldNumber = 1103,
    kReplyQueryTaxiPathFieldNumber = 1106,
    kNotifyAircraftCreatedFieldNumber = 201,
    kNotifyAircraftSituationUpdatedFieldNumber = 202,
    kNotifyAircraftRemovedFieldNumber = 203,
    kFaultDeclinedFieldNumber = 3001,
    kFaultNotFoundFieldNumber = 3002,
  };
  // .google.protobuf.Timestamp sent_at = 4;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_sent_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_sent_at();
  void set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_sent_at();
  public:
  void unsafe_arena_set_allocated_sent_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_sent_at();

  // .google.protobuf.Timestamp request_sent_at = 5;
  bool has_request_sent_at() const;
  private:
  bool _internal_has_request_sent_at() const;
  public:
  void clear_request_sent_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& request_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_request_sent_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_request_sent_at();
  void set_allocated_request_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_request_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_request_sent_at();
  public:
  void unsafe_arena_set_allocated_request_sent_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_request_sent_at();

  // .google.protobuf.Timestamp request_received_at = 6;
  bool has_request_received_at() const;
  private:
  bool _internal_has_request_received_at() const;
  public:
  void clear_request_received_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& request_received_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_request_received_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_request_received_at();
  void set_allocated_request_received_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_request_received_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_request_received_at();
  public:
  void unsafe_arena_set_allocated_request_received_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_request_received_at();

  // uint64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 reply_to_request_id = 3;
  void clear_reply_to_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 reply_to_request_id() const;
  void set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reply_to_request_id() const;
  void _internal_set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .world_proto.ServerToClient.ReplyConnect reply_connect = 1101;
  bool has_reply_connect() const;
  private:
  bool _internal_has_reply_connect() const;
  public:
  void clear_reply_connect();
  const ::world_proto::ServerToClient_ReplyConnect& reply_connect() const;
  ::world_proto::ServerToClient_ReplyConnect* release_reply_connect();
  ::world_proto::ServerToClient_ReplyConnect* mutable_reply_connect();
  void set_allocated_reply_connect(::world_proto::ServerToClient_ReplyConnect* reply_connect);
  private:
  const ::world_proto::ServerToClient_ReplyConnect& _internal_reply_connect() const;
  ::world_proto::ServerToClient_ReplyConnect* _internal_mutable_reply_connect();
  public:
  void unsafe_arena_set_allocated_reply_connect(
      ::world_proto::ServerToClient_ReplyConnect* reply_connect);
  ::world_proto::ServerToClient_ReplyConnect* unsafe_arena_release_reply_connect();

  // .world_proto.ServerToClient.ReplyQueryAirport reply_query_airport = 1102;
  bool has_reply_query_airport() const;
  private:
  bool _internal_has_reply_query_airport() const;
  public:
  void clear_reply_query_airport();
  const ::world_proto::ServerToClient_ReplyQueryAirport& reply_query_airport() const;
  ::world_proto::ServerToClient_ReplyQueryAirport* release_reply_query_airport();
  ::world_proto::ServerToClient_ReplyQueryAirport* mutable_reply_query_airport();
  void set_allocated_reply_query_airport(::world_proto::ServerToClient_ReplyQueryAirport* reply_query_airport);
  private:
  const ::world_proto::ServerToClient_ReplyQueryAirport& _internal_reply_query_airport() const;
  ::world_proto::ServerToClient_ReplyQueryAirport* _internal_mutable_reply_query_airport();
  public:
  void unsafe_arena_set_allocated_reply_query_airport(
      ::world_proto::ServerToClient_ReplyQueryAirport* reply_query_airport);
  ::world_proto::ServerToClient_ReplyQueryAirport* unsafe_arena_release_reply_query_airport();

  // .world_proto.ServerToClient.ReplyCreateAircraft reply_create_aircraft = 1103;
  bool has_reply_create_aircraft() const;
  private:
  bool _internal_has_reply_create_aircraft() const;
  public:
  void clear_reply_create_aircraft();
  const ::world_proto::ServerToClient_ReplyCreateAircraft& reply_create_aircraft() const;
  ::world_proto::ServerToClient_ReplyCreateAircraft* release_reply_create_aircraft();
  ::world_proto::ServerToClient_ReplyCreateAircraft* mutable_reply_create_aircraft();
  void set_allocated_reply_create_aircraft(::world_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft);
  private:
  const ::world_proto::ServerToClient_ReplyCreateAircraft& _internal_reply_create_aircraft() const;
  ::world_proto::ServerToClient_ReplyCreateAircraft* _internal_mutable_reply_create_aircraft();
  public:
  void unsafe_arena_set_allocated_reply_create_aircraft(
      ::world_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft);
  ::world_proto::ServerToClient_ReplyCreateAircraft* unsafe_arena_release_reply_create_aircraft();

  // .world_proto.ServerToClient.ReplyQueryTaxiPath reply_query_taxi_path = 1106;
  bool has_reply_query_taxi_path() const;
  private:
  bool _internal_has_reply_query_taxi_path() const;
  public:
  void clear_reply_query_taxi_path();
  const ::world_proto::ServerToClient_ReplyQueryTaxiPath& reply_query_taxi_path() const;
  ::world_proto::ServerToClient_ReplyQueryTaxiPath* release_reply_query_taxi_path();
  ::world_proto::ServerToClient_ReplyQueryTaxiPath* mutable_reply_query_taxi_path();
  void set_allocated_reply_query_taxi_path(::world_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path);
  private:
  const ::world_proto::ServerToClient_ReplyQueryTaxiPath& _internal_reply_query_taxi_path() const;
  ::world_proto::ServerToClient_ReplyQueryTaxiPath* _internal_mutable_reply_query_taxi_path();
  public:
  void unsafe_arena_set_allocated_reply_query_taxi_path(
      ::world_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path);
  ::world_proto::ServerToClient_ReplyQueryTaxiPath* unsafe_arena_release_reply_query_taxi_path();

  // .world_proto.ServerToClient.NotifyAircraftCreated notify_aircraft_created = 201;
  bool has_notify_aircraft_created() const;
  private:
  bool _internal_has_notify_aircraft_created() const;
  public:
  void clear_notify_aircraft_created();
  const ::world_proto::ServerToClient_NotifyAircraftCreated& notify_aircraft_created() const;
  ::world_proto::ServerToClient_NotifyAircraftCreated* release_notify_aircraft_created();
  ::world_proto::ServerToClient_NotifyAircraftCreated* mutable_notify_aircraft_created();
  void set_allocated_notify_aircraft_created(::world_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created);
  private:
  const ::world_proto::ServerToClient_NotifyAircraftCreated& _internal_notify_aircraft_created() const;
  ::world_proto::ServerToClient_NotifyAircraftCreated* _internal_mutable_notify_aircraft_created();
  public:
  void unsafe_arena_set_allocated_notify_aircraft_created(
      ::world_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created);
  ::world_proto::ServerToClient_NotifyAircraftCreated* unsafe_arena_release_notify_aircraft_created();

  // .world_proto.ServerToClient.NotifyAircraftSituationUpdated notify_aircraft_situation_updated = 202;
  bool has_notify_aircraft_situation_updated() const;
  private:
  bool _internal_has_notify_aircraft_situation_updated() const;
  public:
  void clear_notify_aircraft_situation_updated();
  const ::world_proto::ServerToClient_NotifyAircraftSituationUpdated& notify_aircraft_situation_updated() const;
  ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* release_notify_aircraft_situation_updated();
  ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* mutable_notify_aircraft_situation_updated();
  void set_allocated_notify_aircraft_situation_updated(::world_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated);
  private:
  const ::world_proto::ServerToClient_NotifyAircraftSituationUpdated& _internal_notify_aircraft_situation_updated() const;
  ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* _internal_mutable_notify_aircraft_situation_updated();
  public:
  void unsafe_arena_set_allocated_notify_aircraft_situation_updated(
      ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated);
  ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* unsafe_arena_release_notify_aircraft_situation_updated();

  // .world_proto.ServerToClient.NotifyAircraftRemoved notify_aircraft_removed = 203;
  bool has_notify_aircraft_removed() const;
  private:
  bool _internal_has_notify_aircraft_removed() const;
  public:
  void clear_notify_aircraft_removed();
  const ::world_proto::ServerToClient_NotifyAircraftRemoved& notify_aircraft_removed() const;
  ::world_proto::ServerToClient_NotifyAircraftRemoved* release_notify_aircraft_removed();
  ::world_proto::ServerToClient_NotifyAircraftRemoved* mutable_notify_aircraft_removed();
  void set_allocated_notify_aircraft_removed(::world_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed);
  private:
  const ::world_proto::ServerToClient_NotifyAircraftRemoved& _internal_notify_aircraft_removed() const;
  ::world_proto::ServerToClient_NotifyAircraftRemoved* _internal_mutable_notify_aircraft_removed();
  public:
  void unsafe_arena_set_allocated_notify_aircraft_removed(
      ::world_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed);
  ::world_proto::ServerToClient_NotifyAircraftRemoved* unsafe_arena_release_notify_aircraft_removed();

  // .world_proto.ServerToClient.FaultDeclined fault_declined = 3001;
  bool has_fault_declined() const;
  private:
  bool _internal_has_fault_declined() const;
  public:
  void clear_fault_declined();
  const ::world_proto::ServerToClient_FaultDeclined& fault_declined() const;
  ::world_proto::ServerToClient_FaultDeclined* release_fault_declined();
  ::world_proto::ServerToClient_FaultDeclined* mutable_fault_declined();
  void set_allocated_fault_declined(::world_proto::ServerToClient_FaultDeclined* fault_declined);
  private:
  const ::world_proto::ServerToClient_FaultDeclined& _internal_fault_declined() const;
  ::world_proto::ServerToClient_FaultDeclined* _internal_mutable_fault_declined();
  public:
  void unsafe_arena_set_allocated_fault_declined(
      ::world_proto::ServerToClient_FaultDeclined* fault_declined);
  ::world_proto::ServerToClient_FaultDeclined* unsafe_arena_release_fault_declined();

  // .world_proto.ServerToClient.FaultNotFound fault_not_found = 3002;
  bool has_fault_not_found() const;
  private:
  bool _internal_has_fault_not_found() const;
  public:
  void clear_fault_not_found();
  const ::world_proto::ServerToClient_FaultNotFound& fault_not_found() const;
  ::world_proto::ServerToClient_FaultNotFound* release_fault_not_found();
  ::world_proto::ServerToClient_FaultNotFound* mutable_fault_not_found();
  void set_allocated_fault_not_found(::world_proto::ServerToClient_FaultNotFound* fault_not_found);
  private:
  const ::world_proto::ServerToClient_FaultNotFound& _internal_fault_not_found() const;
  ::world_proto::ServerToClient_FaultNotFound* _internal_mutable_fault_not_found();
  public:
  void unsafe_arena_set_allocated_fault_not_found(
      ::world_proto::ServerToClient_FaultNotFound* fault_not_found);
  ::world_proto::ServerToClient_FaultNotFound* unsafe_arena_release_fault_not_found();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:world_proto.ServerToClient)
 private:
  class _Internal;
  void set_has_reply_connect();
  void set_has_reply_query_airport();
  void set_has_reply_create_aircraft();
  void set_has_reply_query_taxi_path();
  void set_has_notify_aircraft_created();
  void set_has_notify_aircraft_situation_updated();
  void set_has_notify_aircraft_removed();
  void set_has_fault_declined();
  void set_has_fault_not_found();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* sent_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 reply_to_request_id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::world_proto::ServerToClient_ReplyConnect* reply_connect_;
    ::world_proto::ServerToClient_ReplyQueryAirport* reply_query_airport_;
    ::world_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft_;
    ::world_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path_;
    ::world_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created_;
    ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated_;
    ::world_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed_;
    ::world_proto::ServerToClient_FaultDeclined* fault_declined_;
    ::world_proto::ServerToClient_FaultNotFound* fault_not_found_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_world_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GeoPoint

// double lat = 1;
inline void GeoPoint::clear_lat() {
  lat_ = 0;
}
inline double GeoPoint::_internal_lat() const {
  return lat_;
}
inline double GeoPoint::lat() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoPoint.lat)
  return _internal_lat();
}
inline void GeoPoint::_internal_set_lat(double value) {
  
  lat_ = value;
}
inline void GeoPoint::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:world_proto.GeoPoint.lat)
}

// double lon = 2;
inline void GeoPoint::clear_lon() {
  lon_ = 0;
}
inline double GeoPoint::_internal_lon() const {
  return lon_;
}
inline double GeoPoint::lon() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoPoint.lon)
  return _internal_lon();
}
inline void GeoPoint::_internal_set_lon(double value) {
  
  lon_ = value;
}
inline void GeoPoint::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:world_proto.GeoPoint.lon)
}

// -------------------------------------------------------------------

// GeoBox

// .world_proto.GeoPoint north_west = 1;
inline bool GeoBox::_internal_has_north_west() const {
  return this != internal_default_instance() && north_west_ != nullptr;
}
inline bool GeoBox::has_north_west() const {
  return _internal_has_north_west();
}
inline void GeoBox::clear_north_west() {
  if (GetArena() == nullptr && north_west_ != nullptr) {
    delete north_west_;
  }
  north_west_ = nullptr;
}
inline const ::world_proto::GeoPoint& GeoBox::_internal_north_west() const {
  const ::world_proto::GeoPoint* p = north_west_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& GeoBox::north_west() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoBox.north_west)
  return _internal_north_west();
}
inline void GeoBox::unsafe_arena_set_allocated_north_west(
    ::world_proto::GeoPoint* north_west) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(north_west_);
  }
  north_west_ = north_west;
  if (north_west) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.GeoBox.north_west)
}
inline ::world_proto::GeoPoint* GeoBox::release_north_west() {
  
  ::world_proto::GeoPoint* temp = north_west_;
  north_west_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::unsafe_arena_release_north_west() {
  // @@protoc_insertion_point(field_release:world_proto.GeoBox.north_west)
  
  ::world_proto::GeoPoint* temp = north_west_;
  north_west_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::_internal_mutable_north_west() {
  
  if (north_west_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    north_west_ = p;
  }
  return north_west_;
}
inline ::world_proto::GeoPoint* GeoBox::mutable_north_west() {
  // @@protoc_insertion_point(field_mutable:world_proto.GeoBox.north_west)
  return _internal_mutable_north_west();
}
inline void GeoBox::set_allocated_north_west(::world_proto::GeoPoint* north_west) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete north_west_;
  }
  if (north_west) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(north_west);
    if (message_arena != submessage_arena) {
      north_west = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, north_west, submessage_arena);
    }
    
  } else {
    
  }
  north_west_ = north_west;
  // @@protoc_insertion_point(field_set_allocated:world_proto.GeoBox.north_west)
}

// .world_proto.GeoPoint north_east = 2;
inline bool GeoBox::_internal_has_north_east() const {
  return this != internal_default_instance() && north_east_ != nullptr;
}
inline bool GeoBox::has_north_east() const {
  return _internal_has_north_east();
}
inline void GeoBox::clear_north_east() {
  if (GetArena() == nullptr && north_east_ != nullptr) {
    delete north_east_;
  }
  north_east_ = nullptr;
}
inline const ::world_proto::GeoPoint& GeoBox::_internal_north_east() const {
  const ::world_proto::GeoPoint* p = north_east_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& GeoBox::north_east() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoBox.north_east)
  return _internal_north_east();
}
inline void GeoBox::unsafe_arena_set_allocated_north_east(
    ::world_proto::GeoPoint* north_east) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(north_east_);
  }
  north_east_ = north_east;
  if (north_east) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.GeoBox.north_east)
}
inline ::world_proto::GeoPoint* GeoBox::release_north_east() {
  
  ::world_proto::GeoPoint* temp = north_east_;
  north_east_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::unsafe_arena_release_north_east() {
  // @@protoc_insertion_point(field_release:world_proto.GeoBox.north_east)
  
  ::world_proto::GeoPoint* temp = north_east_;
  north_east_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::_internal_mutable_north_east() {
  
  if (north_east_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    north_east_ = p;
  }
  return north_east_;
}
inline ::world_proto::GeoPoint* GeoBox::mutable_north_east() {
  // @@protoc_insertion_point(field_mutable:world_proto.GeoBox.north_east)
  return _internal_mutable_north_east();
}
inline void GeoBox::set_allocated_north_east(::world_proto::GeoPoint* north_east) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete north_east_;
  }
  if (north_east) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(north_east);
    if (message_arena != submessage_arena) {
      north_east = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, north_east, submessage_arena);
    }
    
  } else {
    
  }
  north_east_ = north_east;
  // @@protoc_insertion_point(field_set_allocated:world_proto.GeoBox.north_east)
}

// .world_proto.GeoPoint south_west = 3;
inline bool GeoBox::_internal_has_south_west() const {
  return this != internal_default_instance() && south_west_ != nullptr;
}
inline bool GeoBox::has_south_west() const {
  return _internal_has_south_west();
}
inline void GeoBox::clear_south_west() {
  if (GetArena() == nullptr && south_west_ != nullptr) {
    delete south_west_;
  }
  south_west_ = nullptr;
}
inline const ::world_proto::GeoPoint& GeoBox::_internal_south_west() const {
  const ::world_proto::GeoPoint* p = south_west_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& GeoBox::south_west() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoBox.south_west)
  return _internal_south_west();
}
inline void GeoBox::unsafe_arena_set_allocated_south_west(
    ::world_proto::GeoPoint* south_west) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(south_west_);
  }
  south_west_ = south_west;
  if (south_west) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.GeoBox.south_west)
}
inline ::world_proto::GeoPoint* GeoBox::release_south_west() {
  
  ::world_proto::GeoPoint* temp = south_west_;
  south_west_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::unsafe_arena_release_south_west() {
  // @@protoc_insertion_point(field_release:world_proto.GeoBox.south_west)
  
  ::world_proto::GeoPoint* temp = south_west_;
  south_west_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::_internal_mutable_south_west() {
  
  if (south_west_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    south_west_ = p;
  }
  return south_west_;
}
inline ::world_proto::GeoPoint* GeoBox::mutable_south_west() {
  // @@protoc_insertion_point(field_mutable:world_proto.GeoBox.south_west)
  return _internal_mutable_south_west();
}
inline void GeoBox::set_allocated_south_west(::world_proto::GeoPoint* south_west) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete south_west_;
  }
  if (south_west) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(south_west);
    if (message_arena != submessage_arena) {
      south_west = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, south_west, submessage_arena);
    }
    
  } else {
    
  }
  south_west_ = south_west;
  // @@protoc_insertion_point(field_set_allocated:world_proto.GeoBox.south_west)
}

// .world_proto.GeoPoint south_east = 4;
inline bool GeoBox::_internal_has_south_east() const {
  return this != internal_default_instance() && south_east_ != nullptr;
}
inline bool GeoBox::has_south_east() const {
  return _internal_has_south_east();
}
inline void GeoBox::clear_south_east() {
  if (GetArena() == nullptr && south_east_ != nullptr) {
    delete south_east_;
  }
  south_east_ = nullptr;
}
inline const ::world_proto::GeoPoint& GeoBox::_internal_south_east() const {
  const ::world_proto::GeoPoint* p = south_east_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& GeoBox::south_east() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoBox.south_east)
  return _internal_south_east();
}
inline void GeoBox::unsafe_arena_set_allocated_south_east(
    ::world_proto::GeoPoint* south_east) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(south_east_);
  }
  south_east_ = south_east;
  if (south_east) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.GeoBox.south_east)
}
inline ::world_proto::GeoPoint* GeoBox::release_south_east() {
  
  ::world_proto::GeoPoint* temp = south_east_;
  south_east_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::unsafe_arena_release_south_east() {
  // @@protoc_insertion_point(field_release:world_proto.GeoBox.south_east)
  
  ::world_proto::GeoPoint* temp = south_east_;
  south_east_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* GeoBox::_internal_mutable_south_east() {
  
  if (south_east_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    south_east_ = p;
  }
  return south_east_;
}
inline ::world_proto::GeoPoint* GeoBox::mutable_south_east() {
  // @@protoc_insertion_point(field_mutable:world_proto.GeoBox.south_east)
  return _internal_mutable_south_east();
}
inline void GeoBox::set_allocated_south_east(::world_proto::GeoPoint* south_east) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete south_east_;
  }
  if (south_east) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(south_east);
    if (message_arena != submessage_arena) {
      south_east = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, south_east, submessage_arena);
    }
    
  } else {
    
  }
  south_east_ = south_east;
  // @@protoc_insertion_point(field_set_allocated:world_proto.GeoBox.south_east)
}

// -------------------------------------------------------------------

// Vector3d

// double lat = 1;
inline void Vector3d::clear_lat() {
  lat_ = 0;
}
inline double Vector3d::_internal_lat() const {
  return lat_;
}
inline double Vector3d::lat() const {
  // @@protoc_insertion_point(field_get:world_proto.Vector3d.lat)
  return _internal_lat();
}
inline void Vector3d::_internal_set_lat(double value) {
  
  lat_ = value;
}
inline void Vector3d::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:world_proto.Vector3d.lat)
}

// double lon = 2;
inline void Vector3d::clear_lon() {
  lon_ = 0;
}
inline double Vector3d::_internal_lon() const {
  return lon_;
}
inline double Vector3d::lon() const {
  // @@protoc_insertion_point(field_get:world_proto.Vector3d.lon)
  return _internal_lon();
}
inline void Vector3d::_internal_set_lon(double value) {
  
  lon_ = value;
}
inline void Vector3d::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:world_proto.Vector3d.lon)
}

// double alt = 3;
inline void Vector3d::clear_alt() {
  alt_ = 0;
}
inline double Vector3d::_internal_alt() const {
  return alt_;
}
inline double Vector3d::alt() const {
  // @@protoc_insertion_point(field_get:world_proto.Vector3d.alt)
  return _internal_alt();
}
inline void Vector3d::_internal_set_alt(double value) {
  
  alt_ = value;
}
inline void Vector3d::set_alt(double value) {
  _internal_set_alt(value);
  // @@protoc_insertion_point(field_set:world_proto.Vector3d.alt)
}

// -------------------------------------------------------------------

// Attitude

// float heading = 1;
inline void Attitude::clear_heading() {
  heading_ = 0;
}
inline float Attitude::_internal_heading() const {
  return heading_;
}
inline float Attitude::heading() const {
  // @@protoc_insertion_point(field_get:world_proto.Attitude.heading)
  return _internal_heading();
}
inline void Attitude::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void Attitude::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:world_proto.Attitude.heading)
}

// float pitch = 2;
inline void Attitude::clear_pitch() {
  pitch_ = 0;
}
inline float Attitude::_internal_pitch() const {
  return pitch_;
}
inline float Attitude::pitch() const {
  // @@protoc_insertion_point(field_get:world_proto.Attitude.pitch)
  return _internal_pitch();
}
inline void Attitude::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void Attitude::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:world_proto.Attitude.pitch)
}

// float roll = 3;
inline void Attitude::clear_roll() {
  roll_ = 0;
}
inline float Attitude::_internal_roll() const {
  return roll_;
}
inline float Attitude::roll() const {
  // @@protoc_insertion_point(field_get:world_proto.Attitude.roll)
  return _internal_roll();
}
inline void Attitude::_internal_set_roll(float value) {
  
  roll_ = value;
}
inline void Attitude::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:world_proto.Attitude.roll)
}

// -------------------------------------------------------------------

// Aircraft_Situation

// .world_proto.Vector3d location = 1;
inline bool Aircraft_Situation::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool Aircraft_Situation::has_location() const {
  return _internal_has_location();
}
inline void Aircraft_Situation::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::world_proto::Vector3d& Aircraft_Situation::_internal_location() const {
  const ::world_proto::Vector3d* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Vector3d*>(
      &::world_proto::_Vector3d_default_instance_);
}
inline const ::world_proto::Vector3d& Aircraft_Situation::location() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.location)
  return _internal_location();
}
inline void Aircraft_Situation::unsafe_arena_set_allocated_location(
    ::world_proto::Vector3d* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Aircraft.Situation.location)
}
inline ::world_proto::Vector3d* Aircraft_Situation::release_location() {
  
  ::world_proto::Vector3d* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Vector3d* Aircraft_Situation::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.Situation.location)
  
  ::world_proto::Vector3d* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::world_proto::Vector3d* Aircraft_Situation::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Vector3d>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::world_proto::Vector3d* Aircraft_Situation::mutable_location() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.Situation.location)
  return _internal_mutable_location();
}
inline void Aircraft_Situation::set_allocated_location(::world_proto::Vector3d* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.Situation.location)
}

// .world_proto.Attitude attitude = 2;
inline bool Aircraft_Situation::_internal_has_attitude() const {
  return this != internal_default_instance() && attitude_ != nullptr;
}
inline bool Aircraft_Situation::has_attitude() const {
  return _internal_has_attitude();
}
inline void Aircraft_Situation::clear_attitude() {
  if (GetArena() == nullptr && attitude_ != nullptr) {
    delete attitude_;
  }
  attitude_ = nullptr;
}
inline const ::world_proto::Attitude& Aircraft_Situation::_internal_attitude() const {
  const ::world_proto::Attitude* p = attitude_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Attitude*>(
      &::world_proto::_Attitude_default_instance_);
}
inline const ::world_proto::Attitude& Aircraft_Situation::attitude() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.attitude)
  return _internal_attitude();
}
inline void Aircraft_Situation::unsafe_arena_set_allocated_attitude(
    ::world_proto::Attitude* attitude) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attitude_);
  }
  attitude_ = attitude;
  if (attitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Aircraft.Situation.attitude)
}
inline ::world_proto::Attitude* Aircraft_Situation::release_attitude() {
  
  ::world_proto::Attitude* temp = attitude_;
  attitude_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Attitude* Aircraft_Situation::unsafe_arena_release_attitude() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.Situation.attitude)
  
  ::world_proto::Attitude* temp = attitude_;
  attitude_ = nullptr;
  return temp;
}
inline ::world_proto::Attitude* Aircraft_Situation::_internal_mutable_attitude() {
  
  if (attitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Attitude>(GetArena());
    attitude_ = p;
  }
  return attitude_;
}
inline ::world_proto::Attitude* Aircraft_Situation::mutable_attitude() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.Situation.attitude)
  return _internal_mutable_attitude();
}
inline void Aircraft_Situation::set_allocated_attitude(::world_proto::Attitude* attitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete attitude_;
  }
  if (attitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(attitude);
    if (message_arena != submessage_arena) {
      attitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attitude, submessage_arena);
    }
    
  } else {
    
  }
  attitude_ = attitude;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.Situation.attitude)
}

// .world_proto.Vector3d velocity = 3;
inline bool Aircraft_Situation::_internal_has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline bool Aircraft_Situation::has_velocity() const {
  return _internal_has_velocity();
}
inline void Aircraft_Situation::clear_velocity() {
  if (GetArena() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
}
inline const ::world_proto::Vector3d& Aircraft_Situation::_internal_velocity() const {
  const ::world_proto::Vector3d* p = velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Vector3d*>(
      &::world_proto::_Vector3d_default_instance_);
}
inline const ::world_proto::Vector3d& Aircraft_Situation::velocity() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.velocity)
  return _internal_velocity();
}
inline void Aircraft_Situation::unsafe_arena_set_allocated_velocity(
    ::world_proto::Vector3d* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Aircraft.Situation.velocity)
}
inline ::world_proto::Vector3d* Aircraft_Situation::release_velocity() {
  
  ::world_proto::Vector3d* temp = velocity_;
  velocity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Vector3d* Aircraft_Situation::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.Situation.velocity)
  
  ::world_proto::Vector3d* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::world_proto::Vector3d* Aircraft_Situation::_internal_mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Vector3d>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::world_proto::Vector3d* Aircraft_Situation::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.Situation.velocity)
  return _internal_mutable_velocity();
}
inline void Aircraft_Situation::set_allocated_velocity(::world_proto::Vector3d* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.Situation.velocity)
}

// .world_proto.Vector3d acceleration = 4;
inline bool Aircraft_Situation::_internal_has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != nullptr;
}
inline bool Aircraft_Situation::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void Aircraft_Situation::clear_acceleration() {
  if (GetArena() == nullptr && acceleration_ != nullptr) {
    delete acceleration_;
  }
  acceleration_ = nullptr;
}
inline const ::world_proto::Vector3d& Aircraft_Situation::_internal_acceleration() const {
  const ::world_proto::Vector3d* p = acceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Vector3d*>(
      &::world_proto::_Vector3d_default_instance_);
}
inline const ::world_proto::Vector3d& Aircraft_Situation::acceleration() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.acceleration)
  return _internal_acceleration();
}
inline void Aircraft_Situation::unsafe_arena_set_allocated_acceleration(
    ::world_proto::Vector3d* acceleration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Aircraft.Situation.acceleration)
}
inline ::world_proto::Vector3d* Aircraft_Situation::release_acceleration() {
  
  ::world_proto::Vector3d* temp = acceleration_;
  acceleration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Vector3d* Aircraft_Situation::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.Situation.acceleration)
  
  ::world_proto::Vector3d* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::world_proto::Vector3d* Aircraft_Situation::_internal_mutable_acceleration() {
  
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Vector3d>(GetArena());
    acceleration_ = p;
  }
  return acceleration_;
}
inline ::world_proto::Vector3d* Aircraft_Situation::mutable_acceleration() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.Situation.acceleration)
  return _internal_mutable_acceleration();
}
inline void Aircraft_Situation::set_allocated_acceleration(::world_proto::Vector3d* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.Situation.acceleration)
}

// bool is_on_ground = 5;
inline void Aircraft_Situation::clear_is_on_ground() {
  is_on_ground_ = false;
}
inline bool Aircraft_Situation::_internal_is_on_ground() const {
  return is_on_ground_;
}
inline bool Aircraft_Situation::is_on_ground() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.is_on_ground)
  return _internal_is_on_ground();
}
inline void Aircraft_Situation::_internal_set_is_on_ground(bool value) {
  
  is_on_ground_ = value;
}
inline void Aircraft_Situation::set_is_on_ground(bool value) {
  _internal_set_is_on_ground(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.is_on_ground)
}

// float flap_ratio = 6;
inline void Aircraft_Situation::clear_flap_ratio() {
  flap_ratio_ = 0;
}
inline float Aircraft_Situation::_internal_flap_ratio() const {
  return flap_ratio_;
}
inline float Aircraft_Situation::flap_ratio() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.flap_ratio)
  return _internal_flap_ratio();
}
inline void Aircraft_Situation::_internal_set_flap_ratio(float value) {
  
  flap_ratio_ = value;
}
inline void Aircraft_Situation::set_flap_ratio(float value) {
  _internal_set_flap_ratio(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.flap_ratio)
}

// float spoiler_ratio = 7;
inline void Aircraft_Situation::clear_spoiler_ratio() {
  spoiler_ratio_ = 0;
}
inline float Aircraft_Situation::_internal_spoiler_ratio() const {
  return spoiler_ratio_;
}
inline float Aircraft_Situation::spoiler_ratio() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.spoiler_ratio)
  return _internal_spoiler_ratio();
}
inline void Aircraft_Situation::_internal_set_spoiler_ratio(float value) {
  
  spoiler_ratio_ = value;
}
inline void Aircraft_Situation::set_spoiler_ratio(float value) {
  _internal_set_spoiler_ratio(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.spoiler_ratio)
}

// float gear_ratio = 8;
inline void Aircraft_Situation::clear_gear_ratio() {
  gear_ratio_ = 0;
}
inline float Aircraft_Situation::_internal_gear_ratio() const {
  return gear_ratio_;
}
inline float Aircraft_Situation::gear_ratio() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.gear_ratio)
  return _internal_gear_ratio();
}
inline void Aircraft_Situation::_internal_set_gear_ratio(float value) {
  
  gear_ratio_ = value;
}
inline void Aircraft_Situation::set_gear_ratio(float value) {
  _internal_set_gear_ratio(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.gear_ratio)
}

// float nose_wheel_angle = 9;
inline void Aircraft_Situation::clear_nose_wheel_angle() {
  nose_wheel_angle_ = 0;
}
inline float Aircraft_Situation::_internal_nose_wheel_angle() const {
  return nose_wheel_angle_;
}
inline float Aircraft_Situation::nose_wheel_angle() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.nose_wheel_angle)
  return _internal_nose_wheel_angle();
}
inline void Aircraft_Situation::_internal_set_nose_wheel_angle(float value) {
  
  nose_wheel_angle_ = value;
}
inline void Aircraft_Situation::set_nose_wheel_angle(float value) {
  _internal_set_nose_wheel_angle(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.nose_wheel_angle)
}

// bool landing_lights = 10;
inline void Aircraft_Situation::clear_landing_lights() {
  landing_lights_ = false;
}
inline bool Aircraft_Situation::_internal_landing_lights() const {
  return landing_lights_;
}
inline bool Aircraft_Situation::landing_lights() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.landing_lights)
  return _internal_landing_lights();
}
inline void Aircraft_Situation::_internal_set_landing_lights(bool value) {
  
  landing_lights_ = value;
}
inline void Aircraft_Situation::set_landing_lights(bool value) {
  _internal_set_landing_lights(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.landing_lights)
}

// bool taxi_lights = 11;
inline void Aircraft_Situation::clear_taxi_lights() {
  taxi_lights_ = false;
}
inline bool Aircraft_Situation::_internal_taxi_lights() const {
  return taxi_lights_;
}
inline bool Aircraft_Situation::taxi_lights() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.taxi_lights)
  return _internal_taxi_lights();
}
inline void Aircraft_Situation::_internal_set_taxi_lights(bool value) {
  
  taxi_lights_ = value;
}
inline void Aircraft_Situation::set_taxi_lights(bool value) {
  _internal_set_taxi_lights(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.taxi_lights)
}

// bool strobe_lights = 12;
inline void Aircraft_Situation::clear_strobe_lights() {
  strobe_lights_ = false;
}
inline bool Aircraft_Situation::_internal_strobe_lights() const {
  return strobe_lights_;
}
inline bool Aircraft_Situation::strobe_lights() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.strobe_lights)
  return _internal_strobe_lights();
}
inline void Aircraft_Situation::_internal_set_strobe_lights(bool value) {
  
  strobe_lights_ = value;
}
inline void Aircraft_Situation::set_strobe_lights(bool value) {
  _internal_set_strobe_lights(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.strobe_lights)
}

// int32 frequency_khz = 13;
inline void Aircraft_Situation::clear_frequency_khz() {
  frequency_khz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Aircraft_Situation::_internal_frequency_khz() const {
  return frequency_khz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Aircraft_Situation::frequency_khz() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.frequency_khz)
  return _internal_frequency_khz();
}
inline void Aircraft_Situation::_internal_set_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  frequency_khz_ = value;
}
inline void Aircraft_Situation::set_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_frequency_khz(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.frequency_khz)
}

// string squawk = 14;
inline void Aircraft_Situation::clear_squawk() {
  squawk_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Aircraft_Situation::squawk() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.squawk)
  return _internal_squawk();
}
inline void Aircraft_Situation::set_squawk(const std::string& value) {
  _internal_set_squawk(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.squawk)
}
inline std::string* Aircraft_Situation::mutable_squawk() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.Situation.squawk)
  return _internal_mutable_squawk();
}
inline const std::string& Aircraft_Situation::_internal_squawk() const {
  return squawk_.Get();
}
inline void Aircraft_Situation::_internal_set_squawk(const std::string& value) {
  
  squawk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Aircraft_Situation::set_squawk(std::string&& value) {
  
  squawk_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Aircraft.Situation.squawk)
}
inline void Aircraft_Situation::set_squawk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  squawk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Aircraft.Situation.squawk)
}
inline void Aircraft_Situation::set_squawk(const char* value,
    size_t size) {
  
  squawk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Aircraft.Situation.squawk)
}
inline std::string* Aircraft_Situation::_internal_mutable_squawk() {
  
  return squawk_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Aircraft_Situation::release_squawk() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.Situation.squawk)
  return squawk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Aircraft_Situation::set_allocated_squawk(std::string* squawk) {
  if (squawk != nullptr) {
    
  } else {
    
  }
  squawk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), squawk,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.Situation.squawk)
}

// bool mode_c = 15;
inline void Aircraft_Situation::clear_mode_c() {
  mode_c_ = false;
}
inline bool Aircraft_Situation::_internal_mode_c() const {
  return mode_c_;
}
inline bool Aircraft_Situation::mode_c() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.mode_c)
  return _internal_mode_c();
}
inline void Aircraft_Situation::_internal_set_mode_c(bool value) {
  
  mode_c_ = value;
}
inline void Aircraft_Situation::set_mode_c(bool value) {
  _internal_set_mode_c(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.mode_c)
}

// bool mode_s = 16;
inline void Aircraft_Situation::clear_mode_s() {
  mode_s_ = false;
}
inline bool Aircraft_Situation::_internal_mode_s() const {
  return mode_s_;
}
inline bool Aircraft_Situation::mode_s() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.Situation.mode_s)
  return _internal_mode_s();
}
inline void Aircraft_Situation::_internal_set_mode_s(bool value) {
  
  mode_s_ = value;
}
inline void Aircraft_Situation::set_mode_s(bool value) {
  _internal_set_mode_s(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.Situation.mode_s)
}

// -------------------------------------------------------------------

// Aircraft

// int32 id = 1;
inline void Aircraft::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Aircraft::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Aircraft::id() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.id)
  return _internal_id();
}
inline void Aircraft::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void Aircraft::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.id)
}

// string model_icao = 2;
inline void Aircraft::clear_model_icao() {
  model_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Aircraft::model_icao() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.model_icao)
  return _internal_model_icao();
}
inline void Aircraft::set_model_icao(const std::string& value) {
  _internal_set_model_icao(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.model_icao)
}
inline std::string* Aircraft::mutable_model_icao() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.model_icao)
  return _internal_mutable_model_icao();
}
inline const std::string& Aircraft::_internal_model_icao() const {
  return model_icao_.Get();
}
inline void Aircraft::_internal_set_model_icao(const std::string& value) {
  
  model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Aircraft::set_model_icao(std::string&& value) {
  
  model_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Aircraft.model_icao)
}
inline void Aircraft::set_model_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Aircraft.model_icao)
}
inline void Aircraft::set_model_icao(const char* value,
    size_t size) {
  
  model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Aircraft.model_icao)
}
inline std::string* Aircraft::_internal_mutable_model_icao() {
  
  return model_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Aircraft::release_model_icao() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.model_icao)
  return model_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Aircraft::set_allocated_model_icao(std::string* model_icao) {
  if (model_icao != nullptr) {
    
  } else {
    
  }
  model_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.model_icao)
}

// string airline_icao = 3;
inline void Aircraft::clear_airline_icao() {
  airline_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Aircraft::airline_icao() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.airline_icao)
  return _internal_airline_icao();
}
inline void Aircraft::set_airline_icao(const std::string& value) {
  _internal_set_airline_icao(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.airline_icao)
}
inline std::string* Aircraft::mutable_airline_icao() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.airline_icao)
  return _internal_mutable_airline_icao();
}
inline const std::string& Aircraft::_internal_airline_icao() const {
  return airline_icao_.Get();
}
inline void Aircraft::_internal_set_airline_icao(const std::string& value) {
  
  airline_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Aircraft::set_airline_icao(std::string&& value) {
  
  airline_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Aircraft.airline_icao)
}
inline void Aircraft::set_airline_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  airline_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Aircraft.airline_icao)
}
inline void Aircraft::set_airline_icao(const char* value,
    size_t size) {
  
  airline_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Aircraft.airline_icao)
}
inline std::string* Aircraft::_internal_mutable_airline_icao() {
  
  return airline_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Aircraft::release_airline_icao() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.airline_icao)
  return airline_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Aircraft::set_allocated_airline_icao(std::string* airline_icao) {
  if (airline_icao != nullptr) {
    
  } else {
    
  }
  airline_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), airline_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.airline_icao)
}

// string tail_no = 4;
inline void Aircraft::clear_tail_no() {
  tail_no_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Aircraft::tail_no() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.tail_no)
  return _internal_tail_no();
}
inline void Aircraft::set_tail_no(const std::string& value) {
  _internal_set_tail_no(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.tail_no)
}
inline std::string* Aircraft::mutable_tail_no() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.tail_no)
  return _internal_mutable_tail_no();
}
inline const std::string& Aircraft::_internal_tail_no() const {
  return tail_no_.Get();
}
inline void Aircraft::_internal_set_tail_no(const std::string& value) {
  
  tail_no_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Aircraft::set_tail_no(std::string&& value) {
  
  tail_no_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Aircraft.tail_no)
}
inline void Aircraft::set_tail_no(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tail_no_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Aircraft.tail_no)
}
inline void Aircraft::set_tail_no(const char* value,
    size_t size) {
  
  tail_no_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Aircraft.tail_no)
}
inline std::string* Aircraft::_internal_mutable_tail_no() {
  
  return tail_no_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Aircraft::release_tail_no() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.tail_no)
  return tail_no_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Aircraft::set_allocated_tail_no(std::string* tail_no) {
  if (tail_no != nullptr) {
    
  } else {
    
  }
  tail_no_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tail_no,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.tail_no)
}

// string call_sign = 5;
inline void Aircraft::clear_call_sign() {
  call_sign_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Aircraft::call_sign() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.call_sign)
  return _internal_call_sign();
}
inline void Aircraft::set_call_sign(const std::string& value) {
  _internal_set_call_sign(value);
  // @@protoc_insertion_point(field_set:world_proto.Aircraft.call_sign)
}
inline std::string* Aircraft::mutable_call_sign() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.call_sign)
  return _internal_mutable_call_sign();
}
inline const std::string& Aircraft::_internal_call_sign() const {
  return call_sign_.Get();
}
inline void Aircraft::_internal_set_call_sign(const std::string& value) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Aircraft::set_call_sign(std::string&& value) {
  
  call_sign_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Aircraft.call_sign)
}
inline void Aircraft::set_call_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Aircraft.call_sign)
}
inline void Aircraft::set_call_sign(const char* value,
    size_t size) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Aircraft.call_sign)
}
inline std::string* Aircraft::_internal_mutable_call_sign() {
  
  return call_sign_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Aircraft::release_call_sign() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.call_sign)
  return call_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Aircraft::set_allocated_call_sign(std::string* call_sign) {
  if (call_sign != nullptr) {
    
  } else {
    
  }
  call_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), call_sign,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.call_sign)
}

// .world_proto.Aircraft.Situation situation = 6;
inline bool Aircraft::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool Aircraft::has_situation() const {
  return _internal_has_situation();
}
inline void Aircraft::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::world_proto::Aircraft_Situation& Aircraft::_internal_situation() const {
  const ::world_proto::Aircraft_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Aircraft_Situation*>(
      &::world_proto::_Aircraft_Situation_default_instance_);
}
inline const ::world_proto::Aircraft_Situation& Aircraft::situation() const {
  // @@protoc_insertion_point(field_get:world_proto.Aircraft.situation)
  return _internal_situation();
}
inline void Aircraft::unsafe_arena_set_allocated_situation(
    ::world_proto::Aircraft_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Aircraft.situation)
}
inline ::world_proto::Aircraft_Situation* Aircraft::release_situation() {
  
  ::world_proto::Aircraft_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Aircraft_Situation* Aircraft::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:world_proto.Aircraft.situation)
  
  ::world_proto::Aircraft_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::world_proto::Aircraft_Situation* Aircraft::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Aircraft_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::world_proto::Aircraft_Situation* Aircraft::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:world_proto.Aircraft.situation)
  return _internal_mutable_situation();
}
inline void Aircraft::set_allocated_situation(::world_proto::Aircraft_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Aircraft.situation)
}

// -------------------------------------------------------------------

// Runway_End

// string name = 1;
inline void Runway_End::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Runway_End::name() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.End.name)
  return _internal_name();
}
inline void Runway_End::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.End.name)
}
inline std::string* Runway_End::mutable_name() {
  // @@protoc_insertion_point(field_mutable:world_proto.Runway.End.name)
  return _internal_mutable_name();
}
inline const std::string& Runway_End::_internal_name() const {
  return name_.Get();
}
inline void Runway_End::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Runway_End::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Runway.End.name)
}
inline void Runway_End::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Runway.End.name)
}
inline void Runway_End::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Runway.End.name)
}
inline std::string* Runway_End::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Runway_End::release_name() {
  // @@protoc_insertion_point(field_release:world_proto.Runway.End.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Runway_End::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Runway.End.name)
}

// float heading = 2;
inline void Runway_End::clear_heading() {
  heading_ = 0;
}
inline float Runway_End::_internal_heading() const {
  return heading_;
}
inline float Runway_End::heading() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.End.heading)
  return _internal_heading();
}
inline void Runway_End::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void Runway_End::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.End.heading)
}

// .world_proto.GeoPoint centerline_point = 3;
inline bool Runway_End::_internal_has_centerline_point() const {
  return this != internal_default_instance() && centerline_point_ != nullptr;
}
inline bool Runway_End::has_centerline_point() const {
  return _internal_has_centerline_point();
}
inline void Runway_End::clear_centerline_point() {
  if (GetArena() == nullptr && centerline_point_ != nullptr) {
    delete centerline_point_;
  }
  centerline_point_ = nullptr;
}
inline const ::world_proto::GeoPoint& Runway_End::_internal_centerline_point() const {
  const ::world_proto::GeoPoint* p = centerline_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& Runway_End::centerline_point() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.End.centerline_point)
  return _internal_centerline_point();
}
inline void Runway_End::unsafe_arena_set_allocated_centerline_point(
    ::world_proto::GeoPoint* centerline_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centerline_point_);
  }
  centerline_point_ = centerline_point;
  if (centerline_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Runway.End.centerline_point)
}
inline ::world_proto::GeoPoint* Runway_End::release_centerline_point() {
  
  ::world_proto::GeoPoint* temp = centerline_point_;
  centerline_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* Runway_End::unsafe_arena_release_centerline_point() {
  // @@protoc_insertion_point(field_release:world_proto.Runway.End.centerline_point)
  
  ::world_proto::GeoPoint* temp = centerline_point_;
  centerline_point_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* Runway_End::_internal_mutable_centerline_point() {
  
  if (centerline_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    centerline_point_ = p;
  }
  return centerline_point_;
}
inline ::world_proto::GeoPoint* Runway_End::mutable_centerline_point() {
  // @@protoc_insertion_point(field_mutable:world_proto.Runway.End.centerline_point)
  return _internal_mutable_centerline_point();
}
inline void Runway_End::set_allocated_centerline_point(::world_proto::GeoPoint* centerline_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete centerline_point_;
  }
  if (centerline_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(centerline_point);
    if (message_arena != submessage_arena) {
      centerline_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centerline_point, submessage_arena);
    }
    
  } else {
    
  }
  centerline_point_ = centerline_point;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Runway.End.centerline_point)
}

// float displaced_threshold_meters = 4;
inline void Runway_End::clear_displaced_threshold_meters() {
  displaced_threshold_meters_ = 0;
}
inline float Runway_End::_internal_displaced_threshold_meters() const {
  return displaced_threshold_meters_;
}
inline float Runway_End::displaced_threshold_meters() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.End.displaced_threshold_meters)
  return _internal_displaced_threshold_meters();
}
inline void Runway_End::_internal_set_displaced_threshold_meters(float value) {
  
  displaced_threshold_meters_ = value;
}
inline void Runway_End::set_displaced_threshold_meters(float value) {
  _internal_set_displaced_threshold_meters(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.End.displaced_threshold_meters)
}

// float overrun_area_meters = 5;
inline void Runway_End::clear_overrun_area_meters() {
  overrun_area_meters_ = 0;
}
inline float Runway_End::_internal_overrun_area_meters() const {
  return overrun_area_meters_;
}
inline float Runway_End::overrun_area_meters() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.End.overrun_area_meters)
  return _internal_overrun_area_meters();
}
inline void Runway_End::_internal_set_overrun_area_meters(float value) {
  
  overrun_area_meters_ = value;
}
inline void Runway_End::set_overrun_area_meters(float value) {
  _internal_set_overrun_area_meters(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.End.overrun_area_meters)
}

// -------------------------------------------------------------------

// Runway

// float width_meters = 1;
inline void Runway::clear_width_meters() {
  width_meters_ = 0;
}
inline float Runway::_internal_width_meters() const {
  return width_meters_;
}
inline float Runway::width_meters() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.width_meters)
  return _internal_width_meters();
}
inline void Runway::_internal_set_width_meters(float value) {
  
  width_meters_ = value;
}
inline void Runway::set_width_meters(float value) {
  _internal_set_width_meters(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.width_meters)
}

// float length_meters = 2;
inline void Runway::clear_length_meters() {
  length_meters_ = 0;
}
inline float Runway::_internal_length_meters() const {
  return length_meters_;
}
inline float Runway::length_meters() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.length_meters)
  return _internal_length_meters();
}
inline void Runway::_internal_set_length_meters(float value) {
  
  length_meters_ = value;
}
inline void Runway::set_length_meters(float value) {
  _internal_set_length_meters(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.length_meters)
}

// uint32 mask_bit = 3;
inline void Runway::clear_mask_bit() {
  mask_bit_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Runway::_internal_mask_bit() const {
  return mask_bit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Runway::mask_bit() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.mask_bit)
  return _internal_mask_bit();
}
inline void Runway::_internal_set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  mask_bit_ = value;
}
inline void Runway::set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mask_bit(value);
  // @@protoc_insertion_point(field_set:world_proto.Runway.mask_bit)
}

// .world_proto.Runway.End end_1 = 4;
inline bool Runway::_internal_has_end_1() const {
  return this != internal_default_instance() && end_1_ != nullptr;
}
inline bool Runway::has_end_1() const {
  return _internal_has_end_1();
}
inline void Runway::clear_end_1() {
  if (GetArena() == nullptr && end_1_ != nullptr) {
    delete end_1_;
  }
  end_1_ = nullptr;
}
inline const ::world_proto::Runway_End& Runway::_internal_end_1() const {
  const ::world_proto::Runway_End* p = end_1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Runway_End*>(
      &::world_proto::_Runway_End_default_instance_);
}
inline const ::world_proto::Runway_End& Runway::end_1() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.end_1)
  return _internal_end_1();
}
inline void Runway::unsafe_arena_set_allocated_end_1(
    ::world_proto::Runway_End* end_1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_1_);
  }
  end_1_ = end_1;
  if (end_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Runway.end_1)
}
inline ::world_proto::Runway_End* Runway::release_end_1() {
  
  ::world_proto::Runway_End* temp = end_1_;
  end_1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Runway_End* Runway::unsafe_arena_release_end_1() {
  // @@protoc_insertion_point(field_release:world_proto.Runway.end_1)
  
  ::world_proto::Runway_End* temp = end_1_;
  end_1_ = nullptr;
  return temp;
}
inline ::world_proto::Runway_End* Runway::_internal_mutable_end_1() {
  
  if (end_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Runway_End>(GetArena());
    end_1_ = p;
  }
  return end_1_;
}
inline ::world_proto::Runway_End* Runway::mutable_end_1() {
  // @@protoc_insertion_point(field_mutable:world_proto.Runway.end_1)
  return _internal_mutable_end_1();
}
inline void Runway::set_allocated_end_1(::world_proto::Runway_End* end_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete end_1_;
  }
  if (end_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(end_1);
    if (message_arena != submessage_arena) {
      end_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_1, submessage_arena);
    }
    
  } else {
    
  }
  end_1_ = end_1;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Runway.end_1)
}

// .world_proto.Runway.End end_2 = 5;
inline bool Runway::_internal_has_end_2() const {
  return this != internal_default_instance() && end_2_ != nullptr;
}
inline bool Runway::has_end_2() const {
  return _internal_has_end_2();
}
inline void Runway::clear_end_2() {
  if (GetArena() == nullptr && end_2_ != nullptr) {
    delete end_2_;
  }
  end_2_ = nullptr;
}
inline const ::world_proto::Runway_End& Runway::_internal_end_2() const {
  const ::world_proto::Runway_End* p = end_2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Runway_End*>(
      &::world_proto::_Runway_End_default_instance_);
}
inline const ::world_proto::Runway_End& Runway::end_2() const {
  // @@protoc_insertion_point(field_get:world_proto.Runway.end_2)
  return _internal_end_2();
}
inline void Runway::unsafe_arena_set_allocated_end_2(
    ::world_proto::Runway_End* end_2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_2_);
  }
  end_2_ = end_2;
  if (end_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Runway.end_2)
}
inline ::world_proto::Runway_End* Runway::release_end_2() {
  
  ::world_proto::Runway_End* temp = end_2_;
  end_2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Runway_End* Runway::unsafe_arena_release_end_2() {
  // @@protoc_insertion_point(field_release:world_proto.Runway.end_2)
  
  ::world_proto::Runway_End* temp = end_2_;
  end_2_ = nullptr;
  return temp;
}
inline ::world_proto::Runway_End* Runway::_internal_mutable_end_2() {
  
  if (end_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Runway_End>(GetArena());
    end_2_ = p;
  }
  return end_2_;
}
inline ::world_proto::Runway_End* Runway::mutable_end_2() {
  // @@protoc_insertion_point(field_mutable:world_proto.Runway.end_2)
  return _internal_mutable_end_2();
}
inline void Runway::set_allocated_end_2(::world_proto::Runway_End* end_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete end_2_;
  }
  if (end_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(end_2);
    if (message_arena != submessage_arena) {
      end_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_2, submessage_arena);
    }
    
  } else {
    
  }
  end_2_ = end_2;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Runway.end_2)
}

// -------------------------------------------------------------------

// TaxiNode

// int32 id = 1;
inline void TaxiNode::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiNode::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiNode::id() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiNode.id)
  return _internal_id();
}
inline void TaxiNode::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void TaxiNode::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiNode.id)
}

// .world_proto.GeoPoint location = 2;
inline bool TaxiNode::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool TaxiNode::has_location() const {
  return _internal_has_location();
}
inline void TaxiNode::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::world_proto::GeoPoint& TaxiNode::_internal_location() const {
  const ::world_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& TaxiNode::location() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiNode.location)
  return _internal_location();
}
inline void TaxiNode::unsafe_arena_set_allocated_location(
    ::world_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.TaxiNode.location)
}
inline ::world_proto::GeoPoint* TaxiNode::release_location() {
  
  ::world_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* TaxiNode::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:world_proto.TaxiNode.location)
  
  ::world_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* TaxiNode::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::world_proto::GeoPoint* TaxiNode::mutable_location() {
  // @@protoc_insertion_point(field_mutable:world_proto.TaxiNode.location)
  return _internal_mutable_location();
}
inline void TaxiNode::set_allocated_location(::world_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:world_proto.TaxiNode.location)
}

// bool is_junction = 3;
inline void TaxiNode::clear_is_junction() {
  is_junction_ = false;
}
inline bool TaxiNode::_internal_is_junction() const {
  return is_junction_;
}
inline bool TaxiNode::is_junction() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiNode.is_junction)
  return _internal_is_junction();
}
inline void TaxiNode::_internal_set_is_junction(bool value) {
  
  is_junction_ = value;
}
inline void TaxiNode::set_is_junction(bool value) {
  _internal_set_is_junction(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiNode.is_junction)
}

// -------------------------------------------------------------------

// TaxiEdge_ActiveZoneMatrix

// uint32 departure = 1;
inline void TaxiEdge_ActiveZoneMatrix::clear_departure() {
  departure_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaxiEdge_ActiveZoneMatrix::_internal_departure() const {
  return departure_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaxiEdge_ActiveZoneMatrix::departure() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.ActiveZoneMatrix.departure)
  return _internal_departure();
}
inline void TaxiEdge_ActiveZoneMatrix::_internal_set_departure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  departure_ = value;
}
inline void TaxiEdge_ActiveZoneMatrix::set_departure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_departure(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.ActiveZoneMatrix.departure)
}

// uint32 arrival = 2;
inline void TaxiEdge_ActiveZoneMatrix::clear_arrival() {
  arrival_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaxiEdge_ActiveZoneMatrix::_internal_arrival() const {
  return arrival_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaxiEdge_ActiveZoneMatrix::arrival() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.ActiveZoneMatrix.arrival)
  return _internal_arrival();
}
inline void TaxiEdge_ActiveZoneMatrix::_internal_set_arrival(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  arrival_ = value;
}
inline void TaxiEdge_ActiveZoneMatrix::set_arrival(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_arrival(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.ActiveZoneMatrix.arrival)
}

// uint32 ils = 3;
inline void TaxiEdge_ActiveZoneMatrix::clear_ils() {
  ils_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaxiEdge_ActiveZoneMatrix::_internal_ils() const {
  return ils_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaxiEdge_ActiveZoneMatrix::ils() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.ActiveZoneMatrix.ils)
  return _internal_ils();
}
inline void TaxiEdge_ActiveZoneMatrix::_internal_set_ils(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ils_ = value;
}
inline void TaxiEdge_ActiveZoneMatrix::set_ils(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ils(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.ActiveZoneMatrix.ils)
}

// -------------------------------------------------------------------

// TaxiEdge

// int32 id = 1;
inline void TaxiEdge::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdge::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdge::id() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.id)
  return _internal_id();
}
inline void TaxiEdge::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void TaxiEdge::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.id)
}

// string name = 2;
inline void TaxiEdge::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TaxiEdge::name() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.name)
  return _internal_name();
}
inline void TaxiEdge::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.name)
}
inline std::string* TaxiEdge::mutable_name() {
  // @@protoc_insertion_point(field_mutable:world_proto.TaxiEdge.name)
  return _internal_mutable_name();
}
inline const std::string& TaxiEdge::_internal_name() const {
  return name_.Get();
}
inline void TaxiEdge::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TaxiEdge::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.TaxiEdge.name)
}
inline void TaxiEdge::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.TaxiEdge.name)
}
inline void TaxiEdge::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.TaxiEdge.name)
}
inline std::string* TaxiEdge::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TaxiEdge::release_name() {
  // @@protoc_insertion_point(field_release:world_proto.TaxiEdge.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TaxiEdge::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.TaxiEdge.name)
}

// int32 node_id_1 = 3;
inline void TaxiEdge::clear_node_id_1() {
  node_id_1_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdge::_internal_node_id_1() const {
  return node_id_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdge::node_id_1() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.node_id_1)
  return _internal_node_id_1();
}
inline void TaxiEdge::_internal_set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_id_1_ = value;
}
inline void TaxiEdge::set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id_1(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.node_id_1)
}

// int32 node_id_2 = 4;
inline void TaxiEdge::clear_node_id_2() {
  node_id_2_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdge::_internal_node_id_2() const {
  return node_id_2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdge::node_id_2() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.node_id_2)
  return _internal_node_id_2();
}
inline void TaxiEdge::_internal_set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_id_2_ = value;
}
inline void TaxiEdge::set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id_2(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.node_id_2)
}

// .world_proto.TaxiEdge.Type type = 5;
inline void TaxiEdge::clear_type() {
  type_ = 0;
}
inline ::world_proto::TaxiEdge_Type TaxiEdge::_internal_type() const {
  return static_cast< ::world_proto::TaxiEdge_Type >(type_);
}
inline ::world_proto::TaxiEdge_Type TaxiEdge::type() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.type)
  return _internal_type();
}
inline void TaxiEdge::_internal_set_type(::world_proto::TaxiEdge_Type value) {
  
  type_ = value;
}
inline void TaxiEdge::set_type(::world_proto::TaxiEdge_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.type)
}

// bool is_one_way = 6;
inline void TaxiEdge::clear_is_one_way() {
  is_one_way_ = false;
}
inline bool TaxiEdge::_internal_is_one_way() const {
  return is_one_way_;
}
inline bool TaxiEdge::is_one_way() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.is_one_way)
  return _internal_is_one_way();
}
inline void TaxiEdge::_internal_set_is_one_way(bool value) {
  
  is_one_way_ = value;
}
inline void TaxiEdge::set_is_one_way(bool value) {
  _internal_set_is_one_way(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.is_one_way)
}

// bool is_high_speed_exit = 7;
inline void TaxiEdge::clear_is_high_speed_exit() {
  is_high_speed_exit_ = false;
}
inline bool TaxiEdge::_internal_is_high_speed_exit() const {
  return is_high_speed_exit_;
}
inline bool TaxiEdge::is_high_speed_exit() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.is_high_speed_exit)
  return _internal_is_high_speed_exit();
}
inline void TaxiEdge::_internal_set_is_high_speed_exit(bool value) {
  
  is_high_speed_exit_ = value;
}
inline void TaxiEdge::set_is_high_speed_exit(bool value) {
  _internal_set_is_high_speed_exit(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.is_high_speed_exit)
}

// float length_meters = 8;
inline void TaxiEdge::clear_length_meters() {
  length_meters_ = 0;
}
inline float TaxiEdge::_internal_length_meters() const {
  return length_meters_;
}
inline float TaxiEdge::length_meters() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.length_meters)
  return _internal_length_meters();
}
inline void TaxiEdge::_internal_set_length_meters(float value) {
  
  length_meters_ = value;
}
inline void TaxiEdge::set_length_meters(float value) {
  _internal_set_length_meters(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.length_meters)
}

// float heading = 9;
inline void TaxiEdge::clear_heading() {
  heading_ = 0;
}
inline float TaxiEdge::_internal_heading() const {
  return heading_;
}
inline float TaxiEdge::heading() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.heading)
  return _internal_heading();
}
inline void TaxiEdge::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void TaxiEdge::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiEdge.heading)
}

// .world_proto.TaxiEdge.ActiveZoneMatrix active_zones = 10;
inline bool TaxiEdge::_internal_has_active_zones() const {
  return this != internal_default_instance() && active_zones_ != nullptr;
}
inline bool TaxiEdge::has_active_zones() const {
  return _internal_has_active_zones();
}
inline void TaxiEdge::clear_active_zones() {
  if (GetArena() == nullptr && active_zones_ != nullptr) {
    delete active_zones_;
  }
  active_zones_ = nullptr;
}
inline const ::world_proto::TaxiEdge_ActiveZoneMatrix& TaxiEdge::_internal_active_zones() const {
  const ::world_proto::TaxiEdge_ActiveZoneMatrix* p = active_zones_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::TaxiEdge_ActiveZoneMatrix*>(
      &::world_proto::_TaxiEdge_ActiveZoneMatrix_default_instance_);
}
inline const ::world_proto::TaxiEdge_ActiveZoneMatrix& TaxiEdge::active_zones() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiEdge.active_zones)
  return _internal_active_zones();
}
inline void TaxiEdge::unsafe_arena_set_allocated_active_zones(
    ::world_proto::TaxiEdge_ActiveZoneMatrix* active_zones) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_zones_);
  }
  active_zones_ = active_zones;
  if (active_zones) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.TaxiEdge.active_zones)
}
inline ::world_proto::TaxiEdge_ActiveZoneMatrix* TaxiEdge::release_active_zones() {
  
  ::world_proto::TaxiEdge_ActiveZoneMatrix* temp = active_zones_;
  active_zones_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::TaxiEdge_ActiveZoneMatrix* TaxiEdge::unsafe_arena_release_active_zones() {
  // @@protoc_insertion_point(field_release:world_proto.TaxiEdge.active_zones)
  
  ::world_proto::TaxiEdge_ActiveZoneMatrix* temp = active_zones_;
  active_zones_ = nullptr;
  return temp;
}
inline ::world_proto::TaxiEdge_ActiveZoneMatrix* TaxiEdge::_internal_mutable_active_zones() {
  
  if (active_zones_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::TaxiEdge_ActiveZoneMatrix>(GetArena());
    active_zones_ = p;
  }
  return active_zones_;
}
inline ::world_proto::TaxiEdge_ActiveZoneMatrix* TaxiEdge::mutable_active_zones() {
  // @@protoc_insertion_point(field_mutable:world_proto.TaxiEdge.active_zones)
  return _internal_mutable_active_zones();
}
inline void TaxiEdge::set_allocated_active_zones(::world_proto::TaxiEdge_ActiveZoneMatrix* active_zones) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete active_zones_;
  }
  if (active_zones) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(active_zones);
    if (message_arena != submessage_arena) {
      active_zones = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_zones, submessage_arena);
    }
    
  } else {
    
  }
  active_zones_ = active_zones;
  // @@protoc_insertion_point(field_set_allocated:world_proto.TaxiEdge.active_zones)
}

// -------------------------------------------------------------------

// ParkingStand

// int32 id = 1;
inline void ParkingStand::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ParkingStand::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ParkingStand::id() const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.id)
  return _internal_id();
}
inline void ParkingStand::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void ParkingStand::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.id)
}

// string name = 2;
inline void ParkingStand::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ParkingStand::name() const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.name)
  return _internal_name();
}
inline void ParkingStand::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.name)
}
inline std::string* ParkingStand::mutable_name() {
  // @@protoc_insertion_point(field_mutable:world_proto.ParkingStand.name)
  return _internal_mutable_name();
}
inline const std::string& ParkingStand::_internal_name() const {
  return name_.Get();
}
inline void ParkingStand::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ParkingStand::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ParkingStand.name)
}
inline void ParkingStand::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ParkingStand.name)
}
inline void ParkingStand::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ParkingStand.name)
}
inline std::string* ParkingStand::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ParkingStand::release_name() {
  // @@protoc_insertion_point(field_release:world_proto.ParkingStand.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ParkingStand::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ParkingStand.name)
}

// .world_proto.ParkingStand.Type type = 3;
inline void ParkingStand::clear_type() {
  type_ = 0;
}
inline ::world_proto::ParkingStand_Type ParkingStand::_internal_type() const {
  return static_cast< ::world_proto::ParkingStand_Type >(type_);
}
inline ::world_proto::ParkingStand_Type ParkingStand::type() const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.type)
  return _internal_type();
}
inline void ParkingStand::_internal_set_type(::world_proto::ParkingStand_Type value) {
  
  type_ = value;
}
inline void ParkingStand::set_type(::world_proto::ParkingStand_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.type)
}

// .world_proto.GeoPoint location = 4;
inline bool ParkingStand::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool ParkingStand::has_location() const {
  return _internal_has_location();
}
inline void ParkingStand::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::world_proto::GeoPoint& ParkingStand::_internal_location() const {
  const ::world_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& ParkingStand::location() const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.location)
  return _internal_location();
}
inline void ParkingStand::unsafe_arena_set_allocated_location(
    ::world_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ParkingStand.location)
}
inline ::world_proto::GeoPoint* ParkingStand::release_location() {
  
  ::world_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* ParkingStand::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:world_proto.ParkingStand.location)
  
  ::world_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* ParkingStand::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::world_proto::GeoPoint* ParkingStand::mutable_location() {
  // @@protoc_insertion_point(field_mutable:world_proto.ParkingStand.location)
  return _internal_mutable_location();
}
inline void ParkingStand::set_allocated_location(::world_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ParkingStand.location)
}

// float heading = 5;
inline void ParkingStand::clear_heading() {
  heading_ = 0;
}
inline float ParkingStand::_internal_heading() const {
  return heading_;
}
inline float ParkingStand::heading() const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.heading)
  return _internal_heading();
}
inline void ParkingStand::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void ParkingStand::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.heading)
}

// string width_code = 6;
inline void ParkingStand::clear_width_code() {
  width_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ParkingStand::width_code() const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.width_code)
  return _internal_width_code();
}
inline void ParkingStand::set_width_code(const std::string& value) {
  _internal_set_width_code(value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.width_code)
}
inline std::string* ParkingStand::mutable_width_code() {
  // @@protoc_insertion_point(field_mutable:world_proto.ParkingStand.width_code)
  return _internal_mutable_width_code();
}
inline const std::string& ParkingStand::_internal_width_code() const {
  return width_code_.Get();
}
inline void ParkingStand::_internal_set_width_code(const std::string& value) {
  
  width_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ParkingStand::set_width_code(std::string&& value) {
  
  width_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ParkingStand.width_code)
}
inline void ParkingStand::set_width_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  width_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ParkingStand.width_code)
}
inline void ParkingStand::set_width_code(const char* value,
    size_t size) {
  
  width_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ParkingStand.width_code)
}
inline std::string* ParkingStand::_internal_mutable_width_code() {
  
  return width_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ParkingStand::release_width_code() {
  // @@protoc_insertion_point(field_release:world_proto.ParkingStand.width_code)
  return width_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ParkingStand::set_allocated_width_code(std::string* width_code) {
  if (width_code != nullptr) {
    
  } else {
    
  }
  width_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), width_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ParkingStand.width_code)
}

// repeated .world_proto.Aircraft.Category categories = 7;
inline int ParkingStand::_internal_categories_size() const {
  return categories_.size();
}
inline int ParkingStand::categories_size() const {
  return _internal_categories_size();
}
inline void ParkingStand::clear_categories() {
  categories_.Clear();
}
inline ::world_proto::Aircraft_Category ParkingStand::_internal_categories(int index) const {
  return static_cast< ::world_proto::Aircraft_Category >(categories_.Get(index));
}
inline ::world_proto::Aircraft_Category ParkingStand::categories(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.categories)
  return _internal_categories(index);
}
inline void ParkingStand::set_categories(int index, ::world_proto::Aircraft_Category value) {
  categories_.Set(index, value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.categories)
}
inline void ParkingStand::_internal_add_categories(::world_proto::Aircraft_Category value) {
  categories_.Add(value);
}
inline void ParkingStand::add_categories(::world_proto::Aircraft_Category value) {
  // @@protoc_insertion_point(field_add:world_proto.ParkingStand.categories)
  _internal_add_categories(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ParkingStand::categories() const {
  // @@protoc_insertion_point(field_list:world_proto.ParkingStand.categories)
  return categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStand::_internal_mutable_categories() {
  return &categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStand::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.ParkingStand.categories)
  return _internal_mutable_categories();
}

// repeated .world_proto.Aircraft.OperationType operation_types = 8;
inline int ParkingStand::_internal_operation_types_size() const {
  return operation_types_.size();
}
inline int ParkingStand::operation_types_size() const {
  return _internal_operation_types_size();
}
inline void ParkingStand::clear_operation_types() {
  operation_types_.Clear();
}
inline ::world_proto::Aircraft_OperationType ParkingStand::_internal_operation_types(int index) const {
  return static_cast< ::world_proto::Aircraft_OperationType >(operation_types_.Get(index));
}
inline ::world_proto::Aircraft_OperationType ParkingStand::operation_types(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.operation_types)
  return _internal_operation_types(index);
}
inline void ParkingStand::set_operation_types(int index, ::world_proto::Aircraft_OperationType value) {
  operation_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.operation_types)
}
inline void ParkingStand::_internal_add_operation_types(::world_proto::Aircraft_OperationType value) {
  operation_types_.Add(value);
}
inline void ParkingStand::add_operation_types(::world_proto::Aircraft_OperationType value) {
  // @@protoc_insertion_point(field_add:world_proto.ParkingStand.operation_types)
  _internal_add_operation_types(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ParkingStand::operation_types() const {
  // @@protoc_insertion_point(field_list:world_proto.ParkingStand.operation_types)
  return operation_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStand::_internal_mutable_operation_types() {
  return &operation_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStand::mutable_operation_types() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.ParkingStand.operation_types)
  return _internal_mutable_operation_types();
}

// repeated string airline_icaos = 9;
inline int ParkingStand::_internal_airline_icaos_size() const {
  return airline_icaos_.size();
}
inline int ParkingStand::airline_icaos_size() const {
  return _internal_airline_icaos_size();
}
inline void ParkingStand::clear_airline_icaos() {
  airline_icaos_.Clear();
}
inline std::string* ParkingStand::add_airline_icaos() {
  // @@protoc_insertion_point(field_add_mutable:world_proto.ParkingStand.airline_icaos)
  return _internal_add_airline_icaos();
}
inline const std::string& ParkingStand::_internal_airline_icaos(int index) const {
  return airline_icaos_.Get(index);
}
inline const std::string& ParkingStand::airline_icaos(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.ParkingStand.airline_icaos)
  return _internal_airline_icaos(index);
}
inline std::string* ParkingStand::mutable_airline_icaos(int index) {
  // @@protoc_insertion_point(field_mutable:world_proto.ParkingStand.airline_icaos)
  return airline_icaos_.Mutable(index);
}
inline void ParkingStand::set_airline_icaos(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.airline_icaos)
  airline_icaos_.Mutable(index)->assign(value);
}
inline void ParkingStand::set_airline_icaos(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:world_proto.ParkingStand.airline_icaos)
  airline_icaos_.Mutable(index)->assign(std::move(value));
}
inline void ParkingStand::set_airline_icaos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  airline_icaos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:world_proto.ParkingStand.airline_icaos)
}
inline void ParkingStand::set_airline_icaos(int index, const char* value, size_t size) {
  airline_icaos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:world_proto.ParkingStand.airline_icaos)
}
inline std::string* ParkingStand::_internal_add_airline_icaos() {
  return airline_icaos_.Add();
}
inline void ParkingStand::add_airline_icaos(const std::string& value) {
  airline_icaos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:world_proto.ParkingStand.airline_icaos)
}
inline void ParkingStand::add_airline_icaos(std::string&& value) {
  airline_icaos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:world_proto.ParkingStand.airline_icaos)
}
inline void ParkingStand::add_airline_icaos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  airline_icaos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:world_proto.ParkingStand.airline_icaos)
}
inline void ParkingStand::add_airline_icaos(const char* value, size_t size) {
  airline_icaos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:world_proto.ParkingStand.airline_icaos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParkingStand::airline_icaos() const {
  // @@protoc_insertion_point(field_list:world_proto.ParkingStand.airline_icaos)
  return airline_icaos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParkingStand::mutable_airline_icaos() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.ParkingStand.airline_icaos)
  return &airline_icaos_;
}

// -------------------------------------------------------------------

// Airport

// string icao = 1;
inline void Airport::clear_icao() {
  icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Airport::icao() const {
  // @@protoc_insertion_point(field_get:world_proto.Airport.icao)
  return _internal_icao();
}
inline void Airport::set_icao(const std::string& value) {
  _internal_set_icao(value);
  // @@protoc_insertion_point(field_set:world_proto.Airport.icao)
}
inline std::string* Airport::mutable_icao() {
  // @@protoc_insertion_point(field_mutable:world_proto.Airport.icao)
  return _internal_mutable_icao();
}
inline const std::string& Airport::_internal_icao() const {
  return icao_.Get();
}
inline void Airport::_internal_set_icao(const std::string& value) {
  
  icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Airport::set_icao(std::string&& value) {
  
  icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.Airport.icao)
}
inline void Airport::set_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.Airport.icao)
}
inline void Airport::set_icao(const char* value,
    size_t size) {
  
  icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.Airport.icao)
}
inline std::string* Airport::_internal_mutable_icao() {
  
  return icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Airport::release_icao() {
  // @@protoc_insertion_point(field_release:world_proto.Airport.icao)
  return icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Airport::set_allocated_icao(std::string* icao) {
  if (icao != nullptr) {
    
  } else {
    
  }
  icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.Airport.icao)
}

// .world_proto.GeoPoint location = 2;
inline bool Airport::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool Airport::has_location() const {
  return _internal_has_location();
}
inline void Airport::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::world_proto::GeoPoint& Airport::_internal_location() const {
  const ::world_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& Airport::location() const {
  // @@protoc_insertion_point(field_get:world_proto.Airport.location)
  return _internal_location();
}
inline void Airport::unsafe_arena_set_allocated_location(
    ::world_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.Airport.location)
}
inline ::world_proto::GeoPoint* Airport::release_location() {
  
  ::world_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* Airport::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:world_proto.Airport.location)
  
  ::world_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* Airport::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::world_proto::GeoPoint* Airport::mutable_location() {
  // @@protoc_insertion_point(field_mutable:world_proto.Airport.location)
  return _internal_mutable_location();
}
inline void Airport::set_allocated_location(::world_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:world_proto.Airport.location)
}

// repeated .world_proto.Runway runways = 3;
inline int Airport::_internal_runways_size() const {
  return runways_.size();
}
inline int Airport::runways_size() const {
  return _internal_runways_size();
}
inline void Airport::clear_runways() {
  runways_.Clear();
}
inline ::world_proto::Runway* Airport::mutable_runways(int index) {
  // @@protoc_insertion_point(field_mutable:world_proto.Airport.runways)
  return runways_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::Runway >*
Airport::mutable_runways() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.Airport.runways)
  return &runways_;
}
inline const ::world_proto::Runway& Airport::_internal_runways(int index) const {
  return runways_.Get(index);
}
inline const ::world_proto::Runway& Airport::runways(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.Airport.runways)
  return _internal_runways(index);
}
inline ::world_proto::Runway* Airport::_internal_add_runways() {
  return runways_.Add();
}
inline ::world_proto::Runway* Airport::add_runways() {
  // @@protoc_insertion_point(field_add:world_proto.Airport.runways)
  return _internal_add_runways();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::Runway >&
Airport::runways() const {
  // @@protoc_insertion_point(field_list:world_proto.Airport.runways)
  return runways_;
}

// repeated .world_proto.ParkingStand parking_stands = 4;
inline int Airport::_internal_parking_stands_size() const {
  return parking_stands_.size();
}
inline int Airport::parking_stands_size() const {
  return _internal_parking_stands_size();
}
inline void Airport::clear_parking_stands() {
  parking_stands_.Clear();
}
inline ::world_proto::ParkingStand* Airport::mutable_parking_stands(int index) {
  // @@protoc_insertion_point(field_mutable:world_proto.Airport.parking_stands)
  return parking_stands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::ParkingStand >*
Airport::mutable_parking_stands() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.Airport.parking_stands)
  return &parking_stands_;
}
inline const ::world_proto::ParkingStand& Airport::_internal_parking_stands(int index) const {
  return parking_stands_.Get(index);
}
inline const ::world_proto::ParkingStand& Airport::parking_stands(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.Airport.parking_stands)
  return _internal_parking_stands(index);
}
inline ::world_proto::ParkingStand* Airport::_internal_add_parking_stands() {
  return parking_stands_.Add();
}
inline ::world_proto::ParkingStand* Airport::add_parking_stands() {
  // @@protoc_insertion_point(field_add:world_proto.Airport.parking_stands)
  return _internal_add_parking_stands();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::ParkingStand >&
Airport::parking_stands() const {
  // @@protoc_insertion_point(field_list:world_proto.Airport.parking_stands)
  return parking_stands_;
}

// repeated .world_proto.TaxiNode taxi_nodes = 5;
inline int Airport::_internal_taxi_nodes_size() const {
  return taxi_nodes_.size();
}
inline int Airport::taxi_nodes_size() const {
  return _internal_taxi_nodes_size();
}
inline void Airport::clear_taxi_nodes() {
  taxi_nodes_.Clear();
}
inline ::world_proto::TaxiNode* Airport::mutable_taxi_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:world_proto.Airport.taxi_nodes)
  return taxi_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiNode >*
Airport::mutable_taxi_nodes() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.Airport.taxi_nodes)
  return &taxi_nodes_;
}
inline const ::world_proto::TaxiNode& Airport::_internal_taxi_nodes(int index) const {
  return taxi_nodes_.Get(index);
}
inline const ::world_proto::TaxiNode& Airport::taxi_nodes(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.Airport.taxi_nodes)
  return _internal_taxi_nodes(index);
}
inline ::world_proto::TaxiNode* Airport::_internal_add_taxi_nodes() {
  return taxi_nodes_.Add();
}
inline ::world_proto::TaxiNode* Airport::add_taxi_nodes() {
  // @@protoc_insertion_point(field_add:world_proto.Airport.taxi_nodes)
  return _internal_add_taxi_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiNode >&
Airport::taxi_nodes() const {
  // @@protoc_insertion_point(field_list:world_proto.Airport.taxi_nodes)
  return taxi_nodes_;
}

// repeated .world_proto.TaxiEdge taxi_edges = 6;
inline int Airport::_internal_taxi_edges_size() const {
  return taxi_edges_.size();
}
inline int Airport::taxi_edges_size() const {
  return _internal_taxi_edges_size();
}
inline void Airport::clear_taxi_edges() {
  taxi_edges_.Clear();
}
inline ::world_proto::TaxiEdge* Airport::mutable_taxi_edges(int index) {
  // @@protoc_insertion_point(field_mutable:world_proto.Airport.taxi_edges)
  return taxi_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiEdge >*
Airport::mutable_taxi_edges() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.Airport.taxi_edges)
  return &taxi_edges_;
}
inline const ::world_proto::TaxiEdge& Airport::_internal_taxi_edges(int index) const {
  return taxi_edges_.Get(index);
}
inline const ::world_proto::TaxiEdge& Airport::taxi_edges(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.Airport.taxi_edges)
  return _internal_taxi_edges(index);
}
inline ::world_proto::TaxiEdge* Airport::_internal_add_taxi_edges() {
  return taxi_edges_.Add();
}
inline ::world_proto::TaxiEdge* Airport::add_taxi_edges() {
  // @@protoc_insertion_point(field_add:world_proto.Airport.taxi_edges)
  return _internal_add_taxi_edges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::TaxiEdge >&
Airport::taxi_edges() const {
  // @@protoc_insertion_point(field_list:world_proto.Airport.taxi_edges)
  return taxi_edges_;
}

// -------------------------------------------------------------------

// TaxiPath

// int32 from_node_id = 1;
inline void TaxiPath::clear_from_node_id() {
  from_node_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPath::_internal_from_node_id() const {
  return from_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPath::from_node_id() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiPath.from_node_id)
  return _internal_from_node_id();
}
inline void TaxiPath::_internal_set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  from_node_id_ = value;
}
inline void TaxiPath::set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_from_node_id(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiPath.from_node_id)
}

// int32 to_node_id = 2;
inline void TaxiPath::clear_to_node_id() {
  to_node_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPath::_internal_to_node_id() const {
  return to_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPath::to_node_id() const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiPath.to_node_id)
  return _internal_to_node_id();
}
inline void TaxiPath::_internal_set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  to_node_id_ = value;
}
inline void TaxiPath::set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_to_node_id(value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiPath.to_node_id)
}

// repeated int32 edge_ids = 3;
inline int TaxiPath::_internal_edge_ids_size() const {
  return edge_ids_.size();
}
inline int TaxiPath::edge_ids_size() const {
  return _internal_edge_ids_size();
}
inline void TaxiPath::clear_edge_ids() {
  edge_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPath::_internal_edge_ids(int index) const {
  return edge_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPath::edge_ids(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.TaxiPath.edge_ids)
  return _internal_edge_ids(index);
}
inline void TaxiPath::set_edge_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  edge_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:world_proto.TaxiPath.edge_ids)
}
inline void TaxiPath::_internal_add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  edge_ids_.Add(value);
}
inline void TaxiPath::add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_edge_ids(value);
  // @@protoc_insertion_point(field_add:world_proto.TaxiPath.edge_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaxiPath::_internal_edge_ids() const {
  return edge_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaxiPath::edge_ids() const {
  // @@protoc_insertion_point(field_list:world_proto.TaxiPath.edge_ids)
  return _internal_edge_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaxiPath::_internal_mutable_edge_ids() {
  return &edge_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaxiPath::mutable_edge_ids() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.TaxiPath.edge_ids)
  return _internal_mutable_edge_ids();
}

// -------------------------------------------------------------------

// GeoPolygon_GeoEdge

// .world_proto.GeoPolygon.GeoEdgeType type = 1;
inline void GeoPolygon_GeoEdge::clear_type() {
  type_ = 0;
}
inline ::world_proto::GeoPolygon_GeoEdgeType GeoPolygon_GeoEdge::_internal_type() const {
  return static_cast< ::world_proto::GeoPolygon_GeoEdgeType >(type_);
}
inline ::world_proto::GeoPolygon_GeoEdgeType GeoPolygon_GeoEdge::type() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoPolygon.GeoEdge.type)
  return _internal_type();
}
inline void GeoPolygon_GeoEdge::_internal_set_type(::world_proto::GeoPolygon_GeoEdgeType value) {
  
  type_ = value;
}
inline void GeoPolygon_GeoEdge::set_type(::world_proto::GeoPolygon_GeoEdgeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:world_proto.GeoPolygon.GeoEdge.type)
}

// .world_proto.GeoPoint from_point = 2;
inline bool GeoPolygon_GeoEdge::_internal_has_from_point() const {
  return this != internal_default_instance() && from_point_ != nullptr;
}
inline bool GeoPolygon_GeoEdge::has_from_point() const {
  return _internal_has_from_point();
}
inline void GeoPolygon_GeoEdge::clear_from_point() {
  if (GetArena() == nullptr && from_point_ != nullptr) {
    delete from_point_;
  }
  from_point_ = nullptr;
}
inline const ::world_proto::GeoPoint& GeoPolygon_GeoEdge::_internal_from_point() const {
  const ::world_proto::GeoPoint* p = from_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& GeoPolygon_GeoEdge::from_point() const {
  // @@protoc_insertion_point(field_get:world_proto.GeoPolygon.GeoEdge.from_point)
  return _internal_from_point();
}
inline void GeoPolygon_GeoEdge::unsafe_arena_set_allocated_from_point(
    ::world_proto::GeoPoint* from_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_point_);
  }
  from_point_ = from_point;
  if (from_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.GeoPolygon.GeoEdge.from_point)
}
inline ::world_proto::GeoPoint* GeoPolygon_GeoEdge::release_from_point() {
  
  ::world_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* GeoPolygon_GeoEdge::unsafe_arena_release_from_point() {
  // @@protoc_insertion_point(field_release:world_proto.GeoPolygon.GeoEdge.from_point)
  
  ::world_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* GeoPolygon_GeoEdge::_internal_mutable_from_point() {
  
  if (from_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    from_point_ = p;
  }
  return from_point_;
}
inline ::world_proto::GeoPoint* GeoPolygon_GeoEdge::mutable_from_point() {
  // @@protoc_insertion_point(field_mutable:world_proto.GeoPolygon.GeoEdge.from_point)
  return _internal_mutable_from_point();
}
inline void GeoPolygon_GeoEdge::set_allocated_from_point(::world_proto::GeoPoint* from_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_point_;
  }
  if (from_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from_point);
    if (message_arena != submessage_arena) {
      from_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_point, submessage_arena);
    }
    
  } else {
    
  }
  from_point_ = from_point;
  // @@protoc_insertion_point(field_set_allocated:world_proto.GeoPolygon.GeoEdge.from_point)
}

// -------------------------------------------------------------------

// GeoPolygon

// repeated .world_proto.GeoPolygon.GeoEdge edges = 1;
inline int GeoPolygon::_internal_edges_size() const {
  return edges_.size();
}
inline int GeoPolygon::edges_size() const {
  return _internal_edges_size();
}
inline void GeoPolygon::clear_edges() {
  edges_.Clear();
}
inline ::world_proto::GeoPolygon_GeoEdge* GeoPolygon::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:world_proto.GeoPolygon.edges)
  return edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::GeoPolygon_GeoEdge >*
GeoPolygon::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:world_proto.GeoPolygon.edges)
  return &edges_;
}
inline const ::world_proto::GeoPolygon_GeoEdge& GeoPolygon::_internal_edges(int index) const {
  return edges_.Get(index);
}
inline const ::world_proto::GeoPolygon_GeoEdge& GeoPolygon::edges(int index) const {
  // @@protoc_insertion_point(field_get:world_proto.GeoPolygon.edges)
  return _internal_edges(index);
}
inline ::world_proto::GeoPolygon_GeoEdge* GeoPolygon::_internal_add_edges() {
  return edges_.Add();
}
inline ::world_proto::GeoPolygon_GeoEdge* GeoPolygon::add_edges() {
  // @@protoc_insertion_point(field_add:world_proto.GeoPolygon.edges)
  return _internal_add_edges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world_proto::GeoPolygon_GeoEdge >&
GeoPolygon::edges() const {
  // @@protoc_insertion_point(field_list:world_proto.GeoPolygon.edges)
  return edges_;
}

// -------------------------------------------------------------------

// AirspaceGeometry

// .world_proto.GeoPolygon lateral_bounds = 1;
inline bool AirspaceGeometry::_internal_has_lateral_bounds() const {
  return this != internal_default_instance() && lateral_bounds_ != nullptr;
}
inline bool AirspaceGeometry::has_lateral_bounds() const {
  return _internal_has_lateral_bounds();
}
inline void AirspaceGeometry::clear_lateral_bounds() {
  if (GetArena() == nullptr && lateral_bounds_ != nullptr) {
    delete lateral_bounds_;
  }
  lateral_bounds_ = nullptr;
}
inline const ::world_proto::GeoPolygon& AirspaceGeometry::_internal_lateral_bounds() const {
  const ::world_proto::GeoPolygon* p = lateral_bounds_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPolygon*>(
      &::world_proto::_GeoPolygon_default_instance_);
}
inline const ::world_proto::GeoPolygon& AirspaceGeometry::lateral_bounds() const {
  // @@protoc_insertion_point(field_get:world_proto.AirspaceGeometry.lateral_bounds)
  return _internal_lateral_bounds();
}
inline void AirspaceGeometry::unsafe_arena_set_allocated_lateral_bounds(
    ::world_proto::GeoPolygon* lateral_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lateral_bounds_);
  }
  lateral_bounds_ = lateral_bounds;
  if (lateral_bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.AirspaceGeometry.lateral_bounds)
}
inline ::world_proto::GeoPolygon* AirspaceGeometry::release_lateral_bounds() {
  
  ::world_proto::GeoPolygon* temp = lateral_bounds_;
  lateral_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPolygon* AirspaceGeometry::unsafe_arena_release_lateral_bounds() {
  // @@protoc_insertion_point(field_release:world_proto.AirspaceGeometry.lateral_bounds)
  
  ::world_proto::GeoPolygon* temp = lateral_bounds_;
  lateral_bounds_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPolygon* AirspaceGeometry::_internal_mutable_lateral_bounds() {
  
  if (lateral_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPolygon>(GetArena());
    lateral_bounds_ = p;
  }
  return lateral_bounds_;
}
inline ::world_proto::GeoPolygon* AirspaceGeometry::mutable_lateral_bounds() {
  // @@protoc_insertion_point(field_mutable:world_proto.AirspaceGeometry.lateral_bounds)
  return _internal_mutable_lateral_bounds();
}
inline void AirspaceGeometry::set_allocated_lateral_bounds(::world_proto::GeoPolygon* lateral_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lateral_bounds_;
  }
  if (lateral_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lateral_bounds);
    if (message_arena != submessage_arena) {
      lateral_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lateral_bounds, submessage_arena);
    }
    
  } else {
    
  }
  lateral_bounds_ = lateral_bounds;
  // @@protoc_insertion_point(field_set_allocated:world_proto.AirspaceGeometry.lateral_bounds)
}

// float lower_bound_feet = 2;
inline void AirspaceGeometry::clear_lower_bound_feet() {
  lower_bound_feet_ = 0;
}
inline float AirspaceGeometry::_internal_lower_bound_feet() const {
  return lower_bound_feet_;
}
inline float AirspaceGeometry::lower_bound_feet() const {
  // @@protoc_insertion_point(field_get:world_proto.AirspaceGeometry.lower_bound_feet)
  return _internal_lower_bound_feet();
}
inline void AirspaceGeometry::_internal_set_lower_bound_feet(float value) {
  
  lower_bound_feet_ = value;
}
inline void AirspaceGeometry::set_lower_bound_feet(float value) {
  _internal_set_lower_bound_feet(value);
  // @@protoc_insertion_point(field_set:world_proto.AirspaceGeometry.lower_bound_feet)
}

// float upper_bound_feet = 3;
inline void AirspaceGeometry::clear_upper_bound_feet() {
  upper_bound_feet_ = 0;
}
inline float AirspaceGeometry::_internal_upper_bound_feet() const {
  return upper_bound_feet_;
}
inline float AirspaceGeometry::upper_bound_feet() const {
  // @@protoc_insertion_point(field_get:world_proto.AirspaceGeometry.upper_bound_feet)
  return _internal_upper_bound_feet();
}
inline void AirspaceGeometry::_internal_set_upper_bound_feet(float value) {
  
  upper_bound_feet_ = value;
}
inline void AirspaceGeometry::set_upper_bound_feet(float value) {
  _internal_set_upper_bound_feet(value);
  // @@protoc_insertion_point(field_set:world_proto.AirspaceGeometry.upper_bound_feet)
}

// -------------------------------------------------------------------

// ControlledAirspace

// string area_code = 1;
inline void ControlledAirspace::clear_area_code() {
  area_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlledAirspace::area_code() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.area_code)
  return _internal_area_code();
}
inline void ControlledAirspace::set_area_code(const std::string& value) {
  _internal_set_area_code(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.area_code)
}
inline std::string* ControlledAirspace::mutable_area_code() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlledAirspace.area_code)
  return _internal_mutable_area_code();
}
inline const std::string& ControlledAirspace::_internal_area_code() const {
  return area_code_.Get();
}
inline void ControlledAirspace::_internal_set_area_code(const std::string& value) {
  
  area_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlledAirspace::set_area_code(std::string&& value) {
  
  area_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlledAirspace.area_code)
}
inline void ControlledAirspace::set_area_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  area_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlledAirspace.area_code)
}
inline void ControlledAirspace::set_area_code(const char* value,
    size_t size) {
  
  area_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlledAirspace.area_code)
}
inline std::string* ControlledAirspace::_internal_mutable_area_code() {
  
  return area_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlledAirspace::release_area_code() {
  // @@protoc_insertion_point(field_release:world_proto.ControlledAirspace.area_code)
  return area_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlledAirspace::set_allocated_area_code(std::string* area_code) {
  if (area_code != nullptr) {
    
  } else {
    
  }
  area_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), area_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlledAirspace.area_code)
}

// string icao_code = 2;
inline void ControlledAirspace::clear_icao_code() {
  icao_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlledAirspace::icao_code() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.icao_code)
  return _internal_icao_code();
}
inline void ControlledAirspace::set_icao_code(const std::string& value) {
  _internal_set_icao_code(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.icao_code)
}
inline std::string* ControlledAirspace::mutable_icao_code() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlledAirspace.icao_code)
  return _internal_mutable_icao_code();
}
inline const std::string& ControlledAirspace::_internal_icao_code() const {
  return icao_code_.Get();
}
inline void ControlledAirspace::_internal_set_icao_code(const std::string& value) {
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlledAirspace::set_icao_code(std::string&& value) {
  
  icao_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlledAirspace.icao_code)
}
inline void ControlledAirspace::set_icao_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlledAirspace.icao_code)
}
inline void ControlledAirspace::set_icao_code(const char* value,
    size_t size) {
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlledAirspace.icao_code)
}
inline std::string* ControlledAirspace::_internal_mutable_icao_code() {
  
  return icao_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlledAirspace::release_icao_code() {
  // @@protoc_insertion_point(field_release:world_proto.ControlledAirspace.icao_code)
  return icao_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlledAirspace::set_allocated_icao_code(std::string* icao_code) {
  if (icao_code != nullptr) {
    
  } else {
    
  }
  icao_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icao_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlledAirspace.icao_code)
}

// string airspace_center = 3;
inline void ControlledAirspace::clear_airspace_center() {
  airspace_center_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlledAirspace::airspace_center() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.airspace_center)
  return _internal_airspace_center();
}
inline void ControlledAirspace::set_airspace_center(const std::string& value) {
  _internal_set_airspace_center(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.airspace_center)
}
inline std::string* ControlledAirspace::mutable_airspace_center() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlledAirspace.airspace_center)
  return _internal_mutable_airspace_center();
}
inline const std::string& ControlledAirspace::_internal_airspace_center() const {
  return airspace_center_.Get();
}
inline void ControlledAirspace::_internal_set_airspace_center(const std::string& value) {
  
  airspace_center_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlledAirspace::set_airspace_center(std::string&& value) {
  
  airspace_center_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlledAirspace.airspace_center)
}
inline void ControlledAirspace::set_airspace_center(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  airspace_center_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlledAirspace.airspace_center)
}
inline void ControlledAirspace::set_airspace_center(const char* value,
    size_t size) {
  
  airspace_center_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlledAirspace.airspace_center)
}
inline std::string* ControlledAirspace::_internal_mutable_airspace_center() {
  
  return airspace_center_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlledAirspace::release_airspace_center() {
  // @@protoc_insertion_point(field_release:world_proto.ControlledAirspace.airspace_center)
  return airspace_center_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlledAirspace::set_allocated_airspace_center(std::string* airspace_center) {
  if (airspace_center != nullptr) {
    
  } else {
    
  }
  airspace_center_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), airspace_center,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlledAirspace.airspace_center)
}

// string controlled_airspace_name = 4;
inline void ControlledAirspace::clear_controlled_airspace_name() {
  controlled_airspace_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlledAirspace::controlled_airspace_name() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.controlled_airspace_name)
  return _internal_controlled_airspace_name();
}
inline void ControlledAirspace::set_controlled_airspace_name(const std::string& value) {
  _internal_set_controlled_airspace_name(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.controlled_airspace_name)
}
inline std::string* ControlledAirspace::mutable_controlled_airspace_name() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlledAirspace.controlled_airspace_name)
  return _internal_mutable_controlled_airspace_name();
}
inline const std::string& ControlledAirspace::_internal_controlled_airspace_name() const {
  return controlled_airspace_name_.Get();
}
inline void ControlledAirspace::_internal_set_controlled_airspace_name(const std::string& value) {
  
  controlled_airspace_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlledAirspace::set_controlled_airspace_name(std::string&& value) {
  
  controlled_airspace_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlledAirspace.controlled_airspace_name)
}
inline void ControlledAirspace::set_controlled_airspace_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  controlled_airspace_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlledAirspace.controlled_airspace_name)
}
inline void ControlledAirspace::set_controlled_airspace_name(const char* value,
    size_t size) {
  
  controlled_airspace_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlledAirspace.controlled_airspace_name)
}
inline std::string* ControlledAirspace::_internal_mutable_controlled_airspace_name() {
  
  return controlled_airspace_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlledAirspace::release_controlled_airspace_name() {
  // @@protoc_insertion_point(field_release:world_proto.ControlledAirspace.controlled_airspace_name)
  return controlled_airspace_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlledAirspace::set_allocated_controlled_airspace_name(std::string* controlled_airspace_name) {
  if (controlled_airspace_name != nullptr) {
    
  } else {
    
  }
  controlled_airspace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controlled_airspace_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlledAirspace.controlled_airspace_name)
}

// .world_proto.ControlledAirspace.Type type = 5;
inline void ControlledAirspace::clear_type() {
  type_ = 0;
}
inline ::world_proto::ControlledAirspace_Type ControlledAirspace::_internal_type() const {
  return static_cast< ::world_proto::ControlledAirspace_Type >(type_);
}
inline ::world_proto::ControlledAirspace_Type ControlledAirspace::type() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.type)
  return _internal_type();
}
inline void ControlledAirspace::_internal_set_type(::world_proto::ControlledAirspace_Type value) {
  
  type_ = value;
}
inline void ControlledAirspace::set_type(::world_proto::ControlledAirspace_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.type)
}

// .world_proto.ControlledAirspace.Classification classification = 6;
inline void ControlledAirspace::clear_classification() {
  classification_ = 0;
}
inline ::world_proto::ControlledAirspace_Classification ControlledAirspace::_internal_classification() const {
  return static_cast< ::world_proto::ControlledAirspace_Classification >(classification_);
}
inline ::world_proto::ControlledAirspace_Classification ControlledAirspace::classification() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.classification)
  return _internal_classification();
}
inline void ControlledAirspace::_internal_set_classification(::world_proto::ControlledAirspace_Classification value) {
  
  classification_ = value;
}
inline void ControlledAirspace::set_classification(::world_proto::ControlledAirspace_Classification value) {
  _internal_set_classification(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.classification)
}

// .world_proto.AirspaceGeometry geometry = 7;
inline bool ControlledAirspace::_internal_has_geometry() const {
  return this != internal_default_instance() && geometry_ != nullptr;
}
inline bool ControlledAirspace::has_geometry() const {
  return _internal_has_geometry();
}
inline void ControlledAirspace::clear_geometry() {
  if (GetArena() == nullptr && geometry_ != nullptr) {
    delete geometry_;
  }
  geometry_ = nullptr;
}
inline const ::world_proto::AirspaceGeometry& ControlledAirspace::_internal_geometry() const {
  const ::world_proto::AirspaceGeometry* p = geometry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::AirspaceGeometry*>(
      &::world_proto::_AirspaceGeometry_default_instance_);
}
inline const ::world_proto::AirspaceGeometry& ControlledAirspace::geometry() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.geometry)
  return _internal_geometry();
}
inline void ControlledAirspace::unsafe_arena_set_allocated_geometry(
    ::world_proto::AirspaceGeometry* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ControlledAirspace.geometry)
}
inline ::world_proto::AirspaceGeometry* ControlledAirspace::release_geometry() {
  
  ::world_proto::AirspaceGeometry* temp = geometry_;
  geometry_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::AirspaceGeometry* ControlledAirspace::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:world_proto.ControlledAirspace.geometry)
  
  ::world_proto::AirspaceGeometry* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::world_proto::AirspaceGeometry* ControlledAirspace::_internal_mutable_geometry() {
  
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::AirspaceGeometry>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::world_proto::AirspaceGeometry* ControlledAirspace::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlledAirspace.geometry)
  return _internal_mutable_geometry();
}
inline void ControlledAirspace::set_allocated_geometry(::world_proto::AirspaceGeometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlledAirspace.geometry)
}

// string tower_airport_icao = 8;
inline void ControlledAirspace::clear_tower_airport_icao() {
  tower_airport_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlledAirspace::tower_airport_icao() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlledAirspace.tower_airport_icao)
  return _internal_tower_airport_icao();
}
inline void ControlledAirspace::set_tower_airport_icao(const std::string& value) {
  _internal_set_tower_airport_icao(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlledAirspace.tower_airport_icao)
}
inline std::string* ControlledAirspace::mutable_tower_airport_icao() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlledAirspace.tower_airport_icao)
  return _internal_mutable_tower_airport_icao();
}
inline const std::string& ControlledAirspace::_internal_tower_airport_icao() const {
  return tower_airport_icao_.Get();
}
inline void ControlledAirspace::_internal_set_tower_airport_icao(const std::string& value) {
  
  tower_airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlledAirspace::set_tower_airport_icao(std::string&& value) {
  
  tower_airport_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlledAirspace.tower_airport_icao)
}
inline void ControlledAirspace::set_tower_airport_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tower_airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlledAirspace.tower_airport_icao)
}
inline void ControlledAirspace::set_tower_airport_icao(const char* value,
    size_t size) {
  
  tower_airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlledAirspace.tower_airport_icao)
}
inline std::string* ControlledAirspace::_internal_mutable_tower_airport_icao() {
  
  return tower_airport_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlledAirspace::release_tower_airport_icao() {
  // @@protoc_insertion_point(field_release:world_proto.ControlledAirspace.tower_airport_icao)
  return tower_airport_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlledAirspace::set_allocated_tower_airport_icao(std::string* tower_airport_icao) {
  if (tower_airport_icao != nullptr) {
    
  } else {
    
  }
  tower_airport_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tower_airport_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlledAirspace.tower_airport_icao)
}

// -------------------------------------------------------------------

// ControlFacility

// string call_sign = 1;
inline void ControlFacility::clear_call_sign() {
  call_sign_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlFacility::call_sign() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlFacility.call_sign)
  return _internal_call_sign();
}
inline void ControlFacility::set_call_sign(const std::string& value) {
  _internal_set_call_sign(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlFacility.call_sign)
}
inline std::string* ControlFacility::mutable_call_sign() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlFacility.call_sign)
  return _internal_mutable_call_sign();
}
inline const std::string& ControlFacility::_internal_call_sign() const {
  return call_sign_.Get();
}
inline void ControlFacility::_internal_set_call_sign(const std::string& value) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlFacility::set_call_sign(std::string&& value) {
  
  call_sign_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlFacility.call_sign)
}
inline void ControlFacility::set_call_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlFacility.call_sign)
}
inline void ControlFacility::set_call_sign(const char* value,
    size_t size) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlFacility.call_sign)
}
inline std::string* ControlFacility::_internal_mutable_call_sign() {
  
  return call_sign_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlFacility::release_call_sign() {
  // @@protoc_insertion_point(field_release:world_proto.ControlFacility.call_sign)
  return call_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlFacility::set_allocated_call_sign(std::string* call_sign) {
  if (call_sign != nullptr) {
    
  } else {
    
  }
  call_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), call_sign,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlFacility.call_sign)
}

// string name = 2;
inline void ControlFacility::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlFacility::name() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlFacility.name)
  return _internal_name();
}
inline void ControlFacility::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlFacility.name)
}
inline std::string* ControlFacility::mutable_name() {
  // @@protoc_insertion_point(field_mutable:world_proto.ControlFacility.name)
  return _internal_mutable_name();
}
inline const std::string& ControlFacility::_internal_name() const {
  return name_.Get();
}
inline void ControlFacility::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlFacility::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ControlFacility.name)
}
inline void ControlFacility::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ControlFacility.name)
}
inline void ControlFacility::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ControlFacility.name)
}
inline std::string* ControlFacility::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlFacility::release_name() {
  // @@protoc_insertion_point(field_release:world_proto.ControlFacility.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlFacility::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ControlFacility.name)
}

// .world_proto.ControlFacility.Type type = 3;
inline void ControlFacility::clear_type() {
  type_ = 0;
}
inline ::world_proto::ControlFacility_Type ControlFacility::_internal_type() const {
  return static_cast< ::world_proto::ControlFacility_Type >(type_);
}
inline ::world_proto::ControlFacility_Type ControlFacility::type() const {
  // @@protoc_insertion_point(field_get:world_proto.ControlFacility.type)
  return _internal_type();
}
inline void ControlFacility::_internal_set_type(::world_proto::ControlFacility_Type value) {
  
  type_ = value;
}
inline void ControlFacility::set_type(::world_proto::ControlFacility_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:world_proto.ControlFacility.type)
}

// -------------------------------------------------------------------

// ClientToServer_Connect

// string token = 1;
inline void ClientToServer_Connect::clear_token() {
  token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_Connect::token() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.Connect.token)
  return _internal_token();
}
inline void ClientToServer_Connect::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.Connect.token)
}
inline std::string* ClientToServer_Connect::mutable_token() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.Connect.token)
  return _internal_mutable_token();
}
inline const std::string& ClientToServer_Connect::_internal_token() const {
  return token_.Get();
}
inline void ClientToServer_Connect::_internal_set_token(const std::string& value) {
  
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_Connect::set_token(std::string&& value) {
  
  token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ClientToServer.Connect.token)
}
inline void ClientToServer_Connect::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ClientToServer.Connect.token)
}
inline void ClientToServer_Connect::set_token(const char* value,
    size_t size) {
  
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ClientToServer.Connect.token)
}
inline std::string* ClientToServer_Connect::_internal_mutable_token() {
  
  return token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_Connect::release_token() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.Connect.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_Connect::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.Connect.token)
}

// -------------------------------------------------------------------

// ClientToServer_QueryAirport

// string icao_code = 1;
inline void ClientToServer_QueryAirport::clear_icao_code() {
  icao_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryAirport::icao_code() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.QueryAirport.icao_code)
  return _internal_icao_code();
}
inline void ClientToServer_QueryAirport::set_icao_code(const std::string& value) {
  _internal_set_icao_code(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.QueryAirport.icao_code)
}
inline std::string* ClientToServer_QueryAirport::mutable_icao_code() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.QueryAirport.icao_code)
  return _internal_mutable_icao_code();
}
inline const std::string& ClientToServer_QueryAirport::_internal_icao_code() const {
  return icao_code_.Get();
}
inline void ClientToServer_QueryAirport::_internal_set_icao_code(const std::string& value) {
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryAirport::set_icao_code(std::string&& value) {
  
  icao_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ClientToServer.QueryAirport.icao_code)
}
inline void ClientToServer_QueryAirport::set_icao_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ClientToServer.QueryAirport.icao_code)
}
inline void ClientToServer_QueryAirport::set_icao_code(const char* value,
    size_t size) {
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ClientToServer.QueryAirport.icao_code)
}
inline std::string* ClientToServer_QueryAirport::_internal_mutable_icao_code() {
  
  return icao_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryAirport::release_icao_code() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.QueryAirport.icao_code)
  return icao_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryAirport::set_allocated_icao_code(std::string* icao_code) {
  if (icao_code != nullptr) {
    
  } else {
    
  }
  icao_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icao_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.QueryAirport.icao_code)
}

// -------------------------------------------------------------------

// ClientToServer_QueryTaxiPath

// string airport_icao = 1;
inline void ClientToServer_QueryTaxiPath::clear_airport_icao() {
  airport_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryTaxiPath::airport_icao() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
  return _internal_airport_icao();
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(const std::string& value) {
  _internal_set_airport_icao(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::mutable_airport_icao() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
  return _internal_mutable_airport_icao();
}
inline const std::string& ClientToServer_QueryTaxiPath::_internal_airport_icao() const {
  return airport_icao_.Get();
}
inline void ClientToServer_QueryTaxiPath::_internal_set_airport_icao(const std::string& value) {
  
  airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(std::string&& value) {
  
  airport_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(const char* value,
    size_t size) {
  
  airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::_internal_mutable_airport_icao() {
  
  return airport_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryTaxiPath::release_airport_icao() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
  return airport_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_allocated_airport_icao(std::string* airport_icao) {
  if (airport_icao != nullptr) {
    
  } else {
    
  }
  airport_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), airport_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.QueryTaxiPath.airport_icao)
}

// string aircraft_model_icao = 2;
inline void ClientToServer_QueryTaxiPath::clear_aircraft_model_icao() {
  aircraft_model_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryTaxiPath::aircraft_model_icao() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
  return _internal_aircraft_model_icao();
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(const std::string& value) {
  _internal_set_aircraft_model_icao(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::mutable_aircraft_model_icao() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
  return _internal_mutable_aircraft_model_icao();
}
inline const std::string& ClientToServer_QueryTaxiPath::_internal_aircraft_model_icao() const {
  return aircraft_model_icao_.Get();
}
inline void ClientToServer_QueryTaxiPath::_internal_set_aircraft_model_icao(const std::string& value) {
  
  aircraft_model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(std::string&& value) {
  
  aircraft_model_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  aircraft_model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(const char* value,
    size_t size) {
  
  aircraft_model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::_internal_mutable_aircraft_model_icao() {
  
  return aircraft_model_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryTaxiPath::release_aircraft_model_icao() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
  return aircraft_model_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_allocated_aircraft_model_icao(std::string* aircraft_model_icao) {
  if (aircraft_model_icao != nullptr) {
    
  } else {
    
  }
  aircraft_model_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), aircraft_model_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}

// .world_proto.GeoPoint from_point = 3;
inline bool ClientToServer_QueryTaxiPath::_internal_has_from_point() const {
  return this != internal_default_instance() && from_point_ != nullptr;
}
inline bool ClientToServer_QueryTaxiPath::has_from_point() const {
  return _internal_has_from_point();
}
inline void ClientToServer_QueryTaxiPath::clear_from_point() {
  if (GetArena() == nullptr && from_point_ != nullptr) {
    delete from_point_;
  }
  from_point_ = nullptr;
}
inline const ::world_proto::GeoPoint& ClientToServer_QueryTaxiPath::_internal_from_point() const {
  const ::world_proto::GeoPoint* p = from_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& ClientToServer_QueryTaxiPath::from_point() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.QueryTaxiPath.from_point)
  return _internal_from_point();
}
inline void ClientToServer_QueryTaxiPath::unsafe_arena_set_allocated_from_point(
    ::world_proto::GeoPoint* from_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_point_);
  }
  from_point_ = from_point;
  if (from_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.QueryTaxiPath.from_point)
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::release_from_point() {
  
  ::world_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::unsafe_arena_release_from_point() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.QueryTaxiPath.from_point)
  
  ::world_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::_internal_mutable_from_point() {
  
  if (from_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    from_point_ = p;
  }
  return from_point_;
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::mutable_from_point() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.QueryTaxiPath.from_point)
  return _internal_mutable_from_point();
}
inline void ClientToServer_QueryTaxiPath::set_allocated_from_point(::world_proto::GeoPoint* from_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_point_;
  }
  if (from_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from_point);
    if (message_arena != submessage_arena) {
      from_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_point, submessage_arena);
    }
    
  } else {
    
  }
  from_point_ = from_point;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.QueryTaxiPath.from_point)
}

// .world_proto.GeoPoint to_point = 4;
inline bool ClientToServer_QueryTaxiPath::_internal_has_to_point() const {
  return this != internal_default_instance() && to_point_ != nullptr;
}
inline bool ClientToServer_QueryTaxiPath::has_to_point() const {
  return _internal_has_to_point();
}
inline void ClientToServer_QueryTaxiPath::clear_to_point() {
  if (GetArena() == nullptr && to_point_ != nullptr) {
    delete to_point_;
  }
  to_point_ = nullptr;
}
inline const ::world_proto::GeoPoint& ClientToServer_QueryTaxiPath::_internal_to_point() const {
  const ::world_proto::GeoPoint* p = to_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::GeoPoint*>(
      &::world_proto::_GeoPoint_default_instance_);
}
inline const ::world_proto::GeoPoint& ClientToServer_QueryTaxiPath::to_point() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.QueryTaxiPath.to_point)
  return _internal_to_point();
}
inline void ClientToServer_QueryTaxiPath::unsafe_arena_set_allocated_to_point(
    ::world_proto::GeoPoint* to_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to_point_);
  }
  to_point_ = to_point;
  if (to_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.QueryTaxiPath.to_point)
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::release_to_point() {
  
  ::world_proto::GeoPoint* temp = to_point_;
  to_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::unsafe_arena_release_to_point() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.QueryTaxiPath.to_point)
  
  ::world_proto::GeoPoint* temp = to_point_;
  to_point_ = nullptr;
  return temp;
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::_internal_mutable_to_point() {
  
  if (to_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::GeoPoint>(GetArena());
    to_point_ = p;
  }
  return to_point_;
}
inline ::world_proto::GeoPoint* ClientToServer_QueryTaxiPath::mutable_to_point() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.QueryTaxiPath.to_point)
  return _internal_mutable_to_point();
}
inline void ClientToServer_QueryTaxiPath::set_allocated_to_point(::world_proto::GeoPoint* to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete to_point_;
  }
  if (to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(to_point);
    if (message_arena != submessage_arena) {
      to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_point, submessage_arena);
    }
    
  } else {
    
  }
  to_point_ = to_point;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.QueryTaxiPath.to_point)
}

// -------------------------------------------------------------------

// ClientToServer_CreateAircraft

// .world_proto.Aircraft aircraft = 1;
inline bool ClientToServer_CreateAircraft::_internal_has_aircraft() const {
  return this != internal_default_instance() && aircraft_ != nullptr;
}
inline bool ClientToServer_CreateAircraft::has_aircraft() const {
  return _internal_has_aircraft();
}
inline void ClientToServer_CreateAircraft::clear_aircraft() {
  if (GetArena() == nullptr && aircraft_ != nullptr) {
    delete aircraft_;
  }
  aircraft_ = nullptr;
}
inline const ::world_proto::Aircraft& ClientToServer_CreateAircraft::_internal_aircraft() const {
  const ::world_proto::Aircraft* p = aircraft_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Aircraft*>(
      &::world_proto::_Aircraft_default_instance_);
}
inline const ::world_proto::Aircraft& ClientToServer_CreateAircraft::aircraft() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.CreateAircraft.aircraft)
  return _internal_aircraft();
}
inline void ClientToServer_CreateAircraft::unsafe_arena_set_allocated_aircraft(
    ::world_proto::Aircraft* aircraft) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_);
  }
  aircraft_ = aircraft;
  if (aircraft) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.CreateAircraft.aircraft)
}
inline ::world_proto::Aircraft* ClientToServer_CreateAircraft::release_aircraft() {
  
  ::world_proto::Aircraft* temp = aircraft_;
  aircraft_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Aircraft* ClientToServer_CreateAircraft::unsafe_arena_release_aircraft() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.CreateAircraft.aircraft)
  
  ::world_proto::Aircraft* temp = aircraft_;
  aircraft_ = nullptr;
  return temp;
}
inline ::world_proto::Aircraft* ClientToServer_CreateAircraft::_internal_mutable_aircraft() {
  
  if (aircraft_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Aircraft>(GetArena());
    aircraft_ = p;
  }
  return aircraft_;
}
inline ::world_proto::Aircraft* ClientToServer_CreateAircraft::mutable_aircraft() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.CreateAircraft.aircraft)
  return _internal_mutable_aircraft();
}
inline void ClientToServer_CreateAircraft::set_allocated_aircraft(::world_proto::Aircraft* aircraft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_;
  }
  if (aircraft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft);
    if (message_arena != submessage_arena) {
      aircraft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_ = aircraft;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.CreateAircraft.aircraft)
}

// -------------------------------------------------------------------

// ClientToServer_UpdateAircraftSituation

// int32 aircraft_id = 1;
inline void ClientToServer_UpdateAircraftSituation::clear_aircraft_id() {
  aircraft_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_UpdateAircraftSituation::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_UpdateAircraftSituation::aircraft_id() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.UpdateAircraftSituation.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_UpdateAircraftSituation::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_UpdateAircraftSituation::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.UpdateAircraftSituation.aircraft_id)
}

// .world_proto.Aircraft.Situation situation = 2;
inline bool ClientToServer_UpdateAircraftSituation::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool ClientToServer_UpdateAircraftSituation::has_situation() const {
  return _internal_has_situation();
}
inline void ClientToServer_UpdateAircraftSituation::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::world_proto::Aircraft_Situation& ClientToServer_UpdateAircraftSituation::_internal_situation() const {
  const ::world_proto::Aircraft_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Aircraft_Situation*>(
      &::world_proto::_Aircraft_Situation_default_instance_);
}
inline const ::world_proto::Aircraft_Situation& ClientToServer_UpdateAircraftSituation::situation() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.UpdateAircraftSituation.situation)
  return _internal_situation();
}
inline void ClientToServer_UpdateAircraftSituation::unsafe_arena_set_allocated_situation(
    ::world_proto::Aircraft_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.UpdateAircraftSituation.situation)
}
inline ::world_proto::Aircraft_Situation* ClientToServer_UpdateAircraftSituation::release_situation() {
  
  ::world_proto::Aircraft_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Aircraft_Situation* ClientToServer_UpdateAircraftSituation::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.UpdateAircraftSituation.situation)
  
  ::world_proto::Aircraft_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::world_proto::Aircraft_Situation* ClientToServer_UpdateAircraftSituation::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Aircraft_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::world_proto::Aircraft_Situation* ClientToServer_UpdateAircraftSituation::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.UpdateAircraftSituation.situation)
  return _internal_mutable_situation();
}
inline void ClientToServer_UpdateAircraftSituation::set_allocated_situation(::world_proto::Aircraft_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.UpdateAircraftSituation.situation)
}

// -------------------------------------------------------------------

// ClientToServer_RemoveAircraft

// int32 aircraft_id = 1;
inline void ClientToServer_RemoveAircraft::clear_aircraft_id() {
  aircraft_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_RemoveAircraft::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_RemoveAircraft::aircraft_id() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.RemoveAircraft.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_RemoveAircraft::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_RemoveAircraft::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.RemoveAircraft.aircraft_id)
}

// -------------------------------------------------------------------

// ClientToServer

// uint64 id = 1;
inline void ClientToServer::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientToServer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientToServer::id() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.id)
  return _internal_id();
}
inline void ClientToServer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void ClientToServer::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ClientToServer.id)
}

// .google.protobuf.Timestamp sent_at = 2;
inline bool ClientToServer::_internal_has_sent_at() const {
  return this != internal_default_instance() && sent_at_ != nullptr;
}
inline bool ClientToServer::has_sent_at() const {
  return _internal_has_sent_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ClientToServer::_internal_sent_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = sent_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ClientToServer::sent_at() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.sent_at)
  return _internal_sent_at();
}
inline void ClientToServer::unsafe_arena_set_allocated_sent_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  sent_at_ = sent_at;
  if (sent_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.sent_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::release_sent_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::unsafe_arena_release_sent_at() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.sent_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::_internal_mutable_sent_at() {
  
  if (sent_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    sent_at_ = p;
  }
  return sent_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::mutable_sent_at() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.sent_at)
  return _internal_mutable_sent_at();
}
inline void ClientToServer::set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  if (sent_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at)->GetArena();
    if (message_arena != submessage_arena) {
      sent_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sent_at, submessage_arena);
    }
    
  } else {
    
  }
  sent_at_ = sent_at;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ClientToServer.sent_at)
}

// .world_proto.ClientToServer.Connect connect = 101;
inline bool ClientToServer::_internal_has_connect() const {
  return payload_case() == kConnect;
}
inline bool ClientToServer::has_connect() const {
  return _internal_has_connect();
}
inline void ClientToServer::set_has_connect() {
  _oneof_case_[0] = kConnect;
}
inline void ClientToServer::clear_connect() {
  if (_internal_has_connect()) {
    if (GetArena() == nullptr) {
      delete payload_.connect_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ClientToServer_Connect* ClientToServer::release_connect() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.connect)
  if (_internal_has_connect()) {
    clear_has_payload();
      ::world_proto::ClientToServer_Connect* temp = payload_.connect_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ClientToServer_Connect& ClientToServer::_internal_connect() const {
  return _internal_has_connect()
      ? *payload_.connect_
      : *reinterpret_cast< ::world_proto::ClientToServer_Connect*>(&::world_proto::_ClientToServer_Connect_default_instance_);
}
inline const ::world_proto::ClientToServer_Connect& ClientToServer::connect() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.connect)
  return _internal_connect();
}
inline ::world_proto::ClientToServer_Connect* ClientToServer::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ClientToServer.connect)
  if (_internal_has_connect()) {
    clear_has_payload();
    ::world_proto::ClientToServer_Connect* temp = payload_.connect_;
    payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_connect(::world_proto::ClientToServer_Connect* connect) {
  clear_payload();
  if (connect) {
    set_has_connect();
    payload_.connect_ = connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.connect)
}
inline ::world_proto::ClientToServer_Connect* ClientToServer::_internal_mutable_connect() {
  if (!_internal_has_connect()) {
    clear_payload();
    set_has_connect();
    payload_.connect_ = CreateMaybeMessage< ::world_proto::ClientToServer_Connect >(GetArena());
  }
  return payload_.connect_;
}
inline ::world_proto::ClientToServer_Connect* ClientToServer::mutable_connect() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.connect)
  return _internal_mutable_connect();
}

// .world_proto.ClientToServer.QueryAirport query_airport = 102;
inline bool ClientToServer::_internal_has_query_airport() const {
  return payload_case() == kQueryAirport;
}
inline bool ClientToServer::has_query_airport() const {
  return _internal_has_query_airport();
}
inline void ClientToServer::set_has_query_airport() {
  _oneof_case_[0] = kQueryAirport;
}
inline void ClientToServer::clear_query_airport() {
  if (_internal_has_query_airport()) {
    if (GetArena() == nullptr) {
      delete payload_.query_airport_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ClientToServer_QueryAirport* ClientToServer::release_query_airport() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.query_airport)
  if (_internal_has_query_airport()) {
    clear_has_payload();
      ::world_proto::ClientToServer_QueryAirport* temp = payload_.query_airport_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ClientToServer_QueryAirport& ClientToServer::_internal_query_airport() const {
  return _internal_has_query_airport()
      ? *payload_.query_airport_
      : *reinterpret_cast< ::world_proto::ClientToServer_QueryAirport*>(&::world_proto::_ClientToServer_QueryAirport_default_instance_);
}
inline const ::world_proto::ClientToServer_QueryAirport& ClientToServer::query_airport() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.query_airport)
  return _internal_query_airport();
}
inline ::world_proto::ClientToServer_QueryAirport* ClientToServer::unsafe_arena_release_query_airport() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ClientToServer.query_airport)
  if (_internal_has_query_airport()) {
    clear_has_payload();
    ::world_proto::ClientToServer_QueryAirport* temp = payload_.query_airport_;
    payload_.query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_query_airport(::world_proto::ClientToServer_QueryAirport* query_airport) {
  clear_payload();
  if (query_airport) {
    set_has_query_airport();
    payload_.query_airport_ = query_airport;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.query_airport)
}
inline ::world_proto::ClientToServer_QueryAirport* ClientToServer::_internal_mutable_query_airport() {
  if (!_internal_has_query_airport()) {
    clear_payload();
    set_has_query_airport();
    payload_.query_airport_ = CreateMaybeMessage< ::world_proto::ClientToServer_QueryAirport >(GetArena());
  }
  return payload_.query_airport_;
}
inline ::world_proto::ClientToServer_QueryAirport* ClientToServer::mutable_query_airport() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.query_airport)
  return _internal_mutable_query_airport();
}

// .world_proto.ClientToServer.CreateAircraft create_aircraft = 103;
inline bool ClientToServer::_internal_has_create_aircraft() const {
  return payload_case() == kCreateAircraft;
}
inline bool ClientToServer::has_create_aircraft() const {
  return _internal_has_create_aircraft();
}
inline void ClientToServer::set_has_create_aircraft() {
  _oneof_case_[0] = kCreateAircraft;
}
inline void ClientToServer::clear_create_aircraft() {
  if (_internal_has_create_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.create_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ClientToServer_CreateAircraft* ClientToServer::release_create_aircraft() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.create_aircraft)
  if (_internal_has_create_aircraft()) {
    clear_has_payload();
      ::world_proto::ClientToServer_CreateAircraft* temp = payload_.create_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ClientToServer_CreateAircraft& ClientToServer::_internal_create_aircraft() const {
  return _internal_has_create_aircraft()
      ? *payload_.create_aircraft_
      : *reinterpret_cast< ::world_proto::ClientToServer_CreateAircraft*>(&::world_proto::_ClientToServer_CreateAircraft_default_instance_);
}
inline const ::world_proto::ClientToServer_CreateAircraft& ClientToServer::create_aircraft() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.create_aircraft)
  return _internal_create_aircraft();
}
inline ::world_proto::ClientToServer_CreateAircraft* ClientToServer::unsafe_arena_release_create_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ClientToServer.create_aircraft)
  if (_internal_has_create_aircraft()) {
    clear_has_payload();
    ::world_proto::ClientToServer_CreateAircraft* temp = payload_.create_aircraft_;
    payload_.create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_create_aircraft(::world_proto::ClientToServer_CreateAircraft* create_aircraft) {
  clear_payload();
  if (create_aircraft) {
    set_has_create_aircraft();
    payload_.create_aircraft_ = create_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.create_aircraft)
}
inline ::world_proto::ClientToServer_CreateAircraft* ClientToServer::_internal_mutable_create_aircraft() {
  if (!_internal_has_create_aircraft()) {
    clear_payload();
    set_has_create_aircraft();
    payload_.create_aircraft_ = CreateMaybeMessage< ::world_proto::ClientToServer_CreateAircraft >(GetArena());
  }
  return payload_.create_aircraft_;
}
inline ::world_proto::ClientToServer_CreateAircraft* ClientToServer::mutable_create_aircraft() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.create_aircraft)
  return _internal_mutable_create_aircraft();
}

// .world_proto.ClientToServer.UpdateAircraftSituation update_aircraft_situation = 104;
inline bool ClientToServer::_internal_has_update_aircraft_situation() const {
  return payload_case() == kUpdateAircraftSituation;
}
inline bool ClientToServer::has_update_aircraft_situation() const {
  return _internal_has_update_aircraft_situation();
}
inline void ClientToServer::set_has_update_aircraft_situation() {
  _oneof_case_[0] = kUpdateAircraftSituation;
}
inline void ClientToServer::clear_update_aircraft_situation() {
  if (_internal_has_update_aircraft_situation()) {
    if (GetArena() == nullptr) {
      delete payload_.update_aircraft_situation_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::release_update_aircraft_situation() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.update_aircraft_situation)
  if (_internal_has_update_aircraft_situation()) {
    clear_has_payload();
      ::world_proto::ClientToServer_UpdateAircraftSituation* temp = payload_.update_aircraft_situation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.update_aircraft_situation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ClientToServer_UpdateAircraftSituation& ClientToServer::_internal_update_aircraft_situation() const {
  return _internal_has_update_aircraft_situation()
      ? *payload_.update_aircraft_situation_
      : *reinterpret_cast< ::world_proto::ClientToServer_UpdateAircraftSituation*>(&::world_proto::_ClientToServer_UpdateAircraftSituation_default_instance_);
}
inline const ::world_proto::ClientToServer_UpdateAircraftSituation& ClientToServer::update_aircraft_situation() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.update_aircraft_situation)
  return _internal_update_aircraft_situation();
}
inline ::world_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::unsafe_arena_release_update_aircraft_situation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ClientToServer.update_aircraft_situation)
  if (_internal_has_update_aircraft_situation()) {
    clear_has_payload();
    ::world_proto::ClientToServer_UpdateAircraftSituation* temp = payload_.update_aircraft_situation_;
    payload_.update_aircraft_situation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_update_aircraft_situation(::world_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation) {
  clear_payload();
  if (update_aircraft_situation) {
    set_has_update_aircraft_situation();
    payload_.update_aircraft_situation_ = update_aircraft_situation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.update_aircraft_situation)
}
inline ::world_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::_internal_mutable_update_aircraft_situation() {
  if (!_internal_has_update_aircraft_situation()) {
    clear_payload();
    set_has_update_aircraft_situation();
    payload_.update_aircraft_situation_ = CreateMaybeMessage< ::world_proto::ClientToServer_UpdateAircraftSituation >(GetArena());
  }
  return payload_.update_aircraft_situation_;
}
inline ::world_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::mutable_update_aircraft_situation() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.update_aircraft_situation)
  return _internal_mutable_update_aircraft_situation();
}

// .world_proto.ClientToServer.RemoveAircraft remove_aircraft = 105;
inline bool ClientToServer::_internal_has_remove_aircraft() const {
  return payload_case() == kRemoveAircraft;
}
inline bool ClientToServer::has_remove_aircraft() const {
  return _internal_has_remove_aircraft();
}
inline void ClientToServer::set_has_remove_aircraft() {
  _oneof_case_[0] = kRemoveAircraft;
}
inline void ClientToServer::clear_remove_aircraft() {
  if (_internal_has_remove_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.remove_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ClientToServer_RemoveAircraft* ClientToServer::release_remove_aircraft() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.remove_aircraft)
  if (_internal_has_remove_aircraft()) {
    clear_has_payload();
      ::world_proto::ClientToServer_RemoveAircraft* temp = payload_.remove_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.remove_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ClientToServer_RemoveAircraft& ClientToServer::_internal_remove_aircraft() const {
  return _internal_has_remove_aircraft()
      ? *payload_.remove_aircraft_
      : *reinterpret_cast< ::world_proto::ClientToServer_RemoveAircraft*>(&::world_proto::_ClientToServer_RemoveAircraft_default_instance_);
}
inline const ::world_proto::ClientToServer_RemoveAircraft& ClientToServer::remove_aircraft() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.remove_aircraft)
  return _internal_remove_aircraft();
}
inline ::world_proto::ClientToServer_RemoveAircraft* ClientToServer::unsafe_arena_release_remove_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ClientToServer.remove_aircraft)
  if (_internal_has_remove_aircraft()) {
    clear_has_payload();
    ::world_proto::ClientToServer_RemoveAircraft* temp = payload_.remove_aircraft_;
    payload_.remove_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_remove_aircraft(::world_proto::ClientToServer_RemoveAircraft* remove_aircraft) {
  clear_payload();
  if (remove_aircraft) {
    set_has_remove_aircraft();
    payload_.remove_aircraft_ = remove_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.remove_aircraft)
}
inline ::world_proto::ClientToServer_RemoveAircraft* ClientToServer::_internal_mutable_remove_aircraft() {
  if (!_internal_has_remove_aircraft()) {
    clear_payload();
    set_has_remove_aircraft();
    payload_.remove_aircraft_ = CreateMaybeMessage< ::world_proto::ClientToServer_RemoveAircraft >(GetArena());
  }
  return payload_.remove_aircraft_;
}
inline ::world_proto::ClientToServer_RemoveAircraft* ClientToServer::mutable_remove_aircraft() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.remove_aircraft)
  return _internal_mutable_remove_aircraft();
}

// .world_proto.ClientToServer.QueryTaxiPath query_taxi_path = 106;
inline bool ClientToServer::_internal_has_query_taxi_path() const {
  return payload_case() == kQueryTaxiPath;
}
inline bool ClientToServer::has_query_taxi_path() const {
  return _internal_has_query_taxi_path();
}
inline void ClientToServer::set_has_query_taxi_path() {
  _oneof_case_[0] = kQueryTaxiPath;
}
inline void ClientToServer::clear_query_taxi_path() {
  if (_internal_has_query_taxi_path()) {
    if (GetArena() == nullptr) {
      delete payload_.query_taxi_path_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ClientToServer_QueryTaxiPath* ClientToServer::release_query_taxi_path() {
  // @@protoc_insertion_point(field_release:world_proto.ClientToServer.query_taxi_path)
  if (_internal_has_query_taxi_path()) {
    clear_has_payload();
      ::world_proto::ClientToServer_QueryTaxiPath* temp = payload_.query_taxi_path_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ClientToServer_QueryTaxiPath& ClientToServer::_internal_query_taxi_path() const {
  return _internal_has_query_taxi_path()
      ? *payload_.query_taxi_path_
      : *reinterpret_cast< ::world_proto::ClientToServer_QueryTaxiPath*>(&::world_proto::_ClientToServer_QueryTaxiPath_default_instance_);
}
inline const ::world_proto::ClientToServer_QueryTaxiPath& ClientToServer::query_taxi_path() const {
  // @@protoc_insertion_point(field_get:world_proto.ClientToServer.query_taxi_path)
  return _internal_query_taxi_path();
}
inline ::world_proto::ClientToServer_QueryTaxiPath* ClientToServer::unsafe_arena_release_query_taxi_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ClientToServer.query_taxi_path)
  if (_internal_has_query_taxi_path()) {
    clear_has_payload();
    ::world_proto::ClientToServer_QueryTaxiPath* temp = payload_.query_taxi_path_;
    payload_.query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_query_taxi_path(::world_proto::ClientToServer_QueryTaxiPath* query_taxi_path) {
  clear_payload();
  if (query_taxi_path) {
    set_has_query_taxi_path();
    payload_.query_taxi_path_ = query_taxi_path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ClientToServer.query_taxi_path)
}
inline ::world_proto::ClientToServer_QueryTaxiPath* ClientToServer::_internal_mutable_query_taxi_path() {
  if (!_internal_has_query_taxi_path()) {
    clear_payload();
    set_has_query_taxi_path();
    payload_.query_taxi_path_ = CreateMaybeMessage< ::world_proto::ClientToServer_QueryTaxiPath >(GetArena());
  }
  return payload_.query_taxi_path_;
}
inline ::world_proto::ClientToServer_QueryTaxiPath* ClientToServer::mutable_query_taxi_path() {
  // @@protoc_insertion_point(field_mutable:world_proto.ClientToServer.query_taxi_path)
  return _internal_mutable_query_taxi_path();
}

inline bool ClientToServer::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientToServer::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientToServer::PayloadCase ClientToServer::payload_case() const {
  return ClientToServer::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerToClient_FaultDeclined

// string message = 1;
inline void ServerToClient_FaultDeclined::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerToClient_FaultDeclined::message() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.FaultDeclined.message)
  return _internal_message();
}
inline void ServerToClient_FaultDeclined::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.FaultDeclined.message)
}
inline std::string* ServerToClient_FaultDeclined::mutable_message() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.FaultDeclined.message)
  return _internal_mutable_message();
}
inline const std::string& ServerToClient_FaultDeclined::_internal_message() const {
  return message_.Get();
}
inline void ServerToClient_FaultDeclined::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerToClient_FaultDeclined::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ServerToClient.FaultDeclined.message)
}
inline void ServerToClient_FaultDeclined::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ServerToClient.FaultDeclined.message)
}
inline void ServerToClient_FaultDeclined::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ServerToClient.FaultDeclined.message)
}
inline std::string* ServerToClient_FaultDeclined::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerToClient_FaultDeclined::release_message() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.FaultDeclined.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerToClient_FaultDeclined::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.FaultDeclined.message)
}

// -------------------------------------------------------------------

// ServerToClient_FaultNotFound

// string message = 1;
inline void ServerToClient_FaultNotFound::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerToClient_FaultNotFound::message() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.FaultNotFound.message)
  return _internal_message();
}
inline void ServerToClient_FaultNotFound::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.FaultNotFound.message)
}
inline std::string* ServerToClient_FaultNotFound::mutable_message() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.FaultNotFound.message)
  return _internal_mutable_message();
}
inline const std::string& ServerToClient_FaultNotFound::_internal_message() const {
  return message_.Get();
}
inline void ServerToClient_FaultNotFound::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerToClient_FaultNotFound::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ServerToClient.FaultNotFound.message)
}
inline void ServerToClient_FaultNotFound::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ServerToClient.FaultNotFound.message)
}
inline void ServerToClient_FaultNotFound::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ServerToClient.FaultNotFound.message)
}
inline std::string* ServerToClient_FaultNotFound::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerToClient_FaultNotFound::release_message() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.FaultNotFound.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerToClient_FaultNotFound::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.FaultNotFound.message)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyConnect

// string server_banner = 2;
inline void ServerToClient_ReplyConnect::clear_server_banner() {
  server_banner_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerToClient_ReplyConnect::server_banner() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.ReplyConnect.server_banner)
  return _internal_server_banner();
}
inline void ServerToClient_ReplyConnect::set_server_banner(const std::string& value) {
  _internal_set_server_banner(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.ReplyConnect.server_banner)
}
inline std::string* ServerToClient_ReplyConnect::mutable_server_banner() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.ReplyConnect.server_banner)
  return _internal_mutable_server_banner();
}
inline const std::string& ServerToClient_ReplyConnect::_internal_server_banner() const {
  return server_banner_.Get();
}
inline void ServerToClient_ReplyConnect::_internal_set_server_banner(const std::string& value) {
  
  server_banner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerToClient_ReplyConnect::set_server_banner(std::string&& value) {
  
  server_banner_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:world_proto.ServerToClient.ReplyConnect.server_banner)
}
inline void ServerToClient_ReplyConnect::set_server_banner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  server_banner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:world_proto.ServerToClient.ReplyConnect.server_banner)
}
inline void ServerToClient_ReplyConnect::set_server_banner(const char* value,
    size_t size) {
  
  server_banner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:world_proto.ServerToClient.ReplyConnect.server_banner)
}
inline std::string* ServerToClient_ReplyConnect::_internal_mutable_server_banner() {
  
  return server_banner_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerToClient_ReplyConnect::release_server_banner() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.ReplyConnect.server_banner)
  return server_banner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerToClient_ReplyConnect::set_allocated_server_banner(std::string* server_banner) {
  if (server_banner != nullptr) {
    
  } else {
    
  }
  server_banner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_banner,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.ReplyConnect.server_banner)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyCreateAircraft

// int32 created_aircraft_id = 1;
inline void ServerToClient_ReplyCreateAircraft::clear_created_aircraft_id() {
  created_aircraft_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerToClient_ReplyCreateAircraft::_internal_created_aircraft_id() const {
  return created_aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerToClient_ReplyCreateAircraft::created_aircraft_id() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.ReplyCreateAircraft.created_aircraft_id)
  return _internal_created_aircraft_id();
}
inline void ServerToClient_ReplyCreateAircraft::_internal_set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  created_aircraft_id_ = value;
}
inline void ServerToClient_ReplyCreateAircraft::set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_created_aircraft_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.ReplyCreateAircraft.created_aircraft_id)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyQueryAirport

// .world_proto.Airport airport = 1;
inline bool ServerToClient_ReplyQueryAirport::_internal_has_airport() const {
  return this != internal_default_instance() && airport_ != nullptr;
}
inline bool ServerToClient_ReplyQueryAirport::has_airport() const {
  return _internal_has_airport();
}
inline void ServerToClient_ReplyQueryAirport::clear_airport() {
  if (GetArena() == nullptr && airport_ != nullptr) {
    delete airport_;
  }
  airport_ = nullptr;
}
inline const ::world_proto::Airport& ServerToClient_ReplyQueryAirport::_internal_airport() const {
  const ::world_proto::Airport* p = airport_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Airport*>(
      &::world_proto::_Airport_default_instance_);
}
inline const ::world_proto::Airport& ServerToClient_ReplyQueryAirport::airport() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.ReplyQueryAirport.airport)
  return _internal_airport();
}
inline void ServerToClient_ReplyQueryAirport::unsafe_arena_set_allocated_airport(
    ::world_proto::Airport* airport) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(airport_);
  }
  airport_ = airport;
  if (airport) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.ReplyQueryAirport.airport)
}
inline ::world_proto::Airport* ServerToClient_ReplyQueryAirport::release_airport() {
  
  ::world_proto::Airport* temp = airport_;
  airport_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Airport* ServerToClient_ReplyQueryAirport::unsafe_arena_release_airport() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.ReplyQueryAirport.airport)
  
  ::world_proto::Airport* temp = airport_;
  airport_ = nullptr;
  return temp;
}
inline ::world_proto::Airport* ServerToClient_ReplyQueryAirport::_internal_mutable_airport() {
  
  if (airport_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Airport>(GetArena());
    airport_ = p;
  }
  return airport_;
}
inline ::world_proto::Airport* ServerToClient_ReplyQueryAirport::mutable_airport() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.ReplyQueryAirport.airport)
  return _internal_mutable_airport();
}
inline void ServerToClient_ReplyQueryAirport::set_allocated_airport(::world_proto::Airport* airport) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete airport_;
  }
  if (airport) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(airport);
    if (message_arena != submessage_arena) {
      airport = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, airport, submessage_arena);
    }
    
  } else {
    
  }
  airport_ = airport;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.ReplyQueryAirport.airport)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyQueryTaxiPath

// bool success = 1;
inline void ServerToClient_ReplyQueryTaxiPath::clear_success() {
  success_ = false;
}
inline bool ServerToClient_ReplyQueryTaxiPath::_internal_success() const {
  return success_;
}
inline bool ServerToClient_ReplyQueryTaxiPath::success() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.ReplyQueryTaxiPath.success)
  return _internal_success();
}
inline void ServerToClient_ReplyQueryTaxiPath::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ServerToClient_ReplyQueryTaxiPath::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.ReplyQueryTaxiPath.success)
}

// .world_proto.TaxiPath taxi_path = 2;
inline bool ServerToClient_ReplyQueryTaxiPath::_internal_has_taxi_path() const {
  return this != internal_default_instance() && taxi_path_ != nullptr;
}
inline bool ServerToClient_ReplyQueryTaxiPath::has_taxi_path() const {
  return _internal_has_taxi_path();
}
inline void ServerToClient_ReplyQueryTaxiPath::clear_taxi_path() {
  if (GetArena() == nullptr && taxi_path_ != nullptr) {
    delete taxi_path_;
  }
  taxi_path_ = nullptr;
}
inline const ::world_proto::TaxiPath& ServerToClient_ReplyQueryTaxiPath::_internal_taxi_path() const {
  const ::world_proto::TaxiPath* p = taxi_path_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::TaxiPath*>(
      &::world_proto::_TaxiPath_default_instance_);
}
inline const ::world_proto::TaxiPath& ServerToClient_ReplyQueryTaxiPath::taxi_path() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
  return _internal_taxi_path();
}
inline void ServerToClient_ReplyQueryTaxiPath::unsafe_arena_set_allocated_taxi_path(
    ::world_proto::TaxiPath* taxi_path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(taxi_path_);
  }
  taxi_path_ = taxi_path;
  if (taxi_path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
}
inline ::world_proto::TaxiPath* ServerToClient_ReplyQueryTaxiPath::release_taxi_path() {
  
  ::world_proto::TaxiPath* temp = taxi_path_;
  taxi_path_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::TaxiPath* ServerToClient_ReplyQueryTaxiPath::unsafe_arena_release_taxi_path() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
  
  ::world_proto::TaxiPath* temp = taxi_path_;
  taxi_path_ = nullptr;
  return temp;
}
inline ::world_proto::TaxiPath* ServerToClient_ReplyQueryTaxiPath::_internal_mutable_taxi_path() {
  
  if (taxi_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::TaxiPath>(GetArena());
    taxi_path_ = p;
  }
  return taxi_path_;
}
inline ::world_proto::TaxiPath* ServerToClient_ReplyQueryTaxiPath::mutable_taxi_path() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
  return _internal_mutable_taxi_path();
}
inline void ServerToClient_ReplyQueryTaxiPath::set_allocated_taxi_path(::world_proto::TaxiPath* taxi_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete taxi_path_;
  }
  if (taxi_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(taxi_path);
    if (message_arena != submessage_arena) {
      taxi_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taxi_path, submessage_arena);
    }
    
  } else {
    
  }
  taxi_path_ = taxi_path;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
}

// -------------------------------------------------------------------

// ServerToClient_NotifyAircraftCreated

// .world_proto.Aircraft aircraft = 1;
inline bool ServerToClient_NotifyAircraftCreated::_internal_has_aircraft() const {
  return this != internal_default_instance() && aircraft_ != nullptr;
}
inline bool ServerToClient_NotifyAircraftCreated::has_aircraft() const {
  return _internal_has_aircraft();
}
inline void ServerToClient_NotifyAircraftCreated::clear_aircraft() {
  if (GetArena() == nullptr && aircraft_ != nullptr) {
    delete aircraft_;
  }
  aircraft_ = nullptr;
}
inline const ::world_proto::Aircraft& ServerToClient_NotifyAircraftCreated::_internal_aircraft() const {
  const ::world_proto::Aircraft* p = aircraft_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Aircraft*>(
      &::world_proto::_Aircraft_default_instance_);
}
inline const ::world_proto::Aircraft& ServerToClient_NotifyAircraftCreated::aircraft() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.NotifyAircraftCreated.aircraft)
  return _internal_aircraft();
}
inline void ServerToClient_NotifyAircraftCreated::unsafe_arena_set_allocated_aircraft(
    ::world_proto::Aircraft* aircraft) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_);
  }
  aircraft_ = aircraft;
  if (aircraft) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.NotifyAircraftCreated.aircraft)
}
inline ::world_proto::Aircraft* ServerToClient_NotifyAircraftCreated::release_aircraft() {
  
  ::world_proto::Aircraft* temp = aircraft_;
  aircraft_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Aircraft* ServerToClient_NotifyAircraftCreated::unsafe_arena_release_aircraft() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.NotifyAircraftCreated.aircraft)
  
  ::world_proto::Aircraft* temp = aircraft_;
  aircraft_ = nullptr;
  return temp;
}
inline ::world_proto::Aircraft* ServerToClient_NotifyAircraftCreated::_internal_mutable_aircraft() {
  
  if (aircraft_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Aircraft>(GetArena());
    aircraft_ = p;
  }
  return aircraft_;
}
inline ::world_proto::Aircraft* ServerToClient_NotifyAircraftCreated::mutable_aircraft() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.NotifyAircraftCreated.aircraft)
  return _internal_mutable_aircraft();
}
inline void ServerToClient_NotifyAircraftCreated::set_allocated_aircraft(::world_proto::Aircraft* aircraft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_;
  }
  if (aircraft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft);
    if (message_arena != submessage_arena) {
      aircraft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_ = aircraft;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.NotifyAircraftCreated.aircraft)
}

// -------------------------------------------------------------------

// ServerToClient_NotifyAircraftSituationUpdated

// int32 airctaft_id = 1;
inline void ServerToClient_NotifyAircraftSituationUpdated::clear_airctaft_id() {
  airctaft_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerToClient_NotifyAircraftSituationUpdated::_internal_airctaft_id() const {
  return airctaft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerToClient_NotifyAircraftSituationUpdated::airctaft_id() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.NotifyAircraftSituationUpdated.airctaft_id)
  return _internal_airctaft_id();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::_internal_set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  airctaft_id_ = value;
}
inline void ServerToClient_NotifyAircraftSituationUpdated::set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_airctaft_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.NotifyAircraftSituationUpdated.airctaft_id)
}

// .world_proto.Aircraft.Situation situation = 2;
inline bool ServerToClient_NotifyAircraftSituationUpdated::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool ServerToClient_NotifyAircraftSituationUpdated::has_situation() const {
  return _internal_has_situation();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::world_proto::Aircraft_Situation& ServerToClient_NotifyAircraftSituationUpdated::_internal_situation() const {
  const ::world_proto::Aircraft_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world_proto::Aircraft_Situation*>(
      &::world_proto::_Aircraft_Situation_default_instance_);
}
inline const ::world_proto::Aircraft_Situation& ServerToClient_NotifyAircraftSituationUpdated::situation() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
  return _internal_situation();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::unsafe_arena_set_allocated_situation(
    ::world_proto::Aircraft_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
}
inline ::world_proto::Aircraft_Situation* ServerToClient_NotifyAircraftSituationUpdated::release_situation() {
  
  ::world_proto::Aircraft_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world_proto::Aircraft_Situation* ServerToClient_NotifyAircraftSituationUpdated::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
  
  ::world_proto::Aircraft_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::world_proto::Aircraft_Situation* ServerToClient_NotifyAircraftSituationUpdated::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::world_proto::Aircraft_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::world_proto::Aircraft_Situation* ServerToClient_NotifyAircraftSituationUpdated::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
  return _internal_mutable_situation();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::set_allocated_situation(::world_proto::Aircraft_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
}

// -------------------------------------------------------------------

// ServerToClient_NotifyAircraftRemoved

// int32 airctaft_id = 1;
inline void ServerToClient_NotifyAircraftRemoved::clear_airctaft_id() {
  airctaft_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerToClient_NotifyAircraftRemoved::_internal_airctaft_id() const {
  return airctaft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerToClient_NotifyAircraftRemoved::airctaft_id() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.NotifyAircraftRemoved.airctaft_id)
  return _internal_airctaft_id();
}
inline void ServerToClient_NotifyAircraftRemoved::_internal_set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  airctaft_id_ = value;
}
inline void ServerToClient_NotifyAircraftRemoved::set_airctaft_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_airctaft_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.NotifyAircraftRemoved.airctaft_id)
}

// -------------------------------------------------------------------

// ServerToClient

// uint64 id = 2;
inline void ServerToClient::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::id() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.id)
  return _internal_id();
}
inline void ServerToClient::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void ServerToClient::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.id)
}

// uint64 reply_to_request_id = 3;
inline void ServerToClient::clear_reply_to_request_id() {
  reply_to_request_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::_internal_reply_to_request_id() const {
  return reply_to_request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::reply_to_request_id() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.reply_to_request_id)
  return _internal_reply_to_request_id();
}
inline void ServerToClient::_internal_set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  reply_to_request_id_ = value;
}
inline void ServerToClient::set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_reply_to_request_id(value);
  // @@protoc_insertion_point(field_set:world_proto.ServerToClient.reply_to_request_id)
}

// .google.protobuf.Timestamp sent_at = 4;
inline bool ServerToClient::_internal_has_sent_at() const {
  return this != internal_default_instance() && sent_at_ != nullptr;
}
inline bool ServerToClient::has_sent_at() const {
  return _internal_has_sent_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::_internal_sent_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = sent_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::sent_at() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.sent_at)
  return _internal_sent_at();
}
inline void ServerToClient::unsafe_arena_set_allocated_sent_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  sent_at_ = sent_at;
  if (sent_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.sent_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::release_sent_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::unsafe_arena_release_sent_at() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.sent_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::_internal_mutable_sent_at() {
  
  if (sent_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    sent_at_ = p;
  }
  return sent_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::mutable_sent_at() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.sent_at)
  return _internal_mutable_sent_at();
}
inline void ServerToClient::set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  if (sent_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at)->GetArena();
    if (message_arena != submessage_arena) {
      sent_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sent_at, submessage_arena);
    }
    
  } else {
    
  }
  sent_at_ = sent_at;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.sent_at)
}

// .google.protobuf.Timestamp request_sent_at = 5;
inline bool ServerToClient::_internal_has_request_sent_at() const {
  return this != internal_default_instance() && request_sent_at_ != nullptr;
}
inline bool ServerToClient::has_request_sent_at() const {
  return _internal_has_request_sent_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::_internal_request_sent_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = request_sent_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::request_sent_at() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.request_sent_at)
  return _internal_request_sent_at();
}
inline void ServerToClient::unsafe_arena_set_allocated_request_sent_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_sent_at_);
  }
  request_sent_at_ = request_sent_at;
  if (request_sent_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.request_sent_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::release_request_sent_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_sent_at_;
  request_sent_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::unsafe_arena_release_request_sent_at() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.request_sent_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_sent_at_;
  request_sent_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::_internal_mutable_request_sent_at() {
  
  if (request_sent_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    request_sent_at_ = p;
  }
  return request_sent_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::mutable_request_sent_at() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.request_sent_at)
  return _internal_mutable_request_sent_at();
}
inline void ServerToClient::set_allocated_request_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_sent_at_);
  }
  if (request_sent_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_sent_at)->GetArena();
    if (message_arena != submessage_arena) {
      request_sent_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_sent_at, submessage_arena);
    }
    
  } else {
    
  }
  request_sent_at_ = request_sent_at;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.request_sent_at)
}

// .google.protobuf.Timestamp request_received_at = 6;
inline bool ServerToClient::_internal_has_request_received_at() const {
  return this != internal_default_instance() && request_received_at_ != nullptr;
}
inline bool ServerToClient::has_request_received_at() const {
  return _internal_has_request_received_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::_internal_request_received_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = request_received_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::request_received_at() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.request_received_at)
  return _internal_request_received_at();
}
inline void ServerToClient::unsafe_arena_set_allocated_request_received_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_received_at_);
  }
  request_received_at_ = request_received_at;
  if (request_received_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.request_received_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::release_request_received_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_received_at_;
  request_received_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::unsafe_arena_release_request_received_at() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.request_received_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_received_at_;
  request_received_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::_internal_mutable_request_received_at() {
  
  if (request_received_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    request_received_at_ = p;
  }
  return request_received_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::mutable_request_received_at() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.request_received_at)
  return _internal_mutable_request_received_at();
}
inline void ServerToClient::set_allocated_request_received_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_received_at_);
  }
  if (request_received_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_received_at)->GetArena();
    if (message_arena != submessage_arena) {
      request_received_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_received_at, submessage_arena);
    }
    
  } else {
    
  }
  request_received_at_ = request_received_at;
  // @@protoc_insertion_point(field_set_allocated:world_proto.ServerToClient.request_received_at)
}

// .world_proto.ServerToClient.ReplyConnect reply_connect = 1101;
inline bool ServerToClient::_internal_has_reply_connect() const {
  return payload_case() == kReplyConnect;
}
inline bool ServerToClient::has_reply_connect() const {
  return _internal_has_reply_connect();
}
inline void ServerToClient::set_has_reply_connect() {
  _oneof_case_[0] = kReplyConnect;
}
inline void ServerToClient::clear_reply_connect() {
  if (_internal_has_reply_connect()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_connect_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_ReplyConnect* ServerToClient::release_reply_connect() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.reply_connect)
  if (_internal_has_reply_connect()) {
    clear_has_payload();
      ::world_proto::ServerToClient_ReplyConnect* temp = payload_.reply_connect_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_ReplyConnect& ServerToClient::_internal_reply_connect() const {
  return _internal_has_reply_connect()
      ? *payload_.reply_connect_
      : *reinterpret_cast< ::world_proto::ServerToClient_ReplyConnect*>(&::world_proto::_ServerToClient_ReplyConnect_default_instance_);
}
inline const ::world_proto::ServerToClient_ReplyConnect& ServerToClient::reply_connect() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.reply_connect)
  return _internal_reply_connect();
}
inline ::world_proto::ServerToClient_ReplyConnect* ServerToClient::unsafe_arena_release_reply_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.reply_connect)
  if (_internal_has_reply_connect()) {
    clear_has_payload();
    ::world_proto::ServerToClient_ReplyConnect* temp = payload_.reply_connect_;
    payload_.reply_connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_connect(::world_proto::ServerToClient_ReplyConnect* reply_connect) {
  clear_payload();
  if (reply_connect) {
    set_has_reply_connect();
    payload_.reply_connect_ = reply_connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.reply_connect)
}
inline ::world_proto::ServerToClient_ReplyConnect* ServerToClient::_internal_mutable_reply_connect() {
  if (!_internal_has_reply_connect()) {
    clear_payload();
    set_has_reply_connect();
    payload_.reply_connect_ = CreateMaybeMessage< ::world_proto::ServerToClient_ReplyConnect >(GetArena());
  }
  return payload_.reply_connect_;
}
inline ::world_proto::ServerToClient_ReplyConnect* ServerToClient::mutable_reply_connect() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.reply_connect)
  return _internal_mutable_reply_connect();
}

// .world_proto.ServerToClient.ReplyQueryAirport reply_query_airport = 1102;
inline bool ServerToClient::_internal_has_reply_query_airport() const {
  return payload_case() == kReplyQueryAirport;
}
inline bool ServerToClient::has_reply_query_airport() const {
  return _internal_has_reply_query_airport();
}
inline void ServerToClient::set_has_reply_query_airport() {
  _oneof_case_[0] = kReplyQueryAirport;
}
inline void ServerToClient::clear_reply_query_airport() {
  if (_internal_has_reply_query_airport()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_query_airport_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_ReplyQueryAirport* ServerToClient::release_reply_query_airport() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.reply_query_airport)
  if (_internal_has_reply_query_airport()) {
    clear_has_payload();
      ::world_proto::ServerToClient_ReplyQueryAirport* temp = payload_.reply_query_airport_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_ReplyQueryAirport& ServerToClient::_internal_reply_query_airport() const {
  return _internal_has_reply_query_airport()
      ? *payload_.reply_query_airport_
      : *reinterpret_cast< ::world_proto::ServerToClient_ReplyQueryAirport*>(&::world_proto::_ServerToClient_ReplyQueryAirport_default_instance_);
}
inline const ::world_proto::ServerToClient_ReplyQueryAirport& ServerToClient::reply_query_airport() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.reply_query_airport)
  return _internal_reply_query_airport();
}
inline ::world_proto::ServerToClient_ReplyQueryAirport* ServerToClient::unsafe_arena_release_reply_query_airport() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.reply_query_airport)
  if (_internal_has_reply_query_airport()) {
    clear_has_payload();
    ::world_proto::ServerToClient_ReplyQueryAirport* temp = payload_.reply_query_airport_;
    payload_.reply_query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_query_airport(::world_proto::ServerToClient_ReplyQueryAirport* reply_query_airport) {
  clear_payload();
  if (reply_query_airport) {
    set_has_reply_query_airport();
    payload_.reply_query_airport_ = reply_query_airport;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.reply_query_airport)
}
inline ::world_proto::ServerToClient_ReplyQueryAirport* ServerToClient::_internal_mutable_reply_query_airport() {
  if (!_internal_has_reply_query_airport()) {
    clear_payload();
    set_has_reply_query_airport();
    payload_.reply_query_airport_ = CreateMaybeMessage< ::world_proto::ServerToClient_ReplyQueryAirport >(GetArena());
  }
  return payload_.reply_query_airport_;
}
inline ::world_proto::ServerToClient_ReplyQueryAirport* ServerToClient::mutable_reply_query_airport() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.reply_query_airport)
  return _internal_mutable_reply_query_airport();
}

// .world_proto.ServerToClient.ReplyCreateAircraft reply_create_aircraft = 1103;
inline bool ServerToClient::_internal_has_reply_create_aircraft() const {
  return payload_case() == kReplyCreateAircraft;
}
inline bool ServerToClient::has_reply_create_aircraft() const {
  return _internal_has_reply_create_aircraft();
}
inline void ServerToClient::set_has_reply_create_aircraft() {
  _oneof_case_[0] = kReplyCreateAircraft;
}
inline void ServerToClient::clear_reply_create_aircraft() {
  if (_internal_has_reply_create_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_create_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::release_reply_create_aircraft() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.reply_create_aircraft)
  if (_internal_has_reply_create_aircraft()) {
    clear_has_payload();
      ::world_proto::ServerToClient_ReplyCreateAircraft* temp = payload_.reply_create_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_ReplyCreateAircraft& ServerToClient::_internal_reply_create_aircraft() const {
  return _internal_has_reply_create_aircraft()
      ? *payload_.reply_create_aircraft_
      : *reinterpret_cast< ::world_proto::ServerToClient_ReplyCreateAircraft*>(&::world_proto::_ServerToClient_ReplyCreateAircraft_default_instance_);
}
inline const ::world_proto::ServerToClient_ReplyCreateAircraft& ServerToClient::reply_create_aircraft() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.reply_create_aircraft)
  return _internal_reply_create_aircraft();
}
inline ::world_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::unsafe_arena_release_reply_create_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.reply_create_aircraft)
  if (_internal_has_reply_create_aircraft()) {
    clear_has_payload();
    ::world_proto::ServerToClient_ReplyCreateAircraft* temp = payload_.reply_create_aircraft_;
    payload_.reply_create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_create_aircraft(::world_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft) {
  clear_payload();
  if (reply_create_aircraft) {
    set_has_reply_create_aircraft();
    payload_.reply_create_aircraft_ = reply_create_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.reply_create_aircraft)
}
inline ::world_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::_internal_mutable_reply_create_aircraft() {
  if (!_internal_has_reply_create_aircraft()) {
    clear_payload();
    set_has_reply_create_aircraft();
    payload_.reply_create_aircraft_ = CreateMaybeMessage< ::world_proto::ServerToClient_ReplyCreateAircraft >(GetArena());
  }
  return payload_.reply_create_aircraft_;
}
inline ::world_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::mutable_reply_create_aircraft() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.reply_create_aircraft)
  return _internal_mutable_reply_create_aircraft();
}

// .world_proto.ServerToClient.ReplyQueryTaxiPath reply_query_taxi_path = 1106;
inline bool ServerToClient::_internal_has_reply_query_taxi_path() const {
  return payload_case() == kReplyQueryTaxiPath;
}
inline bool ServerToClient::has_reply_query_taxi_path() const {
  return _internal_has_reply_query_taxi_path();
}
inline void ServerToClient::set_has_reply_query_taxi_path() {
  _oneof_case_[0] = kReplyQueryTaxiPath;
}
inline void ServerToClient::clear_reply_query_taxi_path() {
  if (_internal_has_reply_query_taxi_path()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_query_taxi_path_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::release_reply_query_taxi_path() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.reply_query_taxi_path)
  if (_internal_has_reply_query_taxi_path()) {
    clear_has_payload();
      ::world_proto::ServerToClient_ReplyQueryTaxiPath* temp = payload_.reply_query_taxi_path_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_ReplyQueryTaxiPath& ServerToClient::_internal_reply_query_taxi_path() const {
  return _internal_has_reply_query_taxi_path()
      ? *payload_.reply_query_taxi_path_
      : *reinterpret_cast< ::world_proto::ServerToClient_ReplyQueryTaxiPath*>(&::world_proto::_ServerToClient_ReplyQueryTaxiPath_default_instance_);
}
inline const ::world_proto::ServerToClient_ReplyQueryTaxiPath& ServerToClient::reply_query_taxi_path() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.reply_query_taxi_path)
  return _internal_reply_query_taxi_path();
}
inline ::world_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::unsafe_arena_release_reply_query_taxi_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.reply_query_taxi_path)
  if (_internal_has_reply_query_taxi_path()) {
    clear_has_payload();
    ::world_proto::ServerToClient_ReplyQueryTaxiPath* temp = payload_.reply_query_taxi_path_;
    payload_.reply_query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_query_taxi_path(::world_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path) {
  clear_payload();
  if (reply_query_taxi_path) {
    set_has_reply_query_taxi_path();
    payload_.reply_query_taxi_path_ = reply_query_taxi_path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.reply_query_taxi_path)
}
inline ::world_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::_internal_mutable_reply_query_taxi_path() {
  if (!_internal_has_reply_query_taxi_path()) {
    clear_payload();
    set_has_reply_query_taxi_path();
    payload_.reply_query_taxi_path_ = CreateMaybeMessage< ::world_proto::ServerToClient_ReplyQueryTaxiPath >(GetArena());
  }
  return payload_.reply_query_taxi_path_;
}
inline ::world_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::mutable_reply_query_taxi_path() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.reply_query_taxi_path)
  return _internal_mutable_reply_query_taxi_path();
}

// .world_proto.ServerToClient.NotifyAircraftCreated notify_aircraft_created = 201;
inline bool ServerToClient::_internal_has_notify_aircraft_created() const {
  return payload_case() == kNotifyAircraftCreated;
}
inline bool ServerToClient::has_notify_aircraft_created() const {
  return _internal_has_notify_aircraft_created();
}
inline void ServerToClient::set_has_notify_aircraft_created() {
  _oneof_case_[0] = kNotifyAircraftCreated;
}
inline void ServerToClient::clear_notify_aircraft_created() {
  if (_internal_has_notify_aircraft_created()) {
    if (GetArena() == nullptr) {
      delete payload_.notify_aircraft_created_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::release_notify_aircraft_created() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.notify_aircraft_created)
  if (_internal_has_notify_aircraft_created()) {
    clear_has_payload();
      ::world_proto::ServerToClient_NotifyAircraftCreated* temp = payload_.notify_aircraft_created_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.notify_aircraft_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_NotifyAircraftCreated& ServerToClient::_internal_notify_aircraft_created() const {
  return _internal_has_notify_aircraft_created()
      ? *payload_.notify_aircraft_created_
      : *reinterpret_cast< ::world_proto::ServerToClient_NotifyAircraftCreated*>(&::world_proto::_ServerToClient_NotifyAircraftCreated_default_instance_);
}
inline const ::world_proto::ServerToClient_NotifyAircraftCreated& ServerToClient::notify_aircraft_created() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.notify_aircraft_created)
  return _internal_notify_aircraft_created();
}
inline ::world_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::unsafe_arena_release_notify_aircraft_created() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.notify_aircraft_created)
  if (_internal_has_notify_aircraft_created()) {
    clear_has_payload();
    ::world_proto::ServerToClient_NotifyAircraftCreated* temp = payload_.notify_aircraft_created_;
    payload_.notify_aircraft_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_notify_aircraft_created(::world_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created) {
  clear_payload();
  if (notify_aircraft_created) {
    set_has_notify_aircraft_created();
    payload_.notify_aircraft_created_ = notify_aircraft_created;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.notify_aircraft_created)
}
inline ::world_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::_internal_mutable_notify_aircraft_created() {
  if (!_internal_has_notify_aircraft_created()) {
    clear_payload();
    set_has_notify_aircraft_created();
    payload_.notify_aircraft_created_ = CreateMaybeMessage< ::world_proto::ServerToClient_NotifyAircraftCreated >(GetArena());
  }
  return payload_.notify_aircraft_created_;
}
inline ::world_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::mutable_notify_aircraft_created() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.notify_aircraft_created)
  return _internal_mutable_notify_aircraft_created();
}

// .world_proto.ServerToClient.NotifyAircraftSituationUpdated notify_aircraft_situation_updated = 202;
inline bool ServerToClient::_internal_has_notify_aircraft_situation_updated() const {
  return payload_case() == kNotifyAircraftSituationUpdated;
}
inline bool ServerToClient::has_notify_aircraft_situation_updated() const {
  return _internal_has_notify_aircraft_situation_updated();
}
inline void ServerToClient::set_has_notify_aircraft_situation_updated() {
  _oneof_case_[0] = kNotifyAircraftSituationUpdated;
}
inline void ServerToClient::clear_notify_aircraft_situation_updated() {
  if (_internal_has_notify_aircraft_situation_updated()) {
    if (GetArena() == nullptr) {
      delete payload_.notify_aircraft_situation_updated_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::release_notify_aircraft_situation_updated() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.notify_aircraft_situation_updated)
  if (_internal_has_notify_aircraft_situation_updated()) {
    clear_has_payload();
      ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* temp = payload_.notify_aircraft_situation_updated_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.notify_aircraft_situation_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_NotifyAircraftSituationUpdated& ServerToClient::_internal_notify_aircraft_situation_updated() const {
  return _internal_has_notify_aircraft_situation_updated()
      ? *payload_.notify_aircraft_situation_updated_
      : *reinterpret_cast< ::world_proto::ServerToClient_NotifyAircraftSituationUpdated*>(&::world_proto::_ServerToClient_NotifyAircraftSituationUpdated_default_instance_);
}
inline const ::world_proto::ServerToClient_NotifyAircraftSituationUpdated& ServerToClient::notify_aircraft_situation_updated() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.notify_aircraft_situation_updated)
  return _internal_notify_aircraft_situation_updated();
}
inline ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::unsafe_arena_release_notify_aircraft_situation_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.notify_aircraft_situation_updated)
  if (_internal_has_notify_aircraft_situation_updated()) {
    clear_has_payload();
    ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* temp = payload_.notify_aircraft_situation_updated_;
    payload_.notify_aircraft_situation_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_notify_aircraft_situation_updated(::world_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated) {
  clear_payload();
  if (notify_aircraft_situation_updated) {
    set_has_notify_aircraft_situation_updated();
    payload_.notify_aircraft_situation_updated_ = notify_aircraft_situation_updated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.notify_aircraft_situation_updated)
}
inline ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::_internal_mutable_notify_aircraft_situation_updated() {
  if (!_internal_has_notify_aircraft_situation_updated()) {
    clear_payload();
    set_has_notify_aircraft_situation_updated();
    payload_.notify_aircraft_situation_updated_ = CreateMaybeMessage< ::world_proto::ServerToClient_NotifyAircraftSituationUpdated >(GetArena());
  }
  return payload_.notify_aircraft_situation_updated_;
}
inline ::world_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::mutable_notify_aircraft_situation_updated() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.notify_aircraft_situation_updated)
  return _internal_mutable_notify_aircraft_situation_updated();
}

// .world_proto.ServerToClient.NotifyAircraftRemoved notify_aircraft_removed = 203;
inline bool ServerToClient::_internal_has_notify_aircraft_removed() const {
  return payload_case() == kNotifyAircraftRemoved;
}
inline bool ServerToClient::has_notify_aircraft_removed() const {
  return _internal_has_notify_aircraft_removed();
}
inline void ServerToClient::set_has_notify_aircraft_removed() {
  _oneof_case_[0] = kNotifyAircraftRemoved;
}
inline void ServerToClient::clear_notify_aircraft_removed() {
  if (_internal_has_notify_aircraft_removed()) {
    if (GetArena() == nullptr) {
      delete payload_.notify_aircraft_removed_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::release_notify_aircraft_removed() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.notify_aircraft_removed)
  if (_internal_has_notify_aircraft_removed()) {
    clear_has_payload();
      ::world_proto::ServerToClient_NotifyAircraftRemoved* temp = payload_.notify_aircraft_removed_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.notify_aircraft_removed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_NotifyAircraftRemoved& ServerToClient::_internal_notify_aircraft_removed() const {
  return _internal_has_notify_aircraft_removed()
      ? *payload_.notify_aircraft_removed_
      : *reinterpret_cast< ::world_proto::ServerToClient_NotifyAircraftRemoved*>(&::world_proto::_ServerToClient_NotifyAircraftRemoved_default_instance_);
}
inline const ::world_proto::ServerToClient_NotifyAircraftRemoved& ServerToClient::notify_aircraft_removed() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.notify_aircraft_removed)
  return _internal_notify_aircraft_removed();
}
inline ::world_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::unsafe_arena_release_notify_aircraft_removed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.notify_aircraft_removed)
  if (_internal_has_notify_aircraft_removed()) {
    clear_has_payload();
    ::world_proto::ServerToClient_NotifyAircraftRemoved* temp = payload_.notify_aircraft_removed_;
    payload_.notify_aircraft_removed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_notify_aircraft_removed(::world_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed) {
  clear_payload();
  if (notify_aircraft_removed) {
    set_has_notify_aircraft_removed();
    payload_.notify_aircraft_removed_ = notify_aircraft_removed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.notify_aircraft_removed)
}
inline ::world_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::_internal_mutable_notify_aircraft_removed() {
  if (!_internal_has_notify_aircraft_removed()) {
    clear_payload();
    set_has_notify_aircraft_removed();
    payload_.notify_aircraft_removed_ = CreateMaybeMessage< ::world_proto::ServerToClient_NotifyAircraftRemoved >(GetArena());
  }
  return payload_.notify_aircraft_removed_;
}
inline ::world_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::mutable_notify_aircraft_removed() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.notify_aircraft_removed)
  return _internal_mutable_notify_aircraft_removed();
}

// .world_proto.ServerToClient.FaultDeclined fault_declined = 3001;
inline bool ServerToClient::_internal_has_fault_declined() const {
  return payload_case() == kFaultDeclined;
}
inline bool ServerToClient::has_fault_declined() const {
  return _internal_has_fault_declined();
}
inline void ServerToClient::set_has_fault_declined() {
  _oneof_case_[0] = kFaultDeclined;
}
inline void ServerToClient::clear_fault_declined() {
  if (_internal_has_fault_declined()) {
    if (GetArena() == nullptr) {
      delete payload_.fault_declined_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_FaultDeclined* ServerToClient::release_fault_declined() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.fault_declined)
  if (_internal_has_fault_declined()) {
    clear_has_payload();
      ::world_proto::ServerToClient_FaultDeclined* temp = payload_.fault_declined_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.fault_declined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_FaultDeclined& ServerToClient::_internal_fault_declined() const {
  return _internal_has_fault_declined()
      ? *payload_.fault_declined_
      : *reinterpret_cast< ::world_proto::ServerToClient_FaultDeclined*>(&::world_proto::_ServerToClient_FaultDeclined_default_instance_);
}
inline const ::world_proto::ServerToClient_FaultDeclined& ServerToClient::fault_declined() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.fault_declined)
  return _internal_fault_declined();
}
inline ::world_proto::ServerToClient_FaultDeclined* ServerToClient::unsafe_arena_release_fault_declined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.fault_declined)
  if (_internal_has_fault_declined()) {
    clear_has_payload();
    ::world_proto::ServerToClient_FaultDeclined* temp = payload_.fault_declined_;
    payload_.fault_declined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_fault_declined(::world_proto::ServerToClient_FaultDeclined* fault_declined) {
  clear_payload();
  if (fault_declined) {
    set_has_fault_declined();
    payload_.fault_declined_ = fault_declined;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.fault_declined)
}
inline ::world_proto::ServerToClient_FaultDeclined* ServerToClient::_internal_mutable_fault_declined() {
  if (!_internal_has_fault_declined()) {
    clear_payload();
    set_has_fault_declined();
    payload_.fault_declined_ = CreateMaybeMessage< ::world_proto::ServerToClient_FaultDeclined >(GetArena());
  }
  return payload_.fault_declined_;
}
inline ::world_proto::ServerToClient_FaultDeclined* ServerToClient::mutable_fault_declined() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.fault_declined)
  return _internal_mutable_fault_declined();
}

// .world_proto.ServerToClient.FaultNotFound fault_not_found = 3002;
inline bool ServerToClient::_internal_has_fault_not_found() const {
  return payload_case() == kFaultNotFound;
}
inline bool ServerToClient::has_fault_not_found() const {
  return _internal_has_fault_not_found();
}
inline void ServerToClient::set_has_fault_not_found() {
  _oneof_case_[0] = kFaultNotFound;
}
inline void ServerToClient::clear_fault_not_found() {
  if (_internal_has_fault_not_found()) {
    if (GetArena() == nullptr) {
      delete payload_.fault_not_found_;
    }
    clear_has_payload();
  }
}
inline ::world_proto::ServerToClient_FaultNotFound* ServerToClient::release_fault_not_found() {
  // @@protoc_insertion_point(field_release:world_proto.ServerToClient.fault_not_found)
  if (_internal_has_fault_not_found()) {
    clear_has_payload();
      ::world_proto::ServerToClient_FaultNotFound* temp = payload_.fault_not_found_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.fault_not_found_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::world_proto::ServerToClient_FaultNotFound& ServerToClient::_internal_fault_not_found() const {
  return _internal_has_fault_not_found()
      ? *payload_.fault_not_found_
      : *reinterpret_cast< ::world_proto::ServerToClient_FaultNotFound*>(&::world_proto::_ServerToClient_FaultNotFound_default_instance_);
}
inline const ::world_proto::ServerToClient_FaultNotFound& ServerToClient::fault_not_found() const {
  // @@protoc_insertion_point(field_get:world_proto.ServerToClient.fault_not_found)
  return _internal_fault_not_found();
}
inline ::world_proto::ServerToClient_FaultNotFound* ServerToClient::unsafe_arena_release_fault_not_found() {
  // @@protoc_insertion_point(field_unsafe_arena_release:world_proto.ServerToClient.fault_not_found)
  if (_internal_has_fault_not_found()) {
    clear_has_payload();
    ::world_proto::ServerToClient_FaultNotFound* temp = payload_.fault_not_found_;
    payload_.fault_not_found_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_fault_not_found(::world_proto::ServerToClient_FaultNotFound* fault_not_found) {
  clear_payload();
  if (fault_not_found) {
    set_has_fault_not_found();
    payload_.fault_not_found_ = fault_not_found;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world_proto.ServerToClient.fault_not_found)
}
inline ::world_proto::ServerToClient_FaultNotFound* ServerToClient::_internal_mutable_fault_not_found() {
  if (!_internal_has_fault_not_found()) {
    clear_payload();
    set_has_fault_not_found();
    payload_.fault_not_found_ = CreateMaybeMessage< ::world_proto::ServerToClient_FaultNotFound >(GetArena());
  }
  return payload_.fault_not_found_;
}
inline ::world_proto::ServerToClient_FaultNotFound* ServerToClient::mutable_fault_not_found() {
  // @@protoc_insertion_point(field_mutable:world_proto.ServerToClient.fault_not_found)
  return _internal_mutable_fault_not_found();
}

inline bool ServerToClient::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerToClient::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerToClient::PayloadCase ServerToClient::payload_case() const {
  return ServerToClient::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace world_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::world_proto::Aircraft_Category> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::Aircraft_Category>() {
  return ::world_proto::Aircraft_Category_descriptor();
}
template <> struct is_proto_enum< ::world_proto::Aircraft_OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::Aircraft_OperationType>() {
  return ::world_proto::Aircraft_OperationType_descriptor();
}
template <> struct is_proto_enum< ::world_proto::TaxiEdge_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::TaxiEdge_Type>() {
  return ::world_proto::TaxiEdge_Type_descriptor();
}
template <> struct is_proto_enum< ::world_proto::ParkingStand_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::ParkingStand_Type>() {
  return ::world_proto::ParkingStand_Type_descriptor();
}
template <> struct is_proto_enum< ::world_proto::GeoPolygon_GeoEdgeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::GeoPolygon_GeoEdgeType>() {
  return ::world_proto::GeoPolygon_GeoEdgeType_descriptor();
}
template <> struct is_proto_enum< ::world_proto::ControlledAirspace_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::ControlledAirspace_Type>() {
  return ::world_proto::ControlledAirspace_Type_descriptor();
}
template <> struct is_proto_enum< ::world_proto::ControlledAirspace_Classification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::ControlledAirspace_Classification>() {
  return ::world_proto::ControlledAirspace_Classification_descriptor();
}
template <> struct is_proto_enum< ::world_proto::ControlFacility_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world_proto::ControlFacility_Type>() {
  return ::world_proto::ControlFacility_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_world_2eproto
